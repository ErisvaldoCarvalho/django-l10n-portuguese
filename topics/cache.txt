..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9441 $
..   $TranslationAuthors: Walter Cruz $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..

.. _topics-cache:

==============================
O framework de cache do Django
==============================

Uma dilema essencial dos sites dinâmicos vem a ser o próprio fato de serem dinâmicos. 
Cada vez que um usuário requisita uma página, o servidor web faz todo o tipo de 
cálculos -- consultas a bancos de dados, renderização de templates e lógica de negócio -- 
para criar a página que o seu visitante vê. Isso tem um custo de processamento
muito maior que apenas a leitura de arquivos estáticos no disco.

Para a maior parte dos aplicativos Web, esse overhead não é um problema. A maior
parte das aplicações Web não são o washingtonpost.com oouslashdot.org; são simplesmente sites
pequenos a médio com tráfico equivalente. Mas para aplicações de porte mério para grante,
é essencial eliminar toda a sobrecarga possível.

É onde entra o cache.

Fazer o cache de algo é gravar o resultado de um cálculo custoso para que
você não tenha de executar o cálculo da próxima vez. Aqui está um pseudocódigo
explicando como isso funcionaria para uma página Web gerada dinamicamente::

    tente encontrar uma página no cache para tal URL
    se a página estiver no cache:
        retorne a página do cache
    se não:
        gere a página
        guarde a página gerada no cache (para a próxima vez)
        retorne a página gerada

O Django vem com um sistema de cache robusto que permite que você guarde as páginas dinâmicas para que
elas não tenham de ser calculadas a cada requisição. Por conveniência, Django
oferece diferentes níveis de granularidade de cache: Você pode fazer o cache da saída de
views específicas, você pode fazer o cache somente das partes que são difíceis de produzir, ou
pode fazer o cache do site inteiro.

O Django também trabalha com caches do tipo "upstream", como o Squid
(http://www.squid-cache.org/) e cache baseado em navegador. Esses são tipos de cache
que você não controla diretamente mas para os quais fornece dicas (via
cabeçalhos HTTP) sobre quais partes do seu site devem ser mantidas em cache, e como.

Configurando o cache
====================

O sistema de cache requer uma pequena configuração. Você deve informar
ao Django onde os seus dados em cache estarão -- se em um banco de dados, no sistema de
arquivos ou diretamente na memória. Essa é uma decisão importante que afeta a performance
do seu cache; sim, algums tipos de cache são mais rápidos que outros.

Sua preferência de cache vai na configuração ``CACHE_BACKEND`` no seu arquivo de
configurações. Aqui vai uma explicação de todos os valores disponíveis para
CACHE_BACKEND.

Memcached
---------

De longe, o mais rápido e mais eficiente tipo de cache disponível no Django, Memcached
é um framework de cache inteiramente baseado em memória originalmente desenvolvido para
lidar com as altas cargas no LiveJournal.com e subsequentemente tornada open-sourced pela Danga 
Interactive. É usado por sites como o Slashdot ou Wikipedia para reduzir o acesso a banco de dados
e aumentar a performance do site drasticamente.

O Memcached está disponível de graça em http://danga.com/memcached/ . Ele executa como um
daemon, para o qual é alocada uma quantidade específica de RAM. Tudo o que ele faz é fornecer
uma interface -- um interface *super-ultra-rápida* -- para adição, busca e
remoção de dados arbitrários do cache. Todos os dados são gravador diretamente na memória,
então não existe sobrecarga de banco de dados ou uso do filesystem.

Após a instalação do Memcached, você precisa instalar as bibliotecas do Memcached para
Python. Duas versões estão disponíveis. Selecione e instale *um* dos
seguintes módulos:

    * A opção mais rápida é um módulo chamado ``cmemcache``, disponível
      em http://gijsbert.org/cmemcache/ .

    * Se você não pode instalar o ``cmemcache``, você pode instalar o ``python-memcached``,
      disponível em ftp://ftp.tummy.com/pub/python-memcached/ . Se essa URL não
      é mais válida, apenas vá ao site do Memcached
      (http://www.danga.com/memcached/) e obtenha as bibliotecas Python da seção
      "Client APIs".

.. versionadded:: 1.0
    A opção ``cmemcache`` é nova no 1.0. Anteriormente, somente o
    ``python-memcached`` era suportado.

Para usar o Memcached com Django, configure o  ``CACHE_BACKEND`` para
``memcached://ip:port/``, onde ``ip`` é o endereço IP dp daemon do Memcached
e o ``port`` é a porta onde o Memcached está rodando.

Nesse exemplo, o Memcached está rodando em localhost (127.0.0.1) na porta 11211::

    CACHE_BACKEND = 'memcached://127.0.0.1:11211/'

Uma característica excelente do Memcached é sua habilidade de compartilhar o cache
em diversos servidores. Para aproveitar essa funcionalidade, inclua todos os endereços 
de servidores em ``CACHE_BACKEND``, separados por ponto e vírgula. Nesse exemplo, o cache é
compartilhado por instâncias do  Memcached rodando nos endereços IP 172.19.26.240 e
172.19.26.242, ambos na porta 11211::

    CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11211/'

O cache baseado em memória tem uma desvantagem: Como os dados em cache estão na
memória, serão perdidos se o seu servidor travar. Claramente, a memória não
foi feita para armazenamento permanente de dados, então não confie no cache em 
memória como sua única fonte de armazenamento de dados. Na verdade, nenhum dos
backends de cache do Django deve ser usado para armazenamento permanente -- 
devem ser usados como soluções para cache, e não armazenamento -- mas
reafirmamos isso aqui porque o cache em memória é realmente temporário.

Cache em banco de dados
-----------------------

Para usar uma tabela do banco de dados como o seu backend de cache, primeiro 
crie uma tabela de cache em seu banco de dados com o seguinte comando::

    python manage.py createcachetable [cache_table_name]

...onde ``[cache_table_name]`` é o nome da tabela no banco de dados a ser criada.
(Esse nome pode ser qualquer um, desde que seja um nome válido de tabela e esse nome
ainda não esteja sendo usado no seu banco de dados.) Esse comando cria uma única tabela
no seu banco de dados, no formato apropriado que o sistema de cache em banco de dados
do Django espera encontrar.

Uma vez que você tenha configurado a tabela do banco de dados, configure o seu ``CACHE_BACKEND``
para ``"db://tablename"``, onde ``tablename`` é o nome da tabela.
Nesse exemplo, o nome da tabela de cache é ``my_cache_table``::

    CACHE_BACKEND = 'db://my_cache_table'

O cache em banco de dados funciona melhor se você tem um servidor de banco de dados rápido
e bem indexado.

Cache em sistema de arquivos
----------------------------

Para gravar os items em cache no sistema de arquivos, use o tipo de cache ``"file://"``
para ``CACHE_BACKEND``. Por exemplo, para salvar os dados do cache em ``/var/tmp/django_cache``,
use essa configuração::

    CACHE_BACKEND = 'file:///var/tmp/django_cache'

Perceba que existem três barras próximas ao início do exemplo.
As primeiras são para o ``file://``, e a terceira é o primeiro caractere do
caminho do diretório, ``/var/tmp/django_cache``.

O caminho do diretório deve ser absoluto -- isso é, ele deve iniciar na raiz
do seu sistema de arquivos. Não faz diferença se você põe a barra no final
da configuração.

Assegure-se que o diretório apontado por essa configuração exista e tenha permissões
de leitura e escrita pelo usuário do sistema que executa o seu servidor web. 
Continuando o exemplo acima, se o seu servidor web roda como o usuário ``apache``, 
tenha certeza que o diretório ``/var/tmp/django_cache`` exista e tenha permissão de
leitura e escrita pelo usuário ``apache``.

Cache em memória local
----------------------

Se você quer as vantagens de velocidade de executar um cache em memória mas não
pode executar o  Memcached, considere o backend de cache em memória local. Esse
cache é multi-processo e thread-safe. Para usá-lo, configure o ``CACHE_BACKEND`` para
``"locmem:///"``. Por exemplo::

    CACHE_BACKEND = 'locmem:///'
    
Note que cada processo irá ter sua própria instância privada de cache, o que significa
que nenhum cache entre processos é possível. Isso obviamente significa que o cache em
memória local não é muito eficiente em termos de memória, então provavelmente não é
uma boa escolha para um ambiente de produção.

Cache falso (para desenvolvimento)
----------------------------------

Finalmente, o Django vem com um cache "falso" que não faz cache realmente -- ele
apenas implementa a interface de cache sem fazer nada realmente.

Isso é útil se você tem um site em produção que usa cacheamento pesado em
vários lugares, mas em desenvolvimento ou no ambiente de testes você não quer
usar cache. Como resultado, o seu ambiente de desenvolvimento não vai usar cache, 
mas o seu ambiente de produção irá. Para ativar o cache falso, configure o
``CACHE_BACKEND`` assim::

    CACHE_BACKEND = 'dummy:///'

Usando um backend de cache personalizado
----------------------------------------

.. versionadded:: 1.0

Apesar do Django suportar diversos sistemas de cache diferentes,
algumas vezes você pode querer usar algum backend de cache personalizado. Para usar um
backend externo de cache com o  Django, use um caminho de importação de módulos do Python
como a parte do esquema (a parte que vem antes do dois pontos inicial) da URI do
``CACHE_BACKEND``, assim::

    CACHE_BACKEND = 'path.to.backend://'

Se você está construindo o seu próprio backend, você pode usar os backends padrão
de cache como implementações de referência. Você irá encontrar o código no diretório
``django/core/cache/backends/`` dos fontes do Django.

Nota: Você deveria usar os backends de cache incluídos com o Django, anão ser que você
tenha uma razão muito boa, como um host que não os suporta. Eles foram
bem testados e são fáceis de usar.

argumentos do CACHE_BACKEND
---------------------------

Todos os tipos de cache podem receber argumentos. Eles são informados em um estilo  query-string
semelhante a configuração ``CACHE_BACKEND``. Argumentos válidos são:

    timeout
        Timeout padrão, em segundos, a ser usado para o cache. O padrão é 5
        minutos (300 segundos).

    max_entries
        Para o cache simples e em banco de dados, o número máximo de entradas
        permitidas no cache antes dele ser limpo. O padrão é 300.

    cull_percentage
        A porcentagem de entradas que são limpas do cache quando max_entries é atingido.
        A porcentagem real é 1/cull_percentage, então configure o cull_percentage=3 para
        limpar 1/3 das entradas quando o valor de max_entries é atingido.

        Um valor de 0 fpara o cull_percentage significa que o cache todo
        será limpo quando max_entries for atingido. Isso torna a limpeza *muito* mais rápida,
	as custas de mais perdas no cache.

Nesse exemplo, o  ``timeout`` está configurado para ``60``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=60"

Nesse exemplo, o ``timeout`` é ``30`` e ``max_entries`` é ``400``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=30&max_entries=400"

Argumentos inválidos são silenciosamente ignorados, assim como valores inválidos para
argumentos conhecidos.

O cache por site
================

.. versionchanged:: 1.0
    (versões anteriores do Django forneciam apenas um único ``CacheMiddleware`` no lugar
    das duas partes descritas abaixo).

Uma vez que o cache esteja configurado, a forma mais siples de usá-lo é fazer
o cache do seu site inteiro. Você precisa adicionar
``'django.middleware.cache.UpdateCacheMiddleware'`` e
``'django.middleware.cache.FetchFromCacheMiddleware'`` as suas configurações de
``MIDDLEWARE_CLASSES``, como nesse exemplo::

    MIDDLEWARE_CLASSES = (
        'django.middleware.cache.UpdateCacheMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',
    )

.. note::

    No, isso não é um erro de digitação: o middleware "update" deve aparecer primeiro na list,
    e o middleware "fetch" por último. Os detalhes são um pouco obscuros, mas
    veja `Ordem das MIDDLEWARE_CLASSES`_ abaixo se você quiser entender os detalhes.

Então, adicione as configurações necessárias ao seu arquivo de configurações do Django:

* ``CACHE_MIDDLEWARE_SECONDS`` -- O número de segundos em que cada página deve permancecer
  em cache.
* ``CACHE_MIDDLEWARE_KEY_PREFIX`` -- Se o cache é compartilhado entre diversos
  sites usando a mesma instalação do Django, configure isso para o nome do site,
  ou alguma outra string única que identifique esse instância do Django, para previnir
  colisões de cache. Use uma string vazia se você não se importa.

O middleware de cache faz o cache de cada página que não tenha parâmetros de GET ou
POST. Opcionalmente, se a configuração ``CACHE_MIDDLEWARE_ANONYMOUS_ONLY`` for
``True``, somente requisições anônimas (i.e., aquelas feitas por usuários não autenticados)
serão cacheadas. Esse é um modo simples e eficiente para desabilita o cache para quaisquer
páginas específicas de usuários (incluindo a interface de administração do Django). Note que se você
usou o ``CACHE_MIDDLEWARE_ANONYMOUS_ONLY``, você deve certificar-se de ter ativado o
``AuthenticationMiddleware``.

Adicionalmente, o middleware de cache adiciona alguma cabeçalhos em cada
``HttpResponse``:

* Configura o cabeçalho ``Last-Modified`` para a data/hora atuais quando uma nova
  versão da página (não cacheada) é resiquitada.
* Configura o cabeçalho ``Expires`` para a hora atual mais o valor definido em
  ``CACHE_MIDDLEWARE_SECONDS``.
* Configura o cabeçalho ``Cache-Control`` para dar um max age para a página -- novamente,
  da configuração ``CACHE_MIDDLEWARE_SECONDS``.

Veja :ref:`topics-http-middleware` para mais sobre middlewares.

.. versionadded:: 1.0

Se uma visão configura o seu próprio tempo de expiração de cache (i.e. tem uma seção ``max-age``
no seu cabeçalho ``Cache-Control``) então a página será mantida em cache até o tempo de
edxpiração, ao invés de ``CACHE_MIDDLEWARE_SECONDS``. Usando os decoradores em
``django.views.decorators.cache`` você pode facilmente configurar o tempo de expiração de
uma visão(usando o decorador ``cache_control``) ou desabilitar o cache para uma visão (usando
o decorador ``never_cache``). Veja a seção `usando outros cabeçalhos`__ para mais
informações sobre esses decoradores.

__ `Controlando o cache: Usando outros cabeçalhos`_

O cache por visão
=================

A more granular way to use the caching framework is by caching the output of
individual views. ``django.views.decorators.cache`` defines a ``cache_page``
decorator that will automatically cache the view's response for you. It's easy
to use::

    from django.views.decorators.cache import cache_page

    def slashdot_this(request):
        ...

    slashdot_this = cache_page(slashdot_this, 60 * 15)

Or, using Python 2.4's decorator syntax::

    @cache_page(60 * 15)
    def slashdot_this(request):
        ...

``cache_page`` takes a single argument: the cache timeout, in seconds. In the
above example, the result of the ``slashdot_this()`` view will be cached for 15
minutes.

Cache de fragmento de template
==============================

.. versionadded:: 1.0

If you're after even more control, you can also cache template fragments using
the ``cache`` template tag. To give your template access to this tag, put
``{% load cache %}`` near the top of your template.

The ``{% cache %}`` template tag caches the contents of the block for a given
amount of time. It takes at least two arguments: the cache timeout, in seconds,
and the name to give the cache fragment. For example::

    {% load cache %}
    {% cache 500 sidebar %}
        .. sidebar ..
    {% endcache %}

Sometimes you might want to cache multiple copies of a fragment depending on
some dynamic data that appears inside the fragment. For example, you might want a
separate cached copy of the sidebar used in the previous example for every user
of your site. Do this by passing additional arguments to the ``{% cache %}``
template tag to uniquely identify the cache fragment::

    {% load cache %}
    {% cache 500 sidebar request.user.username %}
        .. sidebar for logged in user ..
    {% endcache %}

It's perfectly fine to specify more than one argument to identify the fragment.
Simply pass as many arguments to ``{% cache %}`` as you need.

The cache timeout can be a template variable, as long as the template variable
resolves to an integer value. For example, if the template variable
``my_timeout`` is set to the value ``600``, then the following two examples are
equivalent::

    {% cache 600 sidebar %} ... {% endcache %}
    {% cache my_timeout sidebar %} ... {% endcache %}

This feature is useful in avoiding repetition in templates. You can set the
timeout in a variable, in one place, and just reuse that value.

A API de baixo nível do cache
=============================

Algumas vezes, o cache de uma página completa renderizada não é de grande valor.
Por exemplo, você pode descobrir que basta fazer o cache do resultado de uma consulta
intensiva ao banco de dados. Em casos assim, você pode usar a API de baixo nível
de cache para guardar os objetos em qualquer nível de granularidade que você quiser.

A API de cache é simples. O módulo de cache, ``django.core.cache``, exporta um
objeto ``cache`` que é criado automaticamente a partir da configuração
``CACHE_BACKEND``::

    >>> from django.core.cache import cache

A interface básica é ``set(key, value, timeout_seconds)`` e ``get(key)``::

    >>> cache.set('my_key', 'hello, world!', 30)
    >>> cache.get('my_key')
    'hello, world!'

O argumento ``timeout_seconds`` é opcional e o seu padrão é o mesmo do argumento ``timeout``
na configuração ``CACHE_BACKEND`` (explicada acima).

Se o objeto não existe no cache, ``cache.get()`` retorna ``None``::

    >>> cache.get('some_other_key')
    None

    # Espere 30 segundos para 'my_key' expirar...

    >>> cache.get('my_key')
    None

get() pode ter um argumento ``padrão``::

    >>> cache.get('my_key', 'has expired')
    'has expired'

.. versionadded:: 1.0

Para adicionar uma cache somente se ela ainda não existir, use o método ``add()``.
Ele recebe os mesmos parâmetros que ``set()``, mas não irá tentar atualizar o cache se a
chave especificada já estiver presente::

    >>> cache.set('add_key', 'Initial value')
    >>> cache.add('add_key', 'New value')
    >>> cache.get('add_key')
    'Initial value'

Se você precisa saber se ``add()`` salvou um valor no cache, você pode
verificar o valor retornado. O retorno será ``True`` se o valor foi gravado,
e ``False`` se nada for gravado.

Existe também uma interface chamada ``get_many()`` que acessa o cache apenas uma vez.
``get_many()`` retorna um dicionário com todas as chaves que você pediu
que estavam no cache e não estavem expiradas)::

    >>> cache.set('a', 1)
    >>> cache.set('b', 2)
    >>> cache.set('c', 3)
    >>> cache.get_many(['a', 'b', 'c'])
    {'a': 1, 'b': 2, 'c': 3}

Finalmente, você pode remover chaves diferentes com  ``delete()``. Essa é uma forma
fácil de limpar o cache para um objeto em particular::

    >>> cache.delete('a')

É isso. O cache tem muitas poucas restrições: você pode colocar em cache quaisquer
objetos que possam ser 'pickled' seguramente, mas as chaves devem ser strings.

Caches Upstream
===============

Até agora, esse documento concentrou-se no cache de seus *próprios* dados. Mas outro tipo de
cache é relevante para o desenvolvimento Web: o cache executado por cache
"upstream". Esses são sistemas que fazem o cache de páginas para usuários antes mesmo da
requisição chegar ao seu Web site.

Aqui estão algumns exemplos de cache upstream:

    * Seu ISP pode fazer o cache de certas páginas, então se você requisitou uma página de
      somedomain.com, seu ISP poderia entiar a página sem ter de acessar o
      somedomain.com diretamente.

    * Seu Web site Django pode ficar atrás de um proxy Squid
      (http://www.squid-cache.org/) que faz cache de páginas para performance. Nesse
      caso, cada requisição seria tratada primeiramente pelo Squid, e somente seria passada para
      a sua aplicação se necessário.

    * Seu navegador web também faz cache. Se uma página envia os cabeçalhos
      corretos, seu navegador irá usar a cópia local (em cache) para requisições
      subsequentes para essa página.

Caches upstream são um potencializador de eficiência interessante, mas há um perigo nisso:
muitos conteúdos de páginas web diferem baseados na autenticação e em diversas outras
variáveis, e sistemas de cache que servem páginas baseadas em URL cegamente
poderiam expor dados incorretos ou sensíveis para visitantes subsequentes a
essas páginas.

Por exemplo, digamos que você opere um serviço de webmail, e o conteúdo da página
"inbox" obviamente depende do usuário que está logado. Se um ISP cegamente
cacheia seu site, então o primeiro usuário que logou através desse ISP poderia ter
seu conteúdo da caixa de entrada exposto aos próximos visitantes do site. Isso
não é legal.

Felizmente, o HTTP fornece uma solução para esse problema: um conjunto de cabeçalhos HTTP
existem para instruir os diferentes mecanismos de cache de diferir seus conteúdos de cache
de acordo com certas variáveis, e como dizer aos mecanismos de cache como 
não cachear certas páginas em particular.

Usando cabeçalhos Vary
======================

Um desses cabeçalhos é o ``Vary``. Ele define quais cabeçalhos da requisição
um mecanismo de cache deve levar em conta ao construir sua chave de cache. 
Por exemplo, se o conteúdo do site de uma págfina web depende da preferência de
idioma do usuário, dizemos que a página "varia no idioma."

Por padrão, o sistema de cache do DJango cria suas chaves de acesso usando o caminho 
da requisição -- e.g., ``"/stories/2005/jun/23/bank_robbed/"``. Isso significa que cada
requisição a essa URL irá usar a mesma versão do cache, não importando as diferentes
de agente de usuário, como cookies ou preferência de idioma.

É onde entra o ``Vary``.

Se o seu site baseado em Django exibe diferentes conteúdos baseados em alguma diferença
dos cabeçalhos de requisição -- como o cookie, idioma, ou agente de usuário -- você irá
precisar usar o cabeçalho ``Vary`` para dizer aos mecanismos de cache que a saída da página
depende dessas coisas.

Para fazer isso no Django, use o decorador de visão de conveniência ``vary_on_headers``,
assim::

    from django.views.decorators.vary import vary_on_headers

    # Python 2.3 syntax.
    def my_view(request):
        ...
    my_view = vary_on_headers(my_view, 'User-Agent')

    # Python 2.4 decorator syntax.
    @vary_on_headers('User-Agent')
    def my_view(request):
        ...

Nesse caso, um mecanismo de cache (como o próprio middleware de cache do Django) irá
cachear uma versão diferente da página para cada agente de usuário único.

A vantage de usar o decorador ``vary_on_headers``  ao invés de configurar o cabeçalho
``Vary`` manualmente (usando algo como
``response['Vary'] = 'user-agent'``) é que o decorador adiciona algo ao cabeçalho ``Vary``
(que pode já existir) ao invés de sobrescrevê-lo.

Você pode passar diversos cabeçalhos para ``vary_on_headers()``::

    @vary_on_headers('User-Agent', 'Cookie')
    def my_view(request):
        ...

Como a variação baseada em cookie é um caso comum, existe um decorador ``vary_on_cookie``.
Essas duas views são equivalentes::

    @vary_on_cookie
    def my_view(request):
        ...

    @vary_on_headers('Cookie')
    def my_view(request):
        ...

Note também que os abeçalhos que você passa para ``vary_on_headers`` não são
sensíveis a caso. ``"User-Agent"`` é a mesma coisa que ``"user-agent"``.

Você pode também usar uma função auxiliar, ``django.utils.cache.patch_vary_headers``,
diretamente::

    from django.utils.cache import patch_vary_headers
    def my_view(request):
        ...
        response = render_to_response('template_name', context)
        patch_vary_headers(response, ['Cookie'])
        return response

``patch_vary_headers`` recebe uma instância de ``HttpResponse`` como seu primeiro argumento
e uma lista/tupla de nomes de cabeçalho como seu segundo argumento.

Para mais sobre os cabeçalhos Vary, veja a `especificação oficial do Vary`_.

.. _`especificação oficial do Vary`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44

Controlando o cache: Usando outros cabeçalhos
=============================================

Outro problema com o cache é a privacidade de dados e a questão de onde 
os dados devem ser armazenados em uma cascada de caches.

Um usuário normalmente encontra dois tipos de cache: o do seu próprio navegador (um cache
privado) e o do seu provedor (um cache público). Um cache público é usado por
muitos usuários e controlado por mais alguém. Isso coloca problemas com
dados sensíveis: você não quer, por exemplo, que o número da sua conta bancária seja gravada em um
cache público. Assim, aplicações web precisam de uma forma de dizer aos caches quais dados são
privados e quais dados são públicos.

A solução é indicar que o cache de página seja "particular". Para fazer isso no
Django, use o decorador de visão ``cache_control``. Exemplo::

    from django.views.decorators.cache import cache_control
    @cache_control(private=True)
    def my_view(request):
        ...

Esse decorador cuida de enviar o cabeçalho HTTP apropriado nos bastidores.

Existem algumas outras formas de controlar os parâmetros de cache. Por exemplo, o HTTP
permite que aplicações façam o seguinte:

    * Defina o tempo máximo que uma página deva permanecer em cache.
    * Especifica se um cache deve sempre verificar por novas versões da página, 
      exibindo o conteúdo em cache apenas quando não houve mudanças. (Alguns caches
      podem entregar conteúdo em cache mesmo se a página no servidor mudou -- simplesmente
      porque a cópia do cache ainda não expirou.)

No Django, use o decorador de visão ``cache_control`` para especificar esses parâmetros
de cache. Nesse exemplo, ``cache_control`` diz ao cache para revalidar o
cache em cada acesso e para guardar versões em cache em no máximo por 3600 segundos::

    from django.views.decorators.cache import cache_control
    @cache_control(must_revalidate=True, max_age=3600)
    def my_view(request):
        ...

Qualquer diretiva HTTP ``Cache-Control`` é válida em ``cache_control()``.
Aqui está uma lista completa:

    * ``public=True``
    * ``private=True``
    * ``no_cache=True``
    * ``no_transform=True``
    * ``must_revalidate=True``
    * ``proxy_revalidate=True``
    * ``max_age=num_seconds``
    * ``s_maxage=num_seconds``

Para explicação das diretivas HTTP de Cache-Control, veja a `Especificação de Cache-Control`_.

(Note que o middleware  de cache já configura o tempo máximo (max-age) do cache com
o valor da configuração ``CACHE_MIDDLEWARE_SETTINGS``. Se você usa um ``max_age``
personalizado no decorador ``cache_control``, o decorador terá precedência sobre a configuração,
e os valores do cabeçalho serão mesclados corretamente.)

Se você quer usar cabeçalhos para desabilitar todo o cache,
``django.views.decorators.cache.never_cache`` é um decorador de visão que adiciona
cabeçalhos que garantem que a resposta não será posta em cache por navegadores ou outros caches. Exemplo::

    from django.views.decorators.cache import never_cache
    @never_cache
    def myview(request):
        ...

.. _`Especificação de Cache-Control`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9

Outras otimizações
==================

O Django vem com alguns outros middlewares que podem ajudar a otimizar a performance
do seu aplicativo:

    * ``django.middleware.http.ConditionalGetMiddleware`` adiciona suporte para
      GET condicional. Isso faz uso dos cabeçalhos ``ETag`` e ``Last-Modified``.

    * ``django.middleware.gzip.GZipMiddleware`` comprime conteúdo para navegadores que
      entendem a compressão gzip (todos os navegadores modernos).

Ordem das MIDDLEWARE_CLASSES
============================

Se você está usando o middleware de cache, é importador colocar cada parte dentro do lugar correto nas
configurações de ``MIDDLEWARE_CLASSES``. Isso porque o cabeçalho de cache
precisa saber por quais cabeçalhos ele irá variar o armazenamento de cache.
Middleware sempre adiciona algo ao cabeçalho ``Vary`` quando ele pode.

``UpdateCacheMiddleware`` executa durante a fase de resposta, onde os middlewares são
executados em ordem reversa, então um item no topo da lista sempre executa *por último* durante
a fase de resposta. Assim, você precisa garantir que ``UpdateCacheMiddleware``
apareça *antes* de quaisquer outros middlewares que possam adicionar algo ao cabeçalho ``Vary``.
Os seguintes módulos de middleware fazem isso so:

    * ``SessionMiddleware`` adiciona ``Cookie``
    * ``GZipMiddleware`` adiciona ``Accept-Encoding``
    * ``LocaleMiddleware`` adiciona ``Accept-Language``

``FetchFromCacheMiddleware``, por outro lado, executa durante a fase de requisição,
onde os middlewares são aplicados do primeiro ao último, então um item no topo da lista
execute *primeiro* durante a fase de requisição. O ``FetchFromCacheMiddleware`` também
precisa edxecutar depois de alguns outros middlewares atualizarem o cabeçalho ``Vary``, assim
``FetchFromCacheMiddleware`` deve ser configurado *após* qualquer item que faça isso.
