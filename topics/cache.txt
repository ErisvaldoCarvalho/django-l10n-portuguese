..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9441 $
..   $TranslationAuthors: None $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..

.. _topics-cache:

==============================
O framework de cache do Django
==============================

Uma dilema essencial dos sites dinâmicos vem a ser o próprio fato de serem dinâmicos. 
Cada vez que um usuário requisita uma página, o servidor web faz todo o tipo de 
cálculos -- consultas a bancos de dados, renderização de templates e lógica de negócio -- 
para criar a página que o seu visitante vê. Isso tem um custo de processamento
muito maior que apenas a leitura de arquivos estáticos no disco.

Para a maior parte dos aplicativos Web, esse overhead não é um problema. A maior
parte das aplicações Web não são o washingtonpost.com oouslashdot.org; são simplesmente sites
pequenos a médio com tráfico equivalente. Mas para aplicações de porte mério para grante,
é essencial eliminar toda a sobrecarga possível.

É onde entra o cache.

Fazer o cache de algo é gravar o resultado de um cálculo custoso para que
você não tenha de executar o cálculo da próxima vez. Aqui está um pseudocódigo
explicando como isso funcionaria para uma página Web gerada dinamicamente::

    tente encontrar uma página no cache para tal URL
    se a página estiver no cache:
        retorne a página do cache
    se não:
        gere a página
        guarde a página gerada no cache (para a próxima vez)
        retorne a página gerada

O Django vem com um sistema de cache robusto que permite que você guarde as páginas dinâmicas para que
elas não tenham de ser calculadas a cada requisição. Por conveniência, Django
oferece diferentes níveis de granularidade de cache: Você pode fazer o cache da saída de
views específicas, você pode fazer o cache somente das partes que são difíceis de produzir, ou
pode fazer o cache do site inteiro.

O Django também trabalha com caches do tipo "upstream", como o Squid
(http://www.squid-cache.org/) e cache baseado em navegador. Esses são tipos de cache
que você não controla diretamente mas para os quais fornece dicas (via
cabeçalhos HTTP) sobre quais partes do seu site devem ser mantidas em cache, e como.

Configurando o cache
====================

O sistema de cache requer uma pequena configuração. Você deve informar
ao Django onde os seus dados em cache estarão -- se em um banco de dados, no sistema de
arquivos ou diretamente na memória. Essa é uma decisão importante que afeta a performance
do seu cache; sim, algums tipos de cache são mais rápidos que outros.

Sua preferência de cache vai na configuração ``CACHE_BACKEND`` no seu arquivo de
configurações. Aqui vai uma explicação de todos os valores disponíveis para
CACHE_BACKEND.

Memcached
---------

De longe, o mais rápido e mais eficiente tipo de cache disponível no Django, Memcached
é um framework de cache inteiramente baseado em memória originalmente desenvolvido para
lidar com as altas cargas no LiveJournal.com e subsequentemente tornada open-sourced pela Danga 
Interactive. É usado por sites como o Slashdot ou Wikipedia para reduzir o acesso a banco de dados
e aumentar a performance do site drasticamente.

O Memcached está disponível de graça em http://danga.com/memcached/ . Ele executa como um
daemon, para o qual é alocada uma quantidade específica de RAM. Tudo o que ele faz é fornecer
uma interface -- um interface *super-ultra-rápida* -- para adição, busca e
remoção de dados arbitrários do cache. Todos os dados são gravador diretamente na memória,
então não existe sobrecarga de banco de dados ou uso do filesystem.

Após a instalação do Memcached, você precisa instalar as bibliotecas do Memcached para
Python. Duas versões estão disponíveis. Selecione e instale *um* dos
seguintes módulos:

    * A opção mais rápida é um módulo chamado ``cmemcache``, disponível
      em http://gijsbert.org/cmemcache/ .

    * Se você não pode instalar o ``cmemcache``, você pode instalar o ``python-memcached``,
      disponível em ftp://ftp.tummy.com/pub/python-memcached/ . Se essa URL não
      é mais válida, apenas vá ao site do Memcached
      (http://www.danga.com/memcached/) e obtenha as bibliotecas Python da seção
      "Client APIs".

.. versionadded:: 1.0
    A opção ``cmemcache`` é nova no 1.0. Anteriormente, somente o
    ``python-memcached`` era suportado.

Para usar o Memcached com Django, configure o  ``CACHE_BACKEND`` para
``memcached://ip:port/``, onde ``ip`` é o endereço IP dp daemon do Memcached
e o ``port`` é a porta onde o Memcached está rodando.

Nesse exemplo, o Memcached está rodando em localhost (127.0.0.1) na porta 11211::

    CACHE_BACKEND = 'memcached://127.0.0.1:11211/'

Uma característica excelente do Memcached é sua habilidade de compartilhar o cache
em diversos servidores. Para aproveitar essa funcionalidade, inclua todos os endereços 
de servidores em ``CACHE_BACKEND``, separados por ponto e vírgula. Nesse exemplo, o cache é
compartilhado por instâncias do  Memcached rodando nos endereços IP 172.19.26.240 e
172.19.26.242, ambos na porta 11211::

    CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11211/'

O cache baseado em memória tem uma desvantagem: Como os dados em cache estão na
memória, serão perdidos se o seu servidor travar. Claramente, a memória não
foi feita para armazenamento permanente de dados, então não confie no cache em 
memória como sua única fonte de armazenamento de dados. Na verdade, nenhum dos
backends de cache do Django deve ser usado para armazenamento permanente -- 
devem ser usados como soluções para cache, e não armazenamento -- mas
reafirmamos isso aqui porque o cache em memória é realmente temporário.

Cache em banco de dados
-----------------------

Para usar uma tabela do banco de dados como o seu backend de cache, primeiro 
crie uma tabela de cache em seu banco de dados com o seguinte comando::

    python manage.py createcachetable [cache_table_name]

...onde ``[cache_table_name]`` é o nome da tabela no banco de dados a ser criada.
(Esse nome pode ser qualquer um, desde que seja um nome válido de tabela e esse nome
ainda não esteja sendo usado no seu banco de dados.) Esse comando cria uma única tabela
no seu banco de dados, no formato apropriado que o sistema de cache em banco de dados
do Django espera encontrar.

Uma vez que você tenha configurado a tabela do banco de dados, configure o seu ``CACHE_BACKEND``
para ``"db://tablename"``, onde ``tablename`` é o nome da tabela.
Nesse exemplo, o nome da tabela de cache é ``my_cache_table``::

    CACHE_BACKEND = 'db://my_cache_table'

O cache em banco de dados funciona melhor se você tem um servidor de banco de dados rápido
e bem indexado.

Cache em sistema de arquivos
----------------------------

Para gravar os items em cache no sistema de arquivos, use o tipo de cache ``"file://"``
para ``CACHE_BACKEND``. Por exemplo, para salvar os dados do cache em ``/var/tmp/django_cache``,
use essa configuração::

    CACHE_BACKEND = 'file:///var/tmp/django_cache'

Perceba que existem três barras próximas ao início do exemplo.
As primeiras são para o ``file://``, e a terceira é o primeiro caractere do
caminho do diretório, ``/var/tmp/django_cache``.

O caminho do diretório deve ser absoluto -- isso é, ele deve iniciar na raiz
do seu sistema de arquivos. Não faz diferença se você põe a barra no final
da configuração.

Assegure-se que o diretório apontado por essa configuração exista e tenha permissões
de leitura e escrita pelo usuário do sistema que executa o seu servidor web. 
Continuando o exemplo acima, se o seu servidor web roda como o usuário ``apache``, 
tenha certeza que o diretório ``/var/tmp/django_cache`` exista e tenha permissão de
leitura e escrita pelo usuário ``apache``.

Cache em memória local
----------------------

Se você quer as vantagens de velocidade de executar um cache em memória mas não
pode executar o  Memcached, considere o backend de cache em memória local. Esse
cache é multi-processo e thread-safe. Para usá-lo, configure o ``CACHE_BACKEND`` para
``"locmem:///"``. Por exemplo::

    CACHE_BACKEND = 'locmem:///'
    
Note que cada processo irá ter sua própria instância privada de cache, o que significa
que nenhum cache entre processos é possível. Isso obviamente significa que o cache em
memória local não é muito eficiente em termos de memória, então provavelmente não é
uma boa escolha para um ambiente de produção.

Cache falso (para desenvolvimento)
----------------------------------

Finalmente, o Django vem com um cache "falso" que não faz cache realmente -- ele
apenas implementa a interface de cache sem fazer nada realmente.

Isso é útil se você tem um site em produção que usa cacheamento pesado em
vários lugares, mas em desenvolvimento ou no ambiente de testes você não quer
usar cache. Como resultado, o seu ambiente de desenvolvimento não vai usar cache, 
mas o seu ambiente de produção irá. Para ativar o cache falso, configure o
``CACHE_BACKEND`` assim::

    CACHE_BACKEND = 'dummy:///'

Usando um backend de cache personalizado
----------------------------------------

.. versionadded:: 1.0

Apesar do Django suportar diversos sistemas de cache diferentes,
algumas vezes você pode querer usar algum backend de cache personalizado. Para usar um
backend externo de cache com o  Django, use um caminho de importação de módulos do Python
como a parte do esquema (a parte que vem antes do dois pontos inicial) da URI do
``CACHE_BACKEND``, assim::

    CACHE_BACKEND = 'path.to.backend://'

Se você está construindo o seu próprio backend, você pode usar os backends padrão
de cache como implementações de referência. Você irá encontrar o código no diretório
``django/core/cache/backends/`` dos fontes do Django.

Nota: Você deveria usar os backends de cache incluídos com o Django, anão ser que você
tenha uma razão muito boa, como um host que não os suporta. Eles foram
bem testados e são fáceis de usar.

argumentos do CACHE_BACKEND
---------------------------

Todos os tipos de cache podem receber argumentos. Eles são informados em um estilo  query-string
semelhante a configuração ``CACHE_BACKEND``. Argumentos válidos são:

    timeout
        Timeout padrão, em segundos, a ser usado para o cache. O padrão é 5
        minutos (300 segundos).

    max_entries
        Para o cache simples e em banco de dados, o número máximo de entradas
        permitidas no cache antes dele ser limpo. O padrão é 300.

    cull_percentage
        A porcentagem de entradas que são limpas do cache quando max_entries é atingido.
        A porcentagem real é 1/cull_percentage, então configure o cull_percentage=3 para
        limpar 1/3 das entradas quando o valor de max_entries é atingido.

        Um valor de 0 fpara o cull_percentage significa que o cache todo
        será limpo quando max_entries for atingido. Isso torna a limpeza *muito* mais rápida,
	as custas de mais perdas no cache.

Nesse exemplo, o  ``timeout`` está configurado para ``60``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=60"

Nesse exemplo, o ``timeout`` é ``30`` e ``max_entries`` é ``400``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=30&max_entries=400"

Argumentos inválidos são silenciosamente ignorados, assim como valores inválidos para
argumentos conhecidos.

O cache por site
================

.. versionchanged:: 1.0
    (previous versions of Django only provided a single ``CacheMiddleware`` instead
    of the two pieces described below).

Once the cache is set up, the simplest way to use caching is to cache your
entire site. You'll need to add
``'django.middleware.cache.UpdateCacheMiddleware'`` and
``'django.middleware.cache.FetchFromCacheMiddleware'`` to your
``MIDDLEWARE_CLASSES`` setting, as in this example::

    MIDDLEWARE_CLASSES = (
        'django.middleware.cache.UpdateCacheMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',
    )

.. note::

    No, that's not a typo: the "update" middleware must be first in the list,
    and the "fetch" middleware must be last. The details are a bit obscure, but
    see `Ordem das MIDDLEWARE_CLASSES`_ below if you'd like the full story.

Then, add the following required settings to your Django settings file:

* ``CACHE_MIDDLEWARE_SECONDS`` -- The number of seconds each page should be
  cached.
* ``CACHE_MIDDLEWARE_KEY_PREFIX`` -- If the cache is shared across multiple
  sites using the same Django installation, set this to the name of the site,
  or some other string that is unique to this Django instance, to prevent key
  collisions. Use an empty string if you don't care.

The cache middleware caches every page that doesn't have GET or POST
parameters. Optionally, if the ``CACHE_MIDDLEWARE_ANONYMOUS_ONLY`` setting is
``True``, only anonymous requests (i.e., not those made by a logged-in user)
will be cached. This is a simple and effective way of disabling caching for any
user-specific pages (include Django's admin interface). Note that if you use
``CACHE_MIDDLEWARE_ANONYMOUS_ONLY``, you should make sure you've activated
``AuthenticationMiddleware``.

Additionally, the cache middleware automatically sets a few headers in each
``HttpResponse``:

* Sets the ``Last-Modified`` header to the current date/time when a fresh
  (uncached) version of the page is requested.
* Sets the ``Expires`` header to the current date/time plus the defined
  ``CACHE_MIDDLEWARE_SECONDS``.
* Sets the ``Cache-Control`` header to give a max age for the page -- again,
  from the ``CACHE_MIDDLEWARE_SECONDS`` setting.

See :ref:`topics-http-middleware` for more on middleware.

.. versionadded:: 1.0

If a view sets its own cache expiry time (i.e. it has a ``max-age`` section in
its ``Cache-Control`` header) then the page will be cached until the expiry
time, rather than ``CACHE_MIDDLEWARE_SECONDS``. Using the decorators in
``django.views.decorators.cache`` you can easily set a view's expiry time
(using the ``cache_control`` decorator) or disable caching for a view (using
the ``never_cache`` decorator). See the `using other headers`__ section for
more on these decorators.

__ `Controlando o cache: Usando outros cabeçalhos`_

O cache por visão
=================

A more granular way to use the caching framework is by caching the output of
individual views. ``django.views.decorators.cache`` defines a ``cache_page``
decorator that will automatically cache the view's response for you. It's easy
to use::

    from django.views.decorators.cache import cache_page

    def slashdot_this(request):
        ...

    slashdot_this = cache_page(slashdot_this, 60 * 15)

Or, using Python 2.4's decorator syntax::

    @cache_page(60 * 15)
    def slashdot_this(request):
        ...

``cache_page`` takes a single argument: the cache timeout, in seconds. In the
above example, the result of the ``slashdot_this()`` view will be cached for 15
minutes.

Cache de fragmento de template
==============================

.. versionadded:: 1.0

If you're after even more control, you can also cache template fragments using
the ``cache`` template tag. To give your template access to this tag, put
``{% load cache %}`` near the top of your template.

The ``{% cache %}`` template tag caches the contents of the block for a given
amount of time. It takes at least two arguments: the cache timeout, in seconds,
and the name to give the cache fragment. For example::

    {% load cache %}
    {% cache 500 sidebar %}
        .. sidebar ..
    {% endcache %}

Sometimes you might want to cache multiple copies of a fragment depending on
some dynamic data that appears inside the fragment. For example, you might want a
separate cached copy of the sidebar used in the previous example for every user
of your site. Do this by passing additional arguments to the ``{% cache %}``
template tag to uniquely identify the cache fragment::

    {% load cache %}
    {% cache 500 sidebar request.user.username %}
        .. sidebar for logged in user ..
    {% endcache %}

It's perfectly fine to specify more than one argument to identify the fragment.
Simply pass as many arguments to ``{% cache %}`` as you need.

The cache timeout can be a template variable, as long as the template variable
resolves to an integer value. For example, if the template variable
``my_timeout`` is set to the value ``600``, then the following two examples are
equivalent::

    {% cache 600 sidebar %} ... {% endcache %}
    {% cache my_timeout sidebar %} ... {% endcache %}

This feature is useful in avoiding repetition in templates. You can set the
timeout in a variable, in one place, and just reuse that value.

A API de baixo nível do cache
=============================

Algumas vezes, o cache de uma página completa renderizada não é de grande valor.
Por exemplo, você pode descobrir que basta fazer o cache do resultado de uma consulta
intensiva ao banco de dados. Em casos assim, você pode usar a API de baixo nível
de cache para guardar os objetos em qualquer nível de granularidade que você quiser.

A API de cache é simples. O módulo de cache, ``django.core.cache``, exporta um
objeto ``cache`` que é criado automaticamente a partir da configuração
``CACHE_BACKEND``::

    >>> from django.core.cache import cache

A interface básica é ``set(key, value, timeout_seconds)`` e ``get(key)``::

    >>> cache.set('my_key', 'hello, world!', 30)
    >>> cache.get('my_key')
    'hello, world!'

O argumento ``timeout_seconds`` é opcional e o seu padrão é o mesmo do argumento ``timeout``
na configuração ``CACHE_BACKEND`` (explicada acima).

Se o objeto não existe no cache, ``cache.get()`` retorna ``None``::

    >>> cache.get('some_other_key')
    None

    # Espere 30 segundos para 'my_key' expirar...

    >>> cache.get('my_key')
    None

get() pode ter um argumento ``padrão``::

    >>> cache.get('my_key', 'has expired')
    'has expired'

.. versionadded:: 1.0

Para adicionar uma cache somente se ela ainda não existir, use o método ``add()``.
Ele recebe os mesmos parâmetros que ``set()``, mas não irá tentar atualizar o cache se a
chave especificada já estiver presente::

    >>> cache.set('add_key', 'Initial value')
    >>> cache.add('add_key', 'New value')
    >>> cache.get('add_key')
    'Initial value'

Se você precisa saber se ``add()`` salvou um valor no cache, você pode
verificar o valor retornado. O retorno será ``True`` se o valor foi gravado,
e ``False`` se nada for gravado.

There's also a ``get_many()`` interface that only hits the cache once.
``get_many()`` returns a dictionary with all the keys you asked for that
actually exist in the cache (and haven't expired)::

    >>> cache.set('a', 1)
    >>> cache.set('b', 2)
    >>> cache.set('c', 3)
    >>> cache.get_many(['a', 'b', 'c'])
    {'a': 1, 'b': 2, 'c': 3}

Finalmente, você pode remover chaves diferentes com  ``delete()``. Essa é uma forma
fácil de limpar o cache para um objeto em particular::

    >>> cache.delete('a')

É isso. O cache tem muitas poucas restrições: você pode colocar em cache quaisquer
objetos que possam ser 'pickled' seguramente, mas as chaves devem ser strings.

Caches Upstream
===============

So far, this document has focused on caching your *own* data. But another type
of caching is relevant to Web development, too: caching performed by "upstream"
caches. These are systems that cache pages for users even before the request
reaches your Web site.

Here are a few examples of upstream caches:

    * Your ISP may cache certain pages, so if you requested a page from
      somedomain.com, your ISP would send you the page without having to access
      somedomain.com directly.

    * Your Django Web site may sit behind a Squid Web proxy
      (http://www.squid-cache.org/) that caches pages for performance. In this
      case, each request first would be handled by Squid, and it'd only be
      passed to your application if needed.

    * Your Web browser caches pages, too. If a Web page sends out the right
      headers, your browser will use the local (cached) copy for subsequent
      requests to that page.

Upstream caching is a nice efficiency boost, but there's a danger to it:
Many Web pages' contents differ based on authentication and a host of other
variables, and cache systems that blindly save pages based purely on URLs could
expose incorrect or sensitive data to subsequent visitors to those pages.

For example, say you operate a Web e-mail system, and the contents of the
"inbox" page obviously depend on which user is logged in. If an ISP blindly
cached your site, then the first user who logged in through that ISP would have
his user-specific inbox page cached for subsequent visitors to the site. That's
not cool.

Fortunately, HTTP provides a solution to this problem: A set of HTTP headers
exist to instruct caching mechanisms to differ their cache contents depending
on designated variables, and to tell caching mechanisms not to cache particular
pages.

Usando cabeçalhos Vary
======================

One of these headers is ``Vary``. It defines which request headers a cache
mechanism should take into account when building its cache key. For example, if
the contents of a Web page depend on a user's language preference, the page is
said to "vary on language."

By default, Django's cache system creates its cache keys using the requested
path -- e.g., ``"/stories/2005/jun/23/bank_robbed/"``. This means every request
to that URL will use the same cached version, regardless of user-agent
differences such as cookies or language preferences.

That's where ``Vary`` comes in.

If your Django-powered page outputs different content based on some difference
in request headers -- such as a cookie, or language, or user-agent -- you'll
need to use the ``Vary`` header to tell caching mechanisms that the page output
depends on those things.

To do this in Django, use the convenient ``vary_on_headers`` view decorator,
like so::

    from django.views.decorators.vary import vary_on_headers

    # Python 2.3 syntax.
    def my_view(request):
        ...
    my_view = vary_on_headers(my_view, 'User-Agent')

    # Python 2.4 decorator syntax.
    @vary_on_headers('User-Agent')
    def my_view(request):
        ...

In this case, a caching mechanism (such as Django's own cache middleware) will
cache a separate version of the page for each unique user-agent.

The advantage to using the ``vary_on_headers`` decorator rather than manually
setting the ``Vary`` header (using something like
``response['Vary'] = 'user-agent'``) is that the decorator adds to the ``Vary``
header (which may already exist) rather than setting it from scratch.

You can pass multiple headers to ``vary_on_headers()``::

    @vary_on_headers('User-Agent', 'Cookie')
    def my_view(request):
        ...

Because varying on cookie is such a common case, there's a ``vary_on_cookie``
decorator. These two views are equivalent::

    @vary_on_cookie
    def my_view(request):
        ...

    @vary_on_headers('Cookie')
    def my_view(request):
        ...

Also note that the headers you pass to ``vary_on_headers`` are not case
sensitive. ``"User-Agent"`` is the same thing as ``"user-agent"``.

You can also use a helper function, ``django.utils.cache.patch_vary_headers``,
directly::

    from django.utils.cache import patch_vary_headers
    def my_view(request):
        ...
        response = render_to_response('template_name', context)
        patch_vary_headers(response, ['Cookie'])
        return response

``patch_vary_headers`` takes an ``HttpResponse`` instance as its first argument
and a list/tuple of header names as its second argument.

For more on Vary headers, see the `official Vary spec`_.

.. _`official Vary spec`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44

Controlando o cache: Usando outros cabeçalhos
=============================================

Another problem with caching is the privacy of data and the question of where
data should be stored in a cascade of caches.

A user usually faces two kinds of caches: his own browser cache (a private
cache) and his provider's cache (a public cache). A public cache is used by
multiple users and controlled by someone else. This poses problems with
sensitive data: You don't want, say, your banking-account number stored in a
public cache. So Web applications need a way to tell caches which data is
private and which is public.

The solution is to indicate a page's cache should be "private." To do this in
Django, use the ``cache_control`` view decorator. Example::

    from django.views.decorators.cache import cache_control
    @cache_control(private=True)
    def my_view(request):
        ...

This decorator takes care of sending out the appropriate HTTP header behind the
scenes.

There are a few other ways to control cache parameters. For example, HTTP
allows applications to do the following:

    * Define the maximum time a page should be cached.
    * Specify whether a cache should always check for newer versions, only
      delivering the cached content when there are no changes. (Some caches
      might deliver cached content even if the server page changed -- simply
      because the cache copy isn't yet expired.)

In Django, use the ``cache_control`` view decorator to specify these cache
parameters. In this example, ``cache_control`` tells caches to revalidate the
cache on every access and to store cached versions for, at most, 3600 seconds::

    from django.views.decorators.cache import cache_control
    @cache_control(must_revalidate=True, max_age=3600)
    def my_view(request):
        ...

Any valid ``Cache-Control`` HTTP directive is valid in ``cache_control()``.
Here's a full list:

    * ``public=True``
    * ``private=True``
    * ``no_cache=True``
    * ``no_transform=True``
    * ``must_revalidate=True``
    * ``proxy_revalidate=True``
    * ``max_age=num_seconds``
    * ``s_maxage=num_seconds``

For explanation of Cache-Control HTTP directives, see the `Cache-Control spec`_.

(Note that the caching middleware already sets the cache header's max-age with
the value of the ``CACHE_MIDDLEWARE_SETTINGS`` setting. If you use a custom
``max_age`` in a ``cache_control`` decorator, the decorator will take
precedence, and the header values will be merged correctly.)

If you want to use headers to disable caching altogether,
``django.views.decorators.cache.never_cache`` is a view decorator that adds
headers to ensure the response won't be cached by browsers or other caches. Example::

    from django.views.decorators.cache import never_cache
    @never_cache
    def myview(request):
        ...

.. _`Cache-Control spec`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9

Outras otimizações
==================

O Django vem com alguns outros middlewares que podem ajudar a otimizar a performance
do seu aplicativo:

    * ``django.middleware.http.ConditionalGetMiddleware`` adiciona suporte para
      GET condicional. Isso faz uso dos cabeçalhos ``ETag`` e ``Last-Modified``.

    * ``django.middleware.gzip.GZipMiddleware`` comprime conteúdo para navegadores que
      entendem a compressão gzip (todos os navegadores modernos).

Ordem das MIDDLEWARE_CLASSES
============================

If you use caching middleware, it's important to put each half in the right
place within the ``MIDDLEWARE_CLASSES`` setting. That's because the cache
middleware needs to know which headers by which to vary the cache storage.
Middleware always adds something to the ``Vary`` response header when it can.

``UpdateCacheMiddleware`` runs during the response phase, where middleware is
run in reverse order, so an item at the top of the list runs *last* during the
response phase. Thus, you need to make sure that ``UpdateCacheMiddleware``
appears *before* any other middleware that might add something to the ``Vary``
header. The following middleware modules do so:

    * ``SessionMiddleware`` adds ``Cookie``
    * ``GZipMiddleware`` adds ``Accept-Encoding``
    * ``LocaleMiddleware`` adds ``Accept-Language``

``FetchFromCacheMiddleware``, on the other hand, runs during the request phase,
where middleware is applied first-to-last, so an item at the top of the list
runs *first* during the request phase. The ``FetchFromCacheMiddleware`` also
needs to run after other middleware updates the ``Vary`` header, so
``FetchFromCacheMiddleware`` must be *after* any item that does so.
