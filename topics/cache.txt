..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9441 $
..   $TranslationAuthors: Walter Cruz $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..

.. _topics-cache:

==============================
O framework de cache do Django
==============================

Uma dilema essencial dos sites dinâmicos vem a ser o próprio fato de serem dinâmicos. 
Cada vez que um usuário requisita uma página, o servidor web faz todo o tipo de 
cálculos -- consultas a bancos de dados, renderização de templates e lógica de negócio -- 
para criar a página que o seu visitante vê. Isso tem um custo de processamento
muito maior que apenas a leitura de arquivos estáticos no disco.

Para a maior parte dos aplicativos Web, esse overhead não é um problema. A maior
parte das aplicações Web não são o washingtonpost.com oouslashdot.org; são simplesmente sites
pequenos a médio com tráfico equivalente. Mas para aplicações de porte mério para grante,
é essencial eliminar toda a sobrecarga possível.

É onde entra o cache.

Fazer o cache de algo é gravar o resultado de um cálculo custoso para que
você não tenha de executar o cálculo da próxima vez. Aqui está um pseudocódigo
explicando como isso funcionaria para uma página Web gerada dinamicamente::

    tente encontrar uma página no cache para tal URL
    se a página estiver no cache:
        retorne a página do cache
    se não:
        gere a página
        guarde a página gerada no cache (para a próxima vez)
        retorne a página gerada

O Django vem com um sistema de cache robusto que permite que você guarde as páginas dinâmicas para que
elas não tenham de ser calculadas a cada requisição. Por conveniência, Django
oferece diferentes níveis de granularidade de cache: Você pode fazer o cache da saída de
views específicas, você pode fazer o cache somente das partes que são difíceis de produzir, ou
pode fazer o cache do site inteiro.

O Django também trabalha com caches do tipo "upstream", como o Squid
(http://www.squid-cache.org/) e cache baseado em navegador. Esses são tipos de cache
que você não controla diretamente mas para os quais fornece dicas (via
cabeçalhos HTTP) sobre quais partes do seu site devem ser mantidas em cache, e como.

Configurando o cache
====================

O sistema de cache requer uma pequena configuração. Você deve informar
ao Django onde os seus dados em cache estarão -- se em um banco de dados, no sistema de
arquivos ou diretamente na memória. Essa é uma decisão importante que afeta a performance
do seu cache; sim, algums tipos de cache são mais rápidos que outros.

Sua preferência de cache vai na configuração ``CACHE_BACKEND`` no seu arquivo de
configurações. Aqui vai uma explicação de todos os valores disponíveis para
CACHE_BACKEND.

Memcached
---------

De longe, o mais rápido e mais eficiente tipo de cache disponível no Django, Memcached
é um framework de cache inteiramente baseado em memória originalmente desenvolvido para
lidar com as altas cargas no LiveJournal.com e subsequentemente tornada open-sourced pela Danga 
Interactive. É usado por sites como o Slashdot ou Wikipedia para reduzir o acesso a banco de dados
e aumentar a performance do site drasticamente.

O Memcached está disponível de graça em http://danga.com/memcached/ . Ele executa como um
daemon, para o qual é alocada uma quantidade específica de RAM. Tudo o que ele faz é fornecer
uma interface -- um interface *super-ultra-rápida* -- para adição, busca e
remoção de dados arbitrários do cache. Todos os dados são gravador diretamente na memória,
então não existe sobrecarga de banco de dados ou uso do filesystem.

Após a instalação do Memcached, você precisa instalar as bibliotecas do Memcached para
Python. Duas versões estão disponíveis. Selecione e instale *um* dos
seguintes módulos:

    * A opção mais rápida é um módulo chamado ``cmemcache``, disponível
      em http://gijsbert.org/cmemcache/ .

    * Se você não pode instalar o ``cmemcache``, você pode instalar o ``python-memcached``,
      disponível em ftp://ftp.tummy.com/pub/python-memcached/ . Se essa URL não
      é mais válida, apenas vá ao site do Memcached
      (http://www.danga.com/memcached/) e obtenha as bibliotecas Python da seção
      "Client APIs".

.. versionadded:: 1.0
    A opção ``cmemcache`` é nova no 1.0. Anteriormente, somente o
    ``python-memcached`` era suportado.

Para usar o Memcached com Django, configure o  ``CACHE_BACKEND`` para
``memcached://ip:port/``, onde ``ip`` é o endereço IP dp daemon do Memcached
e o ``port`` é a porta onde o Memcached está rodando.

Nesse exemplo, o Memcached está rodando em localhost (127.0.0.1) na porta 11211::

    CACHE_BACKEND = 'memcached://127.0.0.1:11211/'

Uma característica excelente do Memcached é sua habilidade de compartilhar o cache
em diversos servidores. Para aproveitar essa funcionalidade, inclua todos os endereços 
de servidores em ``CACHE_BACKEND``, separados por ponto e vírgula. Nesse exemplo, o cache é
compartilhado por instâncias do  Memcached rodando nos endereços IP 172.19.26.240 e
172.19.26.242, ambos na porta 11211::

    CACHE_BACKEND = 'memcached://172.19.26.240:11211;172.19.26.242:11211/'

O cache baseado em memória tem uma desvantagem: Como os dados em cache estão na
memória, serão perdidos se o seu servidor travar. Claramente, a memória não
foi feita para armazenamento permanente de dados, então não confie no cache em 
memória como sua única fonte de armazenamento de dados. Na verdade, nenhum dos
backends de cache do Django deve ser usado para armazenamento permanente -- 
devem ser usados como soluções para cache, e não armazenamento -- mas
reafirmamos isso aqui porque o cache em memória é realmente temporário.

Cache em banco de dados
-----------------------

Para usar uma tabela do banco de dados como o seu backend de cache, primeiro 
crie uma tabela de cache em seu banco de dados com o seguinte comando::

    python manage.py createcachetable [cache_table_name]

...onde ``[cache_table_name]`` é o nome da tabela no banco de dados a ser criada.
(Esse nome pode ser qualquer um, desde que seja um nome válido de tabela e esse nome
ainda não esteja sendo usado no seu banco de dados.) Esse comando cria uma única tabela
no seu banco de dados, no formato apropriado que o sistema de cache em banco de dados
do Django espera encontrar.

Uma vez que você tenha configurado a tabela do banco de dados, configure o seu ``CACHE_BACKEND``
para ``"db://tablename"``, onde ``tablename`` é o nome da tabela.
Nesse exemplo, o nome da tabela de cache é ``my_cache_table``::

    CACHE_BACKEND = 'db://my_cache_table'

O cache em banco de dados funciona melhor se você tem um servidor de banco de dados rápido
e bem indexado.

Cache em sistema de arquivos
----------------------------

Para gravar os items em cache no sistema de arquivos, use o tipo de cache ``"file://"``
para ``CACHE_BACKEND``. Por exemplo, para salvar os dados do cache em ``/var/tmp/django_cache``,
use essa configuração::

    CACHE_BACKEND = 'file:///var/tmp/django_cache'

Perceba que existem três barras próximas ao início do exemplo.
As primeiras são para o ``file://``, e a terceira é o primeiro caractere do
caminho do diretório, ``/var/tmp/django_cache``.

O caminho do diretório deve ser absoluto -- isso é, ele deve iniciar na raiz
do seu sistema de arquivos. Não faz diferença se você põe a barra no final
da configuração.

Assegure-se que o diretório apontado por essa configuração exista e tenha permissões
de leitura e escrita pelo usuário do sistema que executa o seu servidor web. 
Continuando o exemplo acima, se o seu servidor web roda como o usuário ``apache``, 
tenha certeza que o diretório ``/var/tmp/django_cache`` exista e tenha permissão de
leitura e escrita pelo usuário ``apache``.

Cache em memória local
----------------------

Se você quer as vantagens de velocidade de executar um cache em memória mas não
pode executar o  Memcached, considere o backend de cache em memória local. Esse
cache é multi-processo e thread-safe. Para usá-lo, configure o ``CACHE_BACKEND`` para
``"locmem:///"``. Por exemplo::

    CACHE_BACKEND = 'locmem:///'
    
Note que cada processo irá ter sua própria instância privada de cache, o que significa
que nenhum cache entre processos é possível. Isso obviamente significa que o cache em
memória local não é muito eficiente em termos de memória, então provavelmente não é
uma boa escolha para um ambiente de produção.

Cache falso (para desenvolvimento)
----------------------------------

Finalmente, o Django vem com um cache "falso" que não faz cache realmente -- ele
apenas implementa a interface de cache sem fazer nada realmente.

Isso é útil se você tem um site em produção que usa cacheamento pesado em
vários lugares, mas em desenvolvimento ou no ambiente de testes você não quer
usar cache. Como resultado, o seu ambiente de desenvolvimento não vai usar cache, 
mas o seu ambiente de produção irá. Para ativar o cache falso, configure o
``CACHE_BACKEND`` assim::

    CACHE_BACKEND = 'dummy:///'

Usando um backend de cache personalizado
----------------------------------------

.. versionadded:: 1.0

Apesar do Django suportar diversos sistemas de cache diferentes,
algumas vezes você pode querer usar algum backend de cache personalizado. Para usar um
backend externo de cache com o  Django, use um caminho de importação de módulos do Python
como a parte do esquema (a parte que vem antes do dois pontos inicial) da URI do
``CACHE_BACKEND``, assim::

    CACHE_BACKEND = 'path.to.backend://'

Se você está construindo o seu próprio backend, você pode usar os backends padrão
de cache como implementações de referência. Você irá encontrar o código no diretório
``django/core/cache/backends/`` dos fontes do Django.

Nota: Você deveria usar os backends de cache incluídos com o Django, anão ser que você
tenha uma razão muito boa, como um host que não os suporta. Eles foram
bem testados e são fáceis de usar.

argumentos do CACHE_BACKEND
---------------------------

Todos os tipos de cache podem receber argumentos. Eles são informados em um estilo  query-string
semelhante a configuração ``CACHE_BACKEND``. Argumentos válidos são:

    timeout
        Timeout padrão, em segundos, a ser usado para o cache. O padrão é 5
        minutos (300 segundos).

    max_entries
        Para o cache simples e em banco de dados, o número máximo de entradas
        permitidas no cache antes dele ser limpo. O padrão é 300.

    cull_percentage
        A porcentagem de entradas que são limpas do cache quando max_entries é atingido.
        A porcentagem real é 1/cull_percentage, então configure o cull_percentage=3 para
        limpar 1/3 das entradas quando o valor de max_entries é atingido.

        Um valor de 0 fpara o cull_percentage significa que o cache todo
        será limpo quando max_entries for atingido. Isso torna a limpeza *muito* mais rápida,
	as custas de mais perdas no cache.

Nesse exemplo, o  ``timeout`` está configurado para ``60``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=60"

Nesse exemplo, o ``timeout`` é ``30`` e ``max_entries`` é ``400``::

    CACHE_BACKEND = "memcached://127.0.0.1:11211/?timeout=30&max_entries=400"

Argumentos inválidos são silenciosamente ignorados, assim como valores inválidos para
argumentos conhecidos.

O cache por site
================

.. versionchanged:: 1.0
    (versões anteriores do Django forneciam apenas um único ``CacheMiddleware`` no lugar
    das duas partes descritas abaixo).

Uma vez que o cache esteja configurado, a forma mais siples de usá-lo é fazer
o cache do seu site inteiro. Você precisa adicionar
``'django.middleware.cache.UpdateCacheMiddleware'`` e
``'django.middleware.cache.FetchFromCacheMiddleware'`` as suas configurações de
``MIDDLEWARE_CLASSES``, como nesse exemplo::

    MIDDLEWARE_CLASSES = (
        'django.middleware.cache.UpdateCacheMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.cache.FetchFromCacheMiddleware',
    )

.. note::

    No, isso não é um erro de digitação: o middleware "update" deve aparecer primeiro na list,
    e o middleware "fetch" por último. Os detalhes são um pouco obscuros, mas
    veja `Ordem das MIDDLEWARE_CLASSES`_ abaixo se você quiser entender os detalhes.

Então, adicione as configurações necessárias ao seu arquivo de configurações do Django:

* ``CACHE_MIDDLEWARE_SECONDS`` -- O número de segundos em que cada página deve permancecer
  em cache.
* ``CACHE_MIDDLEWARE_KEY_PREFIX`` -- Se o cache é compartilhado entre diversos
  sites usando a mesma instalação do Django, configure isso para o nome do site,
  ou alguma outra string única que identifique esse instância do Django, para previnir
  colisões de cache. Use uma string vazia se você não se importa.

O middleware de cache faz o cache de cada página que não tenha parâmetros de GET ou
POST. Opcionalmente, se a configuração ``CACHE_MIDDLEWARE_ANONYMOUS_ONLY`` for
``True``, somente requisições anônimas (i.e., aquelas feitas por usuários não autenticados)
serão cacheadas. Esse é um modo simples e eficiente para desabilita o cache para quaisquer
páginas específicas de usuários (incluindo a interface de administração do Django). Note que se você
usou o ``CACHE_MIDDLEWARE_ANONYMOUS_ONLY``, você deve certificar-se de ter ativado o
``AuthenticationMiddleware``.

Adicionalmente, o middleware de cache adiciona alguma cabeçalhos em cada
``HttpResponse``:

* Configura o cabeçalho ``Last-Modified`` para a data/hora atuais quando uma nova
  versão da página (não cacheada) é resiquitada.
* Configura o cabeçalho ``Expires`` para a hora atual mais o valor definido em
  ``CACHE_MIDDLEWARE_SECONDS``.
* Configura o cabeçalho ``Cache-Control`` para dar um max age para a página -- novamente,
  da configuração ``CACHE_MIDDLEWARE_SECONDS``.

Veja :ref:`topics-http-middleware` para mais sobre middlewares.

.. versionadded:: 1.0

If a view sets its own cache expiry time (i.e. it has a ``max-age`` section in
its ``Cache-Control`` header) then the page will be cached until the expiry
time, rather than ``CACHE_MIDDLEWARE_SECONDS``. Using the decorators in
``django.views.decorators.cache`` you can easily set a view's expiry time
(using the ``cache_control`` decorator) or disable caching for a view (using
the ``never_cache`` decorator). See the `using other headers`__ section for
more on these decorators.

__ `Controlando o cache: Usando outros cabeçalhos`_

O cache por visão
=================

A more granular way to use the caching framework is by caching the output of
individual views. ``django.views.decorators.cache`` defines a ``cache_page``
decorator that will automatically cache the view's response for you. It's easy
to use::

    from django.views.decorators.cache import cache_page

    def slashdot_this(request):
        ...

    slashdot_this = cache_page(slashdot_this, 60 * 15)

Or, using Python 2.4's decorator syntax::

    @cache_page(60 * 15)
    def slashdot_this(request):
        ...

``cache_page`` takes a single argument: the cache timeout, in seconds. In the
above example, the result of the ``slashdot_this()`` view will be cached for 15
minutes.

Cache de fragmento de template
==============================

.. versionadded:: 1.0

If you're after even more control, you can also cache template fragments using
the ``cache`` template tag. To give your template access to this tag, put
``{% load cache %}`` near the top of your template.

The ``{% cache %}`` template tag caches the contents of the block for a given
amount of time. It takes at least two arguments: the cache timeout, in seconds,
and the name to give the cache fragment. For example::

    {% load cache %}
    {% cache 500 sidebar %}
        .. sidebar ..
    {% endcache %}

Sometimes you might want to cache multiple copies of a fragment depending on
some dynamic data that appears inside the fragment. For example, you might want a
separate cached copy of the sidebar used in the previous example for every user
of your site. Do this by passing additional arguments to the ``{% cache %}``
template tag to uniquely identify the cache fragment::

    {% load cache %}
    {% cache 500 sidebar request.user.username %}
        .. sidebar for logged in user ..
    {% endcache %}

It's perfectly fine to specify more than one argument to identify the fragment.
Simply pass as many arguments to ``{% cache %}`` as you need.

The cache timeout can be a template variable, as long as the template variable
resolves to an integer value. For example, if the template variable
``my_timeout`` is set to the value ``600``, then the following two examples are
equivalent::

    {% cache 600 sidebar %} ... {% endcache %}
    {% cache my_timeout sidebar %} ... {% endcache %}

This feature is useful in avoiding repetition in templates. You can set the
timeout in a variable, in one place, and just reuse that value.

A API de baixo nível do cache
=============================

Algumas vezes, o cache de uma página completa renderizada não é de grande valor.
Por exemplo, você pode descobrir que basta fazer o cache do resultado de uma consulta
intensiva ao banco de dados. Em casos assim, você pode usar a API de baixo nível
de cache para guardar os objetos em qualquer nível de granularidade que você quiser.

A API de cache é simples. O módulo de cache, ``django.core.cache``, exporta um
objeto ``cache`` que é criado automaticamente a partir da configuração
``CACHE_BACKEND``::

    >>> from django.core.cache import cache

A interface básica é ``set(key, value, timeout_seconds)`` e ``get(key)``::

    >>> cache.set('my_key', 'hello, world!', 30)
    >>> cache.get('my_key')
    'hello, world!'

O argumento ``timeout_seconds`` é opcional e o seu padrão é o mesmo do argumento ``timeout``
na configuração ``CACHE_BACKEND`` (explicada acima).

Se o objeto não existe no cache, ``cache.get()`` retorna ``None``::

    >>> cache.get('some_other_key')
    None

    # Espere 30 segundos para 'my_key' expirar...

    >>> cache.get('my_key')
    None

get() pode ter um argumento ``padrão``::

    >>> cache.get('my_key', 'has expired')
    'has expired'

.. versionadded:: 1.0

Para adicionar uma cache somente se ela ainda não existir, use o método ``add()``.
Ele recebe os mesmos parâmetros que ``set()``, mas não irá tentar atualizar o cache se a
chave especificada já estiver presente::

    >>> cache.set('add_key', 'Initial value')
    >>> cache.add('add_key', 'New value')
    >>> cache.get('add_key')
    'Initial value'

Se você precisa saber se ``add()`` salvou um valor no cache, você pode
verificar o valor retornado. O retorno será ``True`` se o valor foi gravado,
e ``False`` se nada for gravado.

Existe também uma interface chamada ``get_many()`` que acessa o cache apenas uma vez.
``get_many()`` retorna um dicionário com todas as chaves que você pediu
que estavam no cache e não estavem expiradas)::

    >>> cache.set('a', 1)
    >>> cache.set('b', 2)
    >>> cache.set('c', 3)
    >>> cache.get_many(['a', 'b', 'c'])
    {'a': 1, 'b': 2, 'c': 3}

Finalmente, você pode remover chaves diferentes com  ``delete()``. Essa é uma forma
fácil de limpar o cache para um objeto em particular::

    >>> cache.delete('a')

É isso. O cache tem muitas poucas restrições: você pode colocar em cache quaisquer
objetos que possam ser 'pickled' seguramente, mas as chaves devem ser strings.

Caches Upstream
===============

Até agora, esse documento concentrou-se no cache de seus *próprios* dados. Mas outro tipo de
cache é relevante para o desenvolvimento Web: o cache executado por cache
"upstream". Esses são sistemas que fazem o cache de páginas para usuários antes mesmo da
requisição chegar ao seu Web site.

Aqui estão algumns exemplos de cache upstream:

    * Seu ISP pode fazer o cache de certas páginas, então se você requisitou uma página de
      somedomain.com, seu ISP poderia entiar a página sem ter de acessar o
      somedomain.com diretamente.

    * Seu Web site Django pode ficar atrás de um proxy Squid
      (http://www.squid-cache.org/) que faz cache de páginas para performance. Nesse
      caso, cada requisição seria tratada primeiramente pelo Squid, e somente seria passada para
      a sua aplicação se necessário.

    * Seu navegador web também faz cache. Se uma página envia os cabeçalhos
      corretos, seu navegador irá usar a cópia local (em cache) para requisições
      subsequentes para essa página.

Caches upstream são um potencializador de eficiência interessante, mas há um perigo nisso:
muitos conteúdos de páginas web diferem baseados na autenticação e em diversas outras
variáveis, e sistemas de cache que servem páginas baseadas em URL cegamente
poderiam expor dados incorretos ou sensíveis para visitantes subsequentes a
essas páginas.

Por exemplo, digamos que você opere um serviço de webmail, e o conteúdo da página
"inbox" obviamente depende do usuário que está logado. Se um ISP cegamente
cacheia seu site, então o primeiro usuário que logou através desse ISP poderia ter
seu conteúdo da caixa de entrada exposto aos próximos visitantes do site. Isso
não é legal.

Felizmente, o HTTP fornece uma solução para esse problema: um conjunto de cabeçalhos HTTP
existem para instruir os diferentes mecanismos de cache de diferir seus conteúdos de cache
de acordo com certas variáveis, e como dizer aos mecanismos de cache como 
não cachear certas páginas em particular.

Usando cabeçalhos Vary
======================

Um desses cabeçalhos é o ``Vary``. Ele define quais cabeçalhos da requisição
um mecanismo de cache deve levar em conta ao construir sua chave de cache. 
Por exemplo, se o conteúdo do site de uma págfina web depende da preferência de
idioma do usuário, dizemos que a página "varia no idioma."

Por padrão, o sistema de cache do DJango cria suas chaves de acesso usando o caminho 
da requisição -- e.g., ``"/stories/2005/jun/23/bank_robbed/"``. Isso significa que cada
requisição a essa URL irá usar a mesma versão do cache, não importando as diferentes
de agente de usuário, como cookies ou preferência de idioma.

É onde entra o ``Vary``.

If your Django-powered page outputs different content based on some difference
in request headers -- such as a cookie, or language, or user-agent -- you'll
need to use the ``Vary`` header to tell caching mechanisms that the page output
depends on those things.

To do this in Django, use the convenient ``vary_on_headers`` view decorator,
like so::

    from django.views.decorators.vary import vary_on_headers

    # Python 2.3 syntax.
    def my_view(request):
        ...
    my_view = vary_on_headers(my_view, 'User-Agent')

    # Python 2.4 decorator syntax.
    @vary_on_headers('User-Agent')
    def my_view(request):
        ...

In this case, a caching mechanism (such as Django's own cache middleware) will
cache a separate version of the page for each unique user-agent.

The advantage to using the ``vary_on_headers`` decorator rather than manually
setting the ``Vary`` header (using something like
``response['Vary'] = 'user-agent'``) is that the decorator adds to the ``Vary``
header (which may already exist) rather than setting it from scratch.

You can pass multiple headers to ``vary_on_headers()``::

    @vary_on_headers('User-Agent', 'Cookie')
    def my_view(request):
        ...

Because varying on cookie is such a common case, there's a ``vary_on_cookie``
decorator. These two views are equivalent::

    @vary_on_cookie
    def my_view(request):
        ...

    @vary_on_headers('Cookie')
    def my_view(request):
        ...

Also note that the headers you pass to ``vary_on_headers`` are not case
sensitive. ``"User-Agent"`` is the same thing as ``"user-agent"``.

You can also use a helper function, ``django.utils.cache.patch_vary_headers``,
directly::

    from django.utils.cache import patch_vary_headers
    def my_view(request):
        ...
        response = render_to_response('template_name', context)
        patch_vary_headers(response, ['Cookie'])
        return response

``patch_vary_headers`` takes an ``HttpResponse`` instance as its first argument
and a list/tuple of header names as its second argument.

For more on Vary headers, see the `official Vary spec`_.

.. _`official Vary spec`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44

Controlando o cache: Usando outros cabeçalhos
=============================================

Another problem with caching is the privacy of data and the question of where
data should be stored in a cascade of caches.

A user usually faces two kinds of caches: his own browser cache (a private
cache) and his provider's cache (a public cache). A public cache is used by
multiple users and controlled by someone else. This poses problems with
sensitive data: You don't want, say, your banking-account number stored in a
public cache. So Web applications need a way to tell caches which data is
private and which is public.

The solution is to indicate a page's cache should be "private." To do this in
Django, use the ``cache_control`` view decorator. Example::

    from django.views.decorators.cache import cache_control
    @cache_control(private=True)
    def my_view(request):
        ...

This decorator takes care of sending out the appropriate HTTP header behind the
scenes.

There are a few other ways to control cache parameters. For example, HTTP
allows applications to do the following:

    * Define the maximum time a page should be cached.
    * Specify whether a cache should always check for newer versions, only
      delivering the cached content when there are no changes. (Some caches
      might deliver cached content even if the server page changed -- simply
      because the cache copy isn't yet expired.)

In Django, use the ``cache_control`` view decorator to specify these cache
parameters. In this example, ``cache_control`` tells caches to revalidate the
cache on every access and to store cached versions for, at most, 3600 seconds::

    from django.views.decorators.cache import cache_control
    @cache_control(must_revalidate=True, max_age=3600)
    def my_view(request):
        ...

Any valid ``Cache-Control`` HTTP directive is valid in ``cache_control()``.
Here's a full list:

    * ``public=True``
    * ``private=True``
    * ``no_cache=True``
    * ``no_transform=True``
    * ``must_revalidate=True``
    * ``proxy_revalidate=True``
    * ``max_age=num_seconds``
    * ``s_maxage=num_seconds``

For explanation of Cache-Control HTTP directives, see the `Cache-Control spec`_.

(Note that the caching middleware already sets the cache header's max-age with
the value of the ``CACHE_MIDDLEWARE_SETTINGS`` setting. If you use a custom
``max_age`` in a ``cache_control`` decorator, the decorator will take
precedence, and the header values will be merged correctly.)

If you want to use headers to disable caching altogether,
``django.views.decorators.cache.never_cache`` is a view decorator that adds
headers to ensure the response won't be cached by browsers or other caches. Example::

    from django.views.decorators.cache import never_cache
    @never_cache
    def myview(request):
        ...

.. _`Cache-Control spec`: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9

Outras otimizações
==================

O Django vem com alguns outros middlewares que podem ajudar a otimizar a performance
do seu aplicativo:

    * ``django.middleware.http.ConditionalGetMiddleware`` adiciona suporte para
      GET condicional. Isso faz uso dos cabeçalhos ``ETag`` e ``Last-Modified``.

    * ``django.middleware.gzip.GZipMiddleware`` comprime conteúdo para navegadores que
      entendem a compressão gzip (todos os navegadores modernos).

Ordem das MIDDLEWARE_CLASSES
============================

If you use caching middleware, it's important to put each half in the right
place within the ``MIDDLEWARE_CLASSES`` setting. That's because the cache
middleware needs to know which headers by which to vary the cache storage.
Middleware always adds something to the ``Vary`` response header when it can.

``UpdateCacheMiddleware`` runs during the response phase, where middleware is
run in reverse order, so an item at the top of the list runs *last* during the
response phase. Thus, you need to make sure that ``UpdateCacheMiddleware``
appears *before* any other middleware that might add something to the ``Vary``
header. The following middleware modules do so:

    * ``SessionMiddleware`` adds ``Cookie``
    * ``GZipMiddleware`` adds ``Accept-Encoding``
    * ``LocaleMiddleware`` adds ``Accept-Language``

``FetchFromCacheMiddleware``, on the other hand, runs during the request phase,
where middleware is applied first-to-last, so an item at the top of the list
runs *first* during the request phase. The ``FetchFromCacheMiddleware`` also
needs to run after other middleware updates the ``Vary`` header, so
``FetchFromCacheMiddleware`` must be *after* any item that does so.
