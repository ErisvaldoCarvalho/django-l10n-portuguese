..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11348 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _topics-db-sql:

Performing raw SQL queries
==========================

Sinta-se livre para escrever consultas SQL nos métodos de seus modelos e métodos
a nível de módulo. O objeto ``django.db.connection`` representa a conexão 
atual com o banco de dados, e ``django.db.transaction`` representa
a transação atual do banco de dados. Para usá-lo, chame ``connection.cursor()`` para
capturar o objeto cursor. Então, chame ``cursor.execute(sql, [params])`` para
executar o SQL e ``cursor.fetchone()`` ou ``cursor.fechall()`` para retornar o
resultado em linhas. Após performar a operação que modica os dados, você deve então chamar
``transaction.commit_unless_managed()`` para garantir que as mudanças estejam confirmadas
no banco de dados. Se sua consulta é puramente uma operção de leitura de dados, nenhum commit
é requerido. Por exemplo::

    def my_custom_sql(self):
        from django.db import connection, transaction
        cursor = connection.cursor()

        # Data modifying operation - commit required
        cursor.execute("UPDATE bar SET foo = 1 WHERE baz = %s", [self.baz])
        transaction.commit_unless_managed()

        # Data retrieval operation - no commit required
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()

        return row

.. _transactions-and-raw-sql:

Transactions and raw SQL
------------------------
If you are using transaction decorators (such as ``commit_on_success``) to
wrap your views and provide transaction control, you don't have to make a
manual call to ``transaction.commit_unless_managed()`` -- you can manually
commit if you want to, but you aren't required to, since the decorator will
commit for you. However, if you don't manually commit your changes, you will
need to manually mark the transaction as dirty, using
``transaction.set_dirty()``::

    @commit_on_success
    def my_custom_sql_view(request, value):
        from django.db import connection, transaction
        cursor = connection.cursor()

        # Data modifying operation
        cursor.execute("UPDATE bar SET foo = 1 WHERE baz = %s", [value])

        # Since we modified data, mark the transaction as dirty
        transaction.set_dirty()

        # Data retrieval operation. This doesn't dirty the transaction,
        # so no call to set_dirty() is required.
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [value])
        row = cursor.fetchone()

        return render_to_response('template.html', {'row': row})

The call to ``set_dirty()`` is made automatically when you use the Django ORM
to make data modifying database calls. However, when you use raw SQL, Django
has no way of knowing if your SQL modifies data or not. The manual call to
``set_dirty()`` ensures that Django knows that there are modifications that
must be committed.

Connections and cursors
-----------------------

``connection`` and ``cursor`` maioritariamente implementa a 
`DB-API padrão do Python`_ (exceto quando se trata de :ref:`manipulação de 
transações <topics-db-transactions>`). Se você não está familiarizado com a 
DB-API do Python, note que a consulta SQL em ``cursor.execute()`` possui 
marcadores, ``"%s"``, ao invés de adicionar paramêtros diretamente dentro do SQL.
Se você usa esta técnica, as bibliotecas de banco de dados subjacentes irão 
automaticamente addicionar aspas e espacar seus paramêtros quando necessário.
(Também atente que o Django espera pelo marcador ``"%s"``, *não* pelo marcador
``"?"``, que é utilizado pelos bindings para Python do SQLite. Isto é por uma 
questão de coerência e bom senso.)

Um lembrete final: Se tudo que você quer é fazer uma clausula ``WHERE`` 
customizada, você pode somente usar os argumentos ``where``, ``tables`` e 
``params`` da API padrão.

.. _DB-API padrão do Python: http://www.python.org/peps/pep-0249.html
