..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: Done, waiting for revision. $
..   $OriginalRevision: 9368 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _topics-db-sql:

Performing raw SQL queries
==========================

Sinta-se livre para escrever consultas SQL nos métodos de seus modelos e métodos
a nível de módulo. O objeto ``django.db.connection`` representa a conexão 
corrente com o banco de dados. Para usá-lo, chame ``connection.cursor()`` para
capturar o objeto cursor. Então, chame ``cursor.execute(sql, [params])`` para
executar o SQL e ``cursor.fetchone()`` ou ``cursor.fechall()`` para retornar o
resultado em linhas. Exemplo::

    def my_custom_sql(self):
        from django.db import connection
        cursor = connection.cursor()
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()
        return row

``connection`` and ``cursor`` maioritariamente implementa a 
`DB-API padrão do Python`_ (exceto quando se trata de :ref:`manipulação de 
transações <topics-db-transactions>`). Se você não está familiarizado com a 
DB-API do Python, note que a consulta SQL em ``cursor.execute()`` possui 
marcadores, ``"%s"``, ao invés de adicionar paramêtros diretamente dentro do SQL.
Se você usa esta técnica, as bibliotecas de banco de dados subjacentes irão 
automaticamente addicionar aspas e espacar seus paramêtros quando necessário.
(Também atente que o Django espera pelo marcador ``"%s"``, *não* pelo marcador
``"?"``, que é utilizado pelos bindings para Python do SQLite. Isto é por uma 
questão de coerência e bom senso.)

Um lembrete final: Se tudo que você quer é fazer uma clausula ``WHERE`` 
customizada, você pode somente usar os argumentos ``where``, ``tables`` e 
``params`` da API padrão.

.. _DB-API padrão do Python: http://www.python.org/peps/pep-0249.html
