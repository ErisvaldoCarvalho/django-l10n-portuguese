..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11332 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _topics-db-transactions:

========================================
Gerenciando transações de banco de dados
========================================

O Django dá a você poucos caminhos para controlar como as transações de banco de
dados são gerenciadas, isso se você estiver usando um banco de dados que suporta
transações.

Comportamento padrão de transações com Django
=============================================

O comportamento padrão do Django é executar com uma transação aberta que ele
comita automaticamente quando quaisquer função interna que modifique a base 
de dados for chamada. Por exemplo, se você chamar ``model.save()`` ou ``model.delete()``, 
a mudança vai ser realizada imediatamente.

Isso parece muito com a configuração auto-commit para a maioria dos bancos
de dados. Tão logo você performe uma ação que precisa escrever no banco
de dados, o Django produz um comando ``INSERT``/``UPDATE``/``DELETE`` e
então faz um ``COMMIT``. Não há ``ROLLBACK`` implícito.

Amarrando transações às requisições HTTP
========================================

A forma recomendada de lidar com transações em requisições Web é amarrá-las
às fases requisição/resposta através do ``TransactionMiddleware`` do Django.

Funciona assim: quando uma requisição é iniciada, o Django começa uma transação.
Se a resposta é produzida sem problemas, o Django commita quaisquer transações
pendentes. Se a função view produz uma exceção, o Django faz um rollback de
quaisquer transações pendentes.

Para ativar esta funcionalidade, apenas adicione o ``TransactionMiddleware``
middleware nos eu setting ``MIDDLEWARE_CLASSES``::

    MIDDLEWARE_CLASSES = (
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.cache.CacheMiddleware',
        'django.middleware.transaction.TransactionMiddleware',
    )

A ordem é bastante importante. O middleware de transação se aplica não somente
às funções da view, mas também a todos os módulos middleware que que vem após o
mesmo. Então, se você usar o session middleware após o transaction middleware, a
criação de sessões será parte da transação.

Uma exceção a isso seria o ``CacheMiddleware``, que nunca é afetado. O cache
middleware usa seu próprio cursor de banco de dados (que é mapeado para a sua
própria conexão de banco de dados internamente).

Controlando o gerenciamento de transações direto nas views
==========================================================

Para a maioria das pessoas, transações baseadas em requisições funciona
maravilhosamente bem. Contudo, se você precisa de um controle mais fino
sobre como suas transações são gerenciadas, você pode usar os decoradores
do Python para mudar a forma como as transações são lidadas por uma função
view em particular.

.. note::

    Mesmo os exemplos abaixo usando funções de view como exemplo, esses
    decoradores também podem ser aplicados para funções que não view.

``django.db.transaction.autocommit``
------------------------------------

Use o decorador ``autocommit`` para mudar o comportamento padrão de commit de
uma view, independente da configuração global das transações.

Exemplo::

    from django.db import transaction

    @transaction.autocommit
    def viewfunc(request):
        ....

Dentro de ``viewfunc()``, transações serão commitadas quão logo você chame
``model.save()``, ``model.delete()``, ou qualquer outra função que escreva
na base de dados.

``django.db.transaction.commit_on_success``
-------------------------------------------

Utilize o decorador ``commit_on_success`` para usar transações únicas para
todo o trabalho feito em uma função::

    from django.db import transaction

    @transaction.commit_on_success
    def viewfunc(request):
        ....

Se a função retorna com sucesso, então o Django irá commitar todo o trabalho
feito na função até aquele ponto. Se a função levanta uma exceção, todavia,
o Django irá fazer um rollback na transação.

``django.db.transaction.commit_manually``
-----------------------------------------

Use o decorador ``commit_manually`` se você precisa de um controle completo
sobre as transações. Ele diz ao Django que você mesmo irá gerenciar a trasação.

Se seu view muda o dado e não executa um ``commit()`` ou ``rollback()``, o
Django irá lançar uma exceção ``TransactionManagementError``.

Gerenciamento manual de transações parece com isso::

    from django.db import transaction

    @transaction.commit_manually
    def viewfunc(request):
        ...
        # Você pode comitar/retroceder quando e onde quiser.
        transaction.commit()
        ...

        # Mas terá de lembrar de fazê-lo você mesmo!
        try:
            ...
        except:
            transaction.rollback()
        else:
            transaction.commit()

.. admonition:: Uma nota importante para usuários de versões anteriores do Django:

    Os métodos de banco de dados ``connection.commit()`` e
    ``connection.rollback()`` (chamados ``db.commit()`` e ``db.rollback`` na
    versão 0.91 e anteriores) não existem mais. Eles foram substituídos por
    ``transation.commit()`` e ``transation.rollback()``.

Como desativar globalmente o gerenciamentod e transações
========================================================

Controladores obsecados, podem disabilitar totalmente todo gerenciamento de
transações
Control freaks can totally disable all transaction management by setting
``DISABLE_TRANSACTION_MANAGEMENT`` to ``True`` in the Django settings file.

Se você fizer isso, o Django não irá prover qualquer gerenciamento de transação
automático qualquer. O middleware não irá implicitamente comitar as transações,
e você precisará gerenciar os rollbacks. Isto requer que você mesmo comita as
alterações feitas pelo middleware e algo a mais.

Deste modo, é melhor usar isto em situações onde você precisa rodar o seu
próprio middleware de controle de transações ou fazer algo realmente estranho.
Em quase todas as situações, você se dará melhor usando o comportamento padrão,
ou o middleware, e somente modificar as funções selecionadas caso precise.

.. _topics-db-transactions-savepoints:

Savepoints
==========

A savepoint is a marker within a transaction that enables you to roll back
part of a transaction, rather than the full transaction. Savepoints are
available to the PostgreSQL 8 and Oracle backends. Other backends will
provide the savepoint functions, but they are empty operations - they won't
actually do anything.

Savepoints aren't especially useful if you are using the default
``autocommit`` behaviour of Django. However, if you are using
``commit_on_success`` or ``commit_manually``, each open transaction will build
up a series of database operations, awaiting a commit or rollback. If you
issue a rollback, the entire transaction is rolled back. Savepoints provide
the ability to perform a fine-grained rollback, rather than the full rollback
that would be performed by ``transaction.rollback()``.

Savepoints are controlled by three methods on the transaction object:

.. method:: transaction.savepoint()

    Creates a new savepoint. This marks a point in the transaction that
    is known to be in a "good" state.

    Returns the savepoint ID (sid).

.. method:: transaction.savepoint_commit(sid)

    Updates the savepoint to include any operations that have been performed
    since the savepoint was created, or since the last commit.

.. method:: transaction.savepoint_rollback(sid)

    Rolls the transaction back to the last point at which the savepoint was
    committed.

The following example demonstrates the use of savepoints::

    from django.db import transaction

    @transaction.commit_manually
    def viewfunc(request):

      a.save()
      # open transaction now contains a.save()
      sid = transaction.savepoint()

      b.save()
      # open transaction now contains a.save() and b.save()

      if want_to_keep_b:
          transaction.savepoint_commit(sid)
          # open transaction still contains a.save() and b.save()
      else:
          transaction.savepoint_rollback(sid)
          # open transaction now contains only a.save()

      transaction.commit()

Transações no MySQL
===================

Se você estiver usando o MySQL, suas tabelas podem ou não suportar transações;
isto depende da versão do MySQL e do tipo de tabelas que você está usando. (Para
"tipo de tabela," significa algo como "InnoDB" ou "MyISAM".) As peculiaridades
de transações no MySQL são fora do escopo do artigo, mas o site do MySQL tem
`informações sobre as transações no MySQL`_.

Se sua instalação do MySQL *não* suporta transações, então o Django irá
funcionar no modo auto-comit: As consultas serão executadas e comitadas logo que
forem chamadas. Se sua instalação do MySQL *suporta* transações, o Django irá
manipular as transações como explicado neste documento.

.. _informações sobre as transações no MySQL: http://dev.mysql.com/doc/refman/5.0/en/sql-syntax-transactions.html

Handling exceptions within PostgreSQL transactions
==================================================

When a call to a PostgreSQL cursor raises an exception (typically
``IntegrityError``), all subsequent SQL in the same transaction will fail with
the error "current transaction is aborted, queries ignored until end of
transaction block". Whilst simple use of ``save()`` is unlikely to raise an
exception in PostgreSQL, there are more advanced usage patterns which
might, such as saving objects with unique fields, saving using the
force_insert/force_update flag, or invoking custom SQL.

There are several ways to recover from this sort of error.

Transaction rollback
--------------------

The first option is to roll back the entire transaction. For example::

    a.save() # Succeeds, but may be undone by transaction rollback
    try:
        b.save() # Could throw exception
    except IntegrityError:
        transaction.rollback()
    c.save() # Succeeds, but a.save() may have been undone

Calling ``transaction.rollback()`` rolls back the entire transaction. Any
uncommitted database operations will be lost. In this example, the changes
made by ``a.save()`` would be lost, even though that operation raised no error
itself.

Savepoint rollback
------------------

If you are using PostgreSQL 8 or later, you can use :ref:`savepoints
<topics-db-transactions-savepoints>` to control the extent of a rollback.
Before performing a database operation that could fail, you can set or update
the savepoint; that way, if the operation fails, you can roll back the single
offending operation, rather than the entire transaction. For example::

    a.save() # Succeeds, and never undone by savepoint rollback
    try:
        sid = transaction.savepoint()
        b.save() # Could throw exception
        transaction.savepoint_commit(sid)
    except IntegrityError:
        transaction.savepoint_rollback(sid)
    c.save() # Succeeds, and a.save() is never undone

In this example, ``a.save()`` will not be undone in the case where
``b.save()`` raises an exception.

