..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11268 $
..   $TranslationAuthors: Walter Cruz, Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _topics-db-models:

======
Models
======

.. module:: django.db.models

Um modelo é a fonte única e definitiva de dados sobre os seus dados. Ele contém
os campos e comportamentos essenciais dos dados que você está gravando.
Geralmente, cada modelo mapeia para uma única tabela no banco de dados.

O básico:

    * Cada modelo é uma classe Python que extende
      :class:`django.db.models.Model`.

    * Cada atributo do modelo representa uma coluna do banco de dados.

    * Com tudo isso, o Django lhe dá uma API de acesso a banco de dados gerada
      automaticamente, o que é explicado em :ref:`topics-db-queries`.

.. seealso::

    Um companheiro para esse documento é o `repositório oficial de exemplos de
    modelo`_. (Na distribuição do fonte do Django, esses exemplos estão no
    diretório ``tests/modeltests``.)

    .. _repositório oficial de exemplos de modelo: http://www.djangoproject.com/documentation/models/


Exemplo rápido
==============

Esse modelo de exemplo define uma ``Person``, que tem um ``first_name`` e um
``last_name``::

    from django.db import models

    class Person(models.Model):
        first_name = models.CharField(max_length=30)
        last_name = models.CharField(max_length=30)

``first_name`` e ``last_name`` são *campos* do modelo. Cada campo é especificado
como um atributo de classe, e cada atributo é mapeado para uma coluna no banco
de dados.

O modelo ``Person`` acima criaria uma tabela assim:

.. code-block:: sql

    CREATE TABLE myapp_person (
        "id" serial NOT NULL PRIMARY KEY,
        "first_name" varchar(30) NOT NULL,
        "last_name" varchar(30) NOT NULL
    );

Algumas notas técnicas:

    * O nome da tabela, ``myapp_person``, é automaticamente derivado de alguns
      metadados do modelo, no entanto isto pode ser sobrescrito. Veja
      :ref:`table-names` abaixo.

    * Um campo ``id`` é adicionado automaticamente, mas esse comportamento
      também pode ser alterado. Veja :ref:`automatic-primary-key-fields` abaixo.

    * O comando SQL ``CREATE TABLE`` nesse exemplo é formatado usando a sintaxe do
      PostgreSQL, mas é digno de nota que o Django usa o SQL adaptado ao banco de dados
      especificado no seu :ref:`arquivo de configurações <topics-settings>`.

Usando models
==============

Uma vez que já tenha criado seus modelos, o passo final é dizer ao Django para
usar estes modelos. Para isto, basta editar seu arquivo settings.py e mudar o
:setting:`INSTALLED_APPS` adicionando o nome do módulo que contém seu
``models.py``.

Por exemplo, se os modelos de sua aplicação ficam no módulo
``mysite.myapp.models`` (a estrutura de pacote que é criada para uma aplicação
pelo script :djadmin:`manage.py startapp <startapp>`), o
:setting:`INSTALLED_APPS` deve ler, em parte::

    INSTALLED_APPS = (
        #...
        'mysite.myapp',
        #...
    )

Quando você adicionar novas aplicações ao :setting:`INSTALLED_APPS`, assegure-se
de rodar o :djadmin:`manage.py syncdb <syncdb>`.

Campos
======

A parte mais importante do modelo -- e a única obrigatória -- é a lista de
campos do banco de dados que ele define. Campos são especificados por meio de
atributos de classe.

Exemplo::

    class Musician(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        instrument = models.CharField(max_length=100)

    class Album(models.Model):
        artist = models.ForeignKey(Musician)
        name = models.CharField(max_length=100)
        release_date = models.DateField()
        num_stars = models.IntegerField()

Tipos de campos
---------------

Cada campo no seu modelo deve ser uma instância da classe
:class:`~django.db.models.Field` apropriada. O Django usa os tipos das classes
para determinar algumas coisas:

    * O tipo de coluna no banco de dados (ex: ``INTEGER``, ``VARCHAR``).

    * O widget a ser usado na interface administrativa do Django, se você a
      utilizar (ex: ``<input type="text">``, ``<select>``).

    * Os requisitos mínimos para validação, usados no site de administração do
      Django e nos formulários automaticamente gerados.

O Django é disponibilizado com dezenas de tipos de campos embutidos; você pode
encontrar a lista completa em :ref:`referência de campos do model
<model-field-types>`. Você também pode facilmente escrever seus próprios tipos
de campos se os que acompanham o Django não lhe servirem; veja
:ref:`howto-custom-model-fields`.

Field options
-------------

Each field takes a certain set of field-specific arguments (documented in the
:ref:`model field reference <model-field-types>`). For example,
:class:`~django.db.models.CharField` (and its subclasses) require a
:attr:`~django.db.models.CharField.max_length` argument which specifies the size
of the ``VARCHAR`` database field used to store the data.

There's also a set of common arguments available to all field types. All are
optional. They're fully explained in the :ref:`reference
<common-model-field-options>`, but here's a quick summary of the most often-used
ones:

    :attr:`~Field.null`
        Se ``True``, o Django irá gravar  valores vazios como ``NULL`` no banco
        de dados. O padrão é ``False``.

    :attr:`~Field.blank`
        Se ``True``, o campo pode ser vazio. o padrão é ``False``.

        Note que isso é diferente de :attr:`~Field.null`. :attr:`~Field.null` é
        puramente relacionado ao banco de dados, e :attr:`~Field.blank` é
        relacionado com validação. Se um campo tem
        :attr:`blank=True <Field.blank>`, a validação na administração do Django
        irá permitir a entrada de um valor vazio. Se um campo tem
        :attr:`blank=False <Field.blank>`, o campo será obrigatório.

    :attr:`~Field.choices`
        Um iterável(e.g., uma lista ou tupla) de tupla duplas para usar como
        escolhas para esse campo. Se fornecido, a administração do Django usará
        uma caixa de seleção no lugar de um campo de texto padrão e irá limitar
        as escolhas as opções dadas.

        Uma lista de opções é parece com isso::

            YEAR_IN_SCHOOL_CHOICES = (
                (u'FR', u'Freshman'),
                (u'SO', u'Sophomore'),
                (u'JR', u'Junior'),
                (u'SR', u'Senior'),
                (u'GR', u'Graduate'),
            )

        O primeiro elemeno de cada tupla é o verdadeiro valor a ser gravado. O
        segundo elemento será mostrado pela interface de adminsitração, ou em um
        ModelChoiceField. Dada uma instância de um objeto de model, o valor
        mostrado pelo campo choices pode ser acessado usando o método
        ``get_FOO_display``. Por exemplo::

            from django.db import models

            class Person(models.Model):
                GENDER_CHOICES = (
                    (u'M', u'Male'),
                    (u'F', u'Female'),
                )
                name = models.CharField(max_length=60)
                gender = models.CharField(max_length=2, choices=GENDER_CHOICES)

        ::

            >>> p = Person(name="Fred Flinstone", gender="M")
            >>> p.save()
            >>> p.gender
            u'M'
            >>> p.get_gender_display()
            u'Male'

    :attr:`~Field.default`
        O valor padrão para o campo. Pode ser também um objeto chamável. Se for
        um chamável, será chamado a cada vez que um novo objeto for criado.

    :attr:`~Field.help_text`
        Um texto de "ajuda" extra para ser mostrado sob o campo no formulário de
        objetos do admin. É útil para documentação, mesmo que seu objeto
        não tenha um formulário administrativo.

    :attr:`~Field.primary_key`
        Se ``True``, esse campo será a chave primária para o modelo.

        Se você não especificar :attr:`primary_key=True <Field.primary_key>``
        para nenhum campo no seu modelo, o Django adicionará automaticamente um
        campo :class:`IntegerField` para ser a chave primária, desta forma, você
        não precisa configurar o :attr:`primary_key=True <Field.primary_key>``
        em qualquer um dos seus campos a menos que você queira sobrescrever o
        comportamento padrão de chaves primárias. Para saber mais,
        :ref:`automatic-primary-key-fields`.

    :attr:`~Field.unique`
        Se ``True``, esse campo deve ser único na tabela.

Novamente, estes são somente descrições curtas das opções mais comuns dos
campos. Detalhes completos podem ser encontrados na :ref:`referência de opções
dos campos comuns do model <common-model-field-options>`.

.. _automatic-primary-key-fields:

Automatic primary key fields
----------------------------

By default, Django gives each model the following field::

    id = models.AutoField(primary_key=True)

This is an auto-incrementing primary key.

If you'd like to specify a custom primary key, just specify
:attr:`primary_key=True <Field.primary_key>` on one of your fields. If Django
sees you've explicitly set :attr:`Field.primary_key`, it won't add the automatic
``id`` column.

Each model requires exactly one field to have :attr:`primary_key=True
<Field.primary_key>`.

.. _verbose-field-names:

Nomes de campos por extenso
---------------------------

Cada tipo de campo, exceto :class:`~django.db.models.ForeignKey`,
:class:`~django.db.models.ManyToManyField` e
:class:`~django.db.models.OneToOneField`, recebem um primeiro argumento
opcional -- um nome por extenso. Se o nome por extenso não é informado, o Django
criará automaticamente a partir do atributo name do campo, convertendo
underscores em espaços.

Nesse exemplo, o nome por extenso é ``"Person's first name"``::

    first_name = models.CharField("Person's first name", max_length=30)

Nesse exemplo, o nome por extenso é ``"first name"``::

    first_name = models.CharField(max_length=30)

:class:`~django.db.models.ForeignKey`,
:class:`~django.db.models.ManyToManyField` e
:class:`~django.db.models.OneToOneField` requerem que o primeiro argumento
seja uma classe do modelo, assim usa o argumento :attr:`~Fields.verbose_name`
como um argumento nomeado::

    poll = models.ForeignKey(Poll, verbose_name="the related poll")
    sites = models.ManyToManyField(Site, verbose_name="list of sites")
    place = models.OneToOneField(Place, verbose_name="related place")

A convenção é não colocar em caixa alta a primeira letra do
:attr:`~Field.verbose_name`. O Django irá automaticamente capitalizar a primeira
letra quando for necessário.

Relacionamentos
---------------

Claramente, o poder dos bancos relacionais reside na capacidade de relacionar
tabelas umas as outroas. O Django oferece formas de definir os três
tipos de relacionamento mais comuns: muitos-para-um, muitos-para-muitos e
um-para-um.

Relacionamentos muitos-para-um
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para definir um relacionamento muitos para um, use
:class:`~django.db.models.ForeignKey`. Você o usa como qualquer outro
:class:`~django.db.models.Field``: incluindo-o como um atributo de classe no seu
modelo.

O :class:`~django.db.models.ForeignKey` requer um argumento posicional: a classe
a qual esse modelo é relacionado.

Por exemplo, se um modelo ``Car`` tem um ``Manufacturer`` -- isso é, um
``Manufacturer`` faz múltiplos carros, mas cada ``Car`` somente tem um
``Manufacturer`` -- use as seguintes definições::

    class Manufacturer(models.Model):
        # ...

    class Car(models.Model):
        manufacturer = models.ForeignKey(Manufacturer)
        # ...

Para criar um :ref:`relacionamento recursivo <recursive-relationships>` -- (um
objeto que tem um relacionamento muitos para um consigo mesmo) e
:ref:`relacionamentos com models que ainda não foram definidos
<lazy-relationships>`; veja :ref:`a referêcia de campos do model
<ref-foreignkey>` para mais detalhes.

É sugerido, mas não obrigatório, que o nome de um campo
:class:`~django.db.models.ForeignKey` (``manufacturer`` do exemplo acima) seja o
nome do model, em minúsculo. Você pode, é claro, chamar o campo como você
quiser. Por exemplo::

    class Car(models.Model):
        company_that_makes_it = models.ForeignKey(Manufacturer)
        # ...

.. seealso::

    Veja o `exemplo de relacionamento Muitos-para-um`_ para um exemplo completo.

.. _exemplo de relacionamento Muitos-para-um: http://www.djangoproject.com/documentation/models/many_to_one/

Os campos :class:`~django.db.models.ForeignKey` também aceitam um número extra
de argumentos que são explicados na :ref:`referência de campos do model
<foreign-key-arguments>`. Estas opções ajudam a definir como o relacionamento
deve funcionar; todos são opicionais.

Relacionamentos muitos-para-muitos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para definir um relacionamento muitos-para-muitos, use o
:class:`~django.db.models.ManyToManyField`. Você o utiliza como qualquer outro
tipo de :class:`~django.db.models.Field`: incluíndo ele como um atributo de
classe do seu model.

O :class:`~django.db.models.ManyToManyField` requer um argumento posicional: a
classe à qual esse modelo está relacionado.

For example, if a ``Pizza`` has multiple ``Topping`` objects -- that is, a
``Topping`` can be on multiple pizzas and each ``Pizza`` has multiple toppings
-- here's how you'd represent that::

    class Topping(models.Model):
        # ...

    class Pizza(models.Model):
        # ...
        toppings = models.ManyToManyField(Topping)

As with :class:`~django.db.models.ForeignKey`, you can also create
:ref:`recursive relationships <recursive-relationships>` (an object with a
many-to-one relationship to itself) and :ref:`relationships to models not yet
defined <lazy-relationships>`; see :ref:`the model field reference
<ref-manytomany>` for details.

It's suggested, but not required, that the name of a
:class:`~django.db.models.ManyToManyField` (``toppings`` in the example above)
be a plural describing the set of related model objects.

It doesn't matter which model gets the
:class:`~django.db.models.ManyToManyField`, but you only need it in one of the
models -- not in both.

Generally, :class:`~django.db.models.ManyToManyField` instances should go in the
object that's going to be edited in the admin interface, if you're using
Django's admin. In the above example, ``toppings`` is in ``Pizza`` (rather than
``Topping`` having a ``pizzas`` :class:`~django.db.models.ManyToManyField` )
because it's more natural to think about a pizza having toppings than a
topping being on multiple pizzas. The way it's set up above, the ``Pizza`` admin
form would let users select the toppings.

.. seealso::

    See the `Many-to-many relationship model example`_ for a full example.

.. _Many-to-many relationship model example: http://www.djangoproject.com/documentation/models/many_to_many/

:class:`~django.db.models.ManyToManyField` fields also accept a number of extra
arguments which are explained in :ref:`the model field reference
<manytomany-arguments>`. These options help define how the relationship should
work; all are optional.

.. _intermediary-manytomany:

Extra fields on many-to-many relationships
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

When you're only dealing with simple many-to-many relationships such as
mixing and matching pizzas and toppings, a standard :class:`~django.db.models.ManyToManyField` is all you need. However, sometimes
you may need to associate data with the relationship between two models.

For example, consider the case of an application tracking the musical groups
which musicians belong to. There is a many-to-many relationship between a person
and the groups of which they are a member, so you could use a
:class:`~django.db.models.ManyToManyField` to represent this relationship.
However, there is a lot of detail about the membership that you might want to
collect, such as the date at which the person joined the group.

For these situations, Django allows you to specify the model that will be used
to govern the many-to-many relationship. You can then put extra fields on the
intermediate model. The intermediate model is associated with the
:class:`~django.db.models.ManyToManyField` using the
:attr:`through <ManyToManyField.through>` argument to point to the model
that will act as an intermediary. For our musician example, the code would look
something like this::

    class Person(models.Model):
        name = models.CharField(max_length=128)

        def __unicode__(self):
            return self.name

    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through='Membership')

        def __unicode__(self):
            return self.name

    class Membership(models.Model):
        person = models.ForeignKey(Person)
        group = models.ForeignKey(Group)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)

When you set up the intermediary model, you explicitly specify foreign
keys to the models that are involved in the ManyToMany relation. This
explicit declaration defines how the two models are related.

There are a few restrictions on the intermediate model:

    * Your intermediate model must contain one - and *only* one - foreign key
      to the target model (this would be ``Person`` in our example). If you
      have more than one foreign key, a validation error will be raised.

    * Your intermediate model must contain one - and *only* one - foreign key
      to the source model (this would be ``Group`` in our example). If you
      have more than one foreign key, a validation error will be raised.

    * The only exception to this is a model which has a many-to-many
      relationship to itself, through an intermediary model. In this
      case, two foreign keys to the same model are permitted, but they
      will be treated as the two (different) sides of the many-to-many
      relation.

    * When defining a many-to-many relationship from a model to
      itself, using an intermediary model, you *must* use
      :attr:`symmetrical=False <ManyToManyField.symmetrical>` (see
      :ref:`the model field reference <manytomany-arguments>`).

Now that you have set up your :class:`~django.db.models.ManyToManyField` to use
your intermediary model (``Membership``, in this case), you're ready to start
creating some many-to-many relationships. You do this by creating instances of
the intermediate model::

    >>> ringo = Person.objects.create(name="Ringo Starr")
    >>> paul = Person.objects.create(name="Paul McCartney")
    >>> beatles = Group.objects.create(name="The Beatles")
    >>> m1 = Membership(person=ringo, group=beatles,
    ...     date_joined=date(1962, 8, 16),
    ...     invite_reason= "Needed a new drummer.")
    >>> m1.save()
    >>> beatles.members.all()
    [<Person: Ringo Starr>]
    >>> ringo.group_set.all()
    [<Group: The Beatles>]
    >>> m2 = Membership.objects.create(person=paul, group=beatles,
    ...     date_joined=date(1960, 8, 1),
    ...     invite_reason= "Wanted to form a band.")
    >>> beatles.members.all()
    [<Person: Ringo Starr>, <Person: Paul McCartney>]

Unlike normal many-to-many fields, you *can't* use ``add``, ``create``,
or assignment (i.e., ``beatles.members = [...]``) to create relationships::

    # THIS WILL NOT WORK
    >>> beatles.members.add(john)
    # NEITHER WILL THIS
    >>> beatles.members.create(name="George Harrison")
    # AND NEITHER WILL THIS
    >>> beatles.members = [john, paul, ringo, george]

Why? You can't just create a relationship between a ``Person`` and a ``Group``
- you need to specify all the detail for the relationship required by the
``Membership`` model. The simple ``add``, ``create`` and assignment calls
don't provide a way to specify this extra detail. As a result, they are
disabled for many-to-many relationships that use an intermediate model.
The only way to create this type of relationship is to create instances of the
intermediate model.

The ``remove`` method is disabled for similar reasons. However, the
``clear()`` method can be used to remove all many-to-many relationships
for an instance::

    # Beatles have broken up
    >>> beatles.members.clear()

Once you have established the many-to-many relationships by creating instances
of your intermediate model, you can issue queries. Just as with normal
many-to-many relationships, you can query using the attributes of the
many-to-many-related model::

    # Find all the groups with a member whose name starts with 'Paul'
    >>> Group.objects.filter(members__name__startswith='Paul')
    [<Group: The Beatles>]

As you are using an intermediate model, you can also query on its attributes::

    # Find all the members of the Beatles that joined after 1 Jan 1961
    >>> Person.objects.filter(
    ...     group__name='The Beatles',
    ...     membership__date_joined__gt=date(1961,1,1))
    [<Person: Ringo Starr]


Relacionamentos um-para-um
~~~~~~~~~~~~~~~~~~~~~~~~~~

Para definir um relacionamento um-para-um, use o
:class:`~django.db.models.OneToOneField`. Você deve utilizá-lo
como qualquer outro :class:`~django.db.models.Field`: incluindo-o como um
atributo de classe em seu model.

This is most useful on the primary key of an object when that object "extends"
another object in some way.

:class:`~django.db.models.OneToOneField` requires a positional argument: the
class to which the model is related.

For example, if you were building a database of "places", you would
build pretty standard stuff such as address, phone number, etc. in the
database. Then, if you wanted to build a database of restaurants on
top of the places, instead of repeating yourself and replicating those
fields in the ``Restaurant`` model, you could make ``Restaurant`` have
a :class:`~django.db.models.OneToOneField` to ``Place`` (because a
restaurant "is a" place; in fact, to handle this you'd typically use
:ref:`inheritance <model-inheritance>`, which involves an implicit
one-to-one relation).

As with :class:`~django.db.models.ForeignKey`, a
:ref:`recursive relationship <recursive-relationships>`
can be defined and
:ref:`references to as-yet undefined models <lazy-relationships>`
can be made; see :ref:`the model field reference <ref-onetoone>` for details.

.. seealso::

    See the `One-to-one relationship model example`_ for a full example.

.. _One-to-one relationship model example: http://www.djangoproject.com/documentation/models/one_to_one/

.. versionadded:: 1.0

:class:`~django.db.models.OneToOneField` fields also accept one optional argument
described in the :ref:`model field reference <ref-onetoone>`.

:class:`~django.db.models.OneToOneField` classes used to automatically become
the primary key on a model. This is no longer true (although you can manually
pass in the :attr:`~django.db.models.Field.primary_key` argument if you like).
Thus, it's now possible to have multiple fields of type
:class:`~django.db.models.OneToOneField` on a single model.

Models across files
-------------------

It's perfectly OK to relate a model to one from another app. To do this,
import the related model at the top of the model that holds your model. Then,
just refer to the other model class wherever needed. For example::

    from mysite.geography.models import ZipCode

    class Restaurant(models.Model):
        # ...
        zip_code = models.ForeignKey(ZipCode)

Restrições de nome de campos
----------------------------

O Django impõe apenas duas restrições aos nomes de campos do modelo:

    1. Um nome de campo não pode ser uma palavra reservada do Python, porque
       isso resultaria num erro de sintaxe do Python. Por exemplo::

           class Example(models.Model):
               pass = models.IntegerField() # 'pass' é uma palavra reservada!

    2. Um nome de campo não pode conter mais de um underscore em uma linha,
       devido à forma que a sintaxe de busca de consultas do Django funciona.
       Por exemplo::

           class Example(models.Model):
               foo__bar = models.IntegerField() # 'foo__bar' tem dois underscores!

Essas limitações podem ser trabalhadas, já que o nome do seu campo não precisa
necessariamente ser igual ao nome da coluna no seu banco de dados. Veja a opção
:attr:`~Field.db_column`.

Palavras reservadas do SQL, como ``join``, ``where`` ou ``select``, *são*
permitidas como nomes de campos no modelo, porque o Django escapa todos os
nomes de tabelas e colunas em cada consulta SQL. Ele usa a sintaxe de quoting
do seu banco de dados em particular.

Custom field types
------------------

.. versionadded:: 1.0

If one of the existing model fields cannot be used to fit your purposes, or if
you wish to take advantage of some less common database column types, you can
create your own field class. Full coverage of creating your own fields is
provided in :ref:`howto-custom-model-fields`.

.. _meta-options:

Meta options
============

Give your model metadata by using an inner ``class Meta``, like so::

    class Ox(models.Model):
        horn_length = models.IntegerField()

        class Meta:
            ordering = ["horn_length"]
            verbose_name_plural = "oxen"

Model metadata is "anything that's not a field", such as ordering options
(:attr:`~Options.ordering`), database table name (:attr:`~Options.db_table`), or
human-readable singular and plural names (:attr:`~Options.verbose_name` and
:attr:`~Options.verbose_name_plural`). None are required, and adding ``class
Meta`` to a model is completely optional.

A complete list of all possible :ref:`Meta <meta-options>` options can be found in the :ref:`model
option reference <ref-models-options>`.

.. _model-methods:

Model methods
=============

Define custom methods on a model to add custom "row-level" functionality to your
objects. Whereas :class:`~django.db.models.Manager` methods are intended to do
"table-wide" things, model methods should act on a particular model instance.

This is a valuable technique for keeping business logic in one place -- the
model.

For example, this model has a few custom methods::

    from django.contrib.localflavor.us.models import USStateField

    class Person(models.Model):
        first_name = models.CharField(max_length=50)
        last_name = models.CharField(max_length=50)
        birth_date = models.DateField()
        address = models.CharField(max_length=100)
        city = models.CharField(max_length=50)
        state = USStateField() # Yes, this is America-centric...

        def baby_boomer_status(self):
            "Returns the person's baby-boomer status."
            import datetime
            if datetime.date(1945, 8, 1) <= self.birth_date <= datetime.date(1964, 12, 31):
                return "Baby boomer"
            if self.birth_date < datetime.date(1945, 8, 1):
                return "Pre-boomer"
            return "Post-boomer"

        def is_midwestern(self):
            "Returns True if this person is from the Midwest."
            return self.state in ('IL', 'WI', 'MI', 'IN', 'OH', 'IA', 'MO')

        def _get_full_name(self):
            "Returns the person's full name."
            return '%s %s' % (self.first_name, self.last_name)
        full_name = property(_get_full_name)

The last method in this example is a :term:`property`. `Read more about
properties`_.

.. _Read more about properties: http://www.python.org/download/releases/2.2/descrintro/#property

The :ref:`model instance reference <ref-models-instances>` has a complete list
of :ref:`methods automatically given to each model <model-instance-methods>`.
You can override most of these -- see `overriding predefined model methods`_,
below -- but there are a couple that you'll almost always want to define:

    :meth:`~Model.__unicode__`
        A Python "magic method" that returns a unicode "representation" of any
        object. This is what Python and Django will use whenever a model
        instance needs to be coerced and displayed as a plain string. Most
        notably, this happens when you display an object in an interactive
        console or in the admin.

        You'll always want to define this method; the default isn't very helpful
        at all.

    :meth:`~Model.get_absolute_url`
        This tells Django how to calculate the URL for an object. Django uses
        this in its admin interface, and any time it needs to figure out a URL
        for an object.

        Any object that has a URL that uniquely identifies it should define this
        method.

Overriding predefined model methods
-----------------------------------

There's another set of :ref:`model methods <model-instance-methods>` that
encapsulate a bunch of database behavior that you'll want to customize. In
particular you'll often want to change the way :meth:`~Model.save` and
:meth:`~Model.delete` work.

You're free to override these methods (and any other model method) to alter
behavior.

A classic use-case for overriding the built-in methods is if you want something
to happen whenever you save an object. For example (see
:meth:`~Model.save` for documentation of the parameters it accepts)::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            do_something()
            super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.
            do_something_else()

You can also prevent saving::

    class Blog(models.Model):
        name = models.CharField(max_length=100)
        tagline = models.TextField()

        def save(self, force_insert=False, force_update=False):
            if self.name == "Yoko Ono's blog":
                return # Yoko shall never have her own blog!
            else:
                super(Blog, self).save(force_insert, force_update) # Call the "real" save() method.

It's important to remember to call the superclass method -- that's that
``super(Blog, self).save()`` business -- to ensure that the object still gets
saved into the database. If you forget to call the superclass method, the
default behavior won't happen and the database won't get touched.

Executing custom SQL
--------------------

Outra prática comum é escrever consultas SQL personalizadas em métodos do model
a nível módulo. Para mais detalhe sobre como usar SQL puro, veja a documentação
em :ref:`usando SQL puro<topics-db-sql>`.

.. _model-inheritance:

Herança de modelos
==================

.. versionadded:: 1.0

Herança de models no Django funciona quase igual à forma normal de herança
entre classes do Python. A única decisão que você tem de tomar é se você quer
que os modelos pai sejam modelos no seu próprio contexto (com suas próprias
tabelas de banco de dados), ou se os pais são somente mantenedores de
informações comuns que somente serão visíveis através da herança entre modelos.

Freqüentemente, você só quer usar a classe pai para manter informações que
você não deseja escrever para cada modelo filho. Esta classe nunca será usada
de forma isolada, então :ref:`classes abstratas de base <abstract-base-classes>`
são o que estiver depois. Entretanto, se você está extendendo uma subclasse de
modelo existente (talvez algo de outra aplicação), ou quer que cada modelo tenha
sua própria tabela no banco de dados, :ref:`herança com multi-tabelas
<multi-table-inheritance>` é o caminho a seguir.

.. _abstract-base-classes:

Classes Abstratas de Base
--------------------------

Uma classe abstrata de base é útil quando você quer colocar alguma informação
comum à disposição de vários modelos. Você escreve sua classe de base e coloca
``abstract=True`` dentro da classe :ref:`Meta <meta-options>`. Este modelo não
será usado para criar qualquer tabela no banco de dados. Em vez disso, quando
ele for usado como uma classe abstrata de base por outro modelo, seus campos
serão adicionados aos seus modelos filho. É um erro ter campos na classe
abstrata de base com o mesmo nome daqueles que a herda (o Django irá lançar uma
exceção).

Um exemplo::

    class CommonInfo(models.Model):
        name = models.CharField(max_length=100)
        age = models.PositiveIntegerField()

        class Meta:
            abstract = True

        class Student(CommonInfo):
            home_group = models.CharField(max_length=5)

O modelo ``Student`` possuirá três campos: ``name``, ``age`` e ``home_group``.
O modelo ``CommonInfo`` não pode ser usado como um modelo normal do Django, já
que ele é uma classe abstrata de base. ``CommonInfo`` não gera uma tabela no
banco de dados e nem pode ser instanciado ou salvo diretamente.

Para muitos usos, este tipo de herança de modelo será exatamente o que você
quer. Ele fornece uma maneira de fatorar informações comuns ao nível do Python,
enquanto ao nível do banco de dados só serão criadas tabelas para os modelos
filhos.

Herança de :ref:`Meta <meta-options>`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Quando uma classe abstrata de base é criada, o Django torna qualquer
:ref:`Meta <meta-options>` interno da classe que você criou, disponível como um
atributo a classe de base. Se uma classe filha não declara sua própria classe
:ref:`Meta <meta-options>`, ela irá herdar de seu pai. Se a classe filha quer
extender a classe :ref:`Meta <meta-options>` do pai, ela pode. Por exemplo:

    class CommonInfo(models.Model):
        ...

        class Meta:
            abstract = True
            ordering = ['name']

    class Student(CommonInfo):
        ...

        class Meta(CommonInfo.Meta):
            db_table = 'student_info'

O Django faz um ajuste para a classe :ref:`Meta <meta-options>` de uma classe
abstrata de base: antes instalando o atributo :ref:`Meta <meta-options>`, e
configurando ``abstract=False``. Isto significa que os filhos da classe abstrata
de base não se tornam automaticamente classes abstratas. É claro, você pode
fazer uma classe abstrata de base que herda outra classe abstrata de base. Você
só precisa lembrar de setar explicitamente ``abstract=True`` toda vez.

Alguns atributos não fazem sentido serem incluídos na classe
:ref:`Meta <meta-options>` de uma classe abstrata de base. Por exemplo,
incluindo ``db_table`` poderia significar que todos os filhos (que não
especificarem seus próprios :ref:`Meta <meta-options>`) poderiam usar a mesma
tabela no banco de dados, que é provavelmente o que você não quer.

.. _abstract-related-name:

Seja cuidadoso com ``related_name``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se você esta usando o atributo :attr:`~django.db.models.ForeignKey.related_name`
sobre um ``ForeignKey`` ou ``ManyToManyField``, você sempre deve especificar um
**reverse name** *único* para o campo. Isto normalmente poderia causar um
problema nas classes abstratas de base, já que os campos desta classe são
incluídos em cada classe filha, com exatamente os mesmos valores para os
atributos (incluindo :attr:`~django.db.models.ForeignKey.related_name`) toda
vez.

Para contornar este problema, quando você está usando o
:attr:`~django.db.models.ForeignKey.related_name` em uma classe abstrata de base
(somente), parte do nome deve ser a string ``'%(class)s'``. Isto é substituído
por um nome em minúsculo da classe filha onde o campo é usado. Desde que cada
classe tenha um nome diferente, cada nome relacionado irá acabar sendo
diferente. Por exemplo::

    class Base(models.Model):
        m2m = models.ManyToMany(OtherModel, related_name="%(class)s_related")

        class Meta:
            abstract = True

    class ChildA(Base):
        pass

    class ChildB(Base):
        pass

O **reverse name** do campo ``ChildA.m2m`` será ``childa_related``, enquanto
que o **reverse name** do campo ``ChildB.m2m`` será ``childb_related``. Cabe a
você como usar a porção ``'%(class)s'`` para contruir seu nome relacionado, mas
se você se esquecer de usá-lo, o Django irá lançar erros quando você validar
seus modelos (ou ao rodar o :djadmin:`syncdb`).

Se você não especificar um atributo
:attr:`~django.db.models.ForeignKey.related_name` para um campo em uma
classe abstrata de base, o **reverse name** padrão será o nome da classe filho
seguido por ``'_set'``, do mesmo modo que normalmente seria se você tivesse
declarado na classe filha. Por exemplo, no código acima, se o atributo
:attr:`~django.db.models.ForeignKey.related_name` fosse omitido, o
**reverse name** para o campo ``m2m`` seria ``childa_set`` no caso do ``ChildA``
e ``childb_set`` para o campo ``ChildB``.

.. _multi-table-inheritance:

Herança com Multi-Tabelas
-------------------------

O segundo tipo de herança de modelos suportado pelo Django é quando cada modelo
na hierarquia é um modelo em si mesmo. Cada modelo corresponde a sua própria
tabela no banco de dados e pode ser consultado e criado individualmente. A
relação de herança introduz links entre o modelo filho e cada um de seus pais
(por meio de um campo :class:`~django.db.models.fields.OneToOneField`
criado automaticamente). Por exemplo::

    class Place(models.Model):
        name = models.CharField(max_length=50)
        address = models.CharField(max_length=80)

    class Restaurant(Place):
        serves_hot_dogs = models.BooleanField()
        serves_pizza = models.BooleanField()

Todos os campos de ``Place`` também estarão disponíveis no ``Restaurant``,
apesar de o dado residir em uma tabela diferente no banco de dados. Então ambos
são possíveis::

    >>> Place.objects.filter(name="Bob's Cafe")
    >>> Restaurant.objects.filter(name="Bob's Cafe")

Se você tem um ``Place`` que também é um ``Restaurant``, você pode obter do
objeto ``Place`` o objeto ``Restaurant`` usando a versão minúscula do nome do
model::

    >>> p = Place.objects.filter(name="Bob's Cafe")
    # Se "Bob's Cafe" é um objeto Restaurant, isto irá retornar uma classe filho:
    >>> p.restaurant
    <Restaurant: ...>

Entretanto, se ``p`` no exemplo acima *não* for um ``Restaurant`` (que havia
sido criado diretamente como um objeto ``Place`` ou foi pai de alguma outra
classe), referir-se a ``p.restaurant`` poderia gerar um erro.

:ref:`Meta <meta-options>` e herança com multi-tabelas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Nesta situação de herança com multi-tabelas, não faz sentido a classe filha
herdar a classe :ref:`Meta <meta-options>` de seus pais. Todas as opções em
:ref:`Meta <meta-options>` já teriam sido aplicadas para a classe e aplicá-las
de novo normalmente levaria a um comportamento contraditório (isto está em
contraste com o caso da classe abstrata de base, onde a classe de base não
existe em seu próprio direito).

Então o modelo filho não tem acesso às classes :ref:`Meta <meta-options>` de seus pais.
Entretanto, existem uns poucos casos limitados onde o filho herda o
comportamento do pai: se o filho não especificar um atributo
:attr:`django.db.models.Options.ordering` ou um atributo
:attr:`django.db.models.Options.get_latest_by`, ele os herdará de seus pais.

Se o pai tem um ordenamento e você não quer que o filho o tenha, você pode
explicitar com uma lista vazia::

    class ChildModel(ParentModel):
        ...
        class Meta:
            # Remove o ordenamento dos pais
            ordering = []

Herança e relações reversas
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Porque a herança com multi-tabelas usa um campo implícito
:class:`~django.db.models.fields.OneToOneField`
para ligar o filho ao pai, é possível mover propriedades do pai para o filho,
como no exemplo acima. Entretanto, isso usa o nome que é o valor padrão
:attr:`~django.db.models.ForeignKey.related_name` para relações
:class:`django.db.models.fields.ForeignKey` e
:class:`django.db.models.fields.ManyToManyField`. Se você está
colocando estes tipos de relações sobre uma subclasse de outro modelo, você
**deve** especificar o atributo
:attr:`~django.db.models.ForeignKey.related_name` em cada campo. Se você
esquecer, o Django gerará um erro quando você rodar o :djadmin:`validate` ou
:djadmin:`syncdb`.

Por exemplo, usando a classe ``Place`` novamente, vamos criar outra subclasse
com um :class:`~django.db.models.fields.ManyToManyField`::

    class Supplier(Place):
        # Você deve especificar o related_name em todas as relações.
        customers = models.ManyToManyField(Restaurant,
                related_name='provider')

Especificando o campo parent_link
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Como mencionado, o Django criará automaticamente um
:class:`~django.db.models.fields.OneToOneField` ligando
sua classe filha com qualquer modelo pai não-abstrato. Se você deseja controlar
o nome dos atributos de ligação, você pode criar sei próprio
:class:`~django.db.models.fields.OneToOneField` e setar
:attr:`parent_link=True <django.db.models.fields.OneToOneField.parent_link>`.
para indicar que seu campo é o link para a classe pai.

Herança múltipla
----------------

Da mesma forma que as subclasses do Python, é possível para um modelo do Django
ter herança de múltiplos modelos pais. Mantenha em mente a aplicação da
resolução normal de nomes do Python. A primeira classe de base em que um nome
particular aparece (ex: :ref:`Meta <meta-options>`) será utilizada. Nós paramos
de procurar assim que encontramos um nome. Isso significa que se os múltiplos
pais possuem uma classe :ref:`Meta <meta-options>`, somente o primeiro será
usado. Todos os outros serão ignorados.

Geralmente você não necessita de herança múltipla. O principal caso de uso
onde isso se torna comum é para classes ''mix-in'': adicionando um campo ou
método extra em particular para cada classe que herdar do mix-in. Tente
manter suas hierarquias o mais simples possível, para que você não trave
batalhas para descobrir de onde vem uma certa informação.

Field name "hiding" is not permitted
-------------------------------------

In normal Python class inheritance, it is permissible for a child class to
override any attribute from the parent class. In Django, this is not permitted
for attributes that are :class:`~django.db.models.fields.Field` instances (at
least, not at the moment). If a base class has a field called ``author``, you
cannot create another model field called ``author`` in any class that inherits
from that base class.

Overriding fields in a parent model leads to difficulties in areas such as
initialising new instances (specifying which field is being intialised in
``Model.__init__``) and serialization. These are features which normal Python
class inheritance doesn't have to deal with in quite the same way, so the
difference between Django model inheritance and Python class inheritance isn't
merely arbitrary.

This restriction only applies to attributes which are
:class:`~django.db.models.fields.Field` instances. Normal Python attributes
can be overridden if you wish. It also only applies to the name of the
attribute as Python sees it: if you are manually specifying the database
column name, you can have the same column name appearing in both a child and
an ancestor model for multi-table inheritance (they are columns in two
different database tables).

Django will raise a ``FieldError`` exception if you override any model field
in any ancestor model.

