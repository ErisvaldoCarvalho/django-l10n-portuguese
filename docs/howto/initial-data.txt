======================================
Provendo dados inicias para os modelos
======================================

As vezes é útil pré popular seu banco de dados com dados pré-definidos quando
você está iniciando sua aplicação pela primeira vez. Existem algumas formas do
Django criar esse dados automaticamente: você pode prover
`dados iniciais usando fixtures`_ , ou pode prover `dados inicias em SQL`_ .

De maneira geral, usar uma fixture é um métodos simples desde que o banco de
dados seja agnóstico, mas dados inicias com SQL podem ser um pouco mais
flexíveis.

.. _dados inicias em SQL: `provendo-dados-inicias-em-sql`_
.. _dados iniciais usando fixtures: `dados-iniciais-usando-fixtures`_

.. _dados-iniciais-usando-fixtures:

Provendo dados iniciais com fixtures
====================================

Uma fixture é uma coleção de dados que o Django sabe como importar para um
banco de dados. O jeito mais simples de criar uma fixture, caso você já tenha
algum dado, é usar o comando :djadmin:`manage.py dumpdata <dumpdata>`.
Ou, você pode escrever fixtures na mão; fixtures podem ser escritas em XML, YAML
ou documento JSON. A :doc:`documentação de serialização </topics/serialization>`
tem mais detalhes sobre cada
:ref:`formatos de serialização <serialization-formats>`.

Como exemplo, aqui está como uma fixture, de um model ``Person`` simples, parece
em JSON:

.. code-block:: js

    [
      {
        "model": "myapp.person",
        "pk": 1,
        "fields": {
          "first_name": "John",
          "last_name": "Lennon"
        }
      },
      {
        "model": "myapp.person",
        "pk": 2,
        "fields": {
          "first_name": "Paul",
          "last_name": "McCartney"
        }
      }
    ]

E aqui está a mesma fixture em YAML:

.. code-block:: none

    - model: myapp.person
      pk: 1
      fields:
        first_name: John
        last_name: Lennon
    - model: myapp.person
      pk: 2
      fields:
        first_name: Paul
        last_name: McCartney

Você deve armazenar esses dados em um diretório chamado ``fixtures`` dentro
da sua aplicação.

Carregar dados é fácil: apenas digite :djadmin:`manage.py loaddata
\<nomedafixture\> <loaddata>`, onde ``<nomedafixture>`` é o nome do arquivo de
fixture que você criou. Cada vez que você executa :djadmin:`loaddata`, os dados
serão lidos apartir da fixture e recarregados para o banco de dados. Note que
isso significa que se você mudar uma das linhas criadas pelo fixture e depois
executar :djadmin:`loaddata` novamente, você perderá qualquer mudança que tenha
você feito.

Carregando automaticamente dados iniciais da fixture
----------------------------------------------------

Se você criar uma fixture chamada ``initial_data.[xml/yaml/json]``, essa fixture
será carregada toda vez que você executar :djadmin:`syncdb`. Isso é extremamente
conveniente, mas você deve ser cuidadoso: Lembre-se que os dados serão
atualizados *toda vez* que você executar :djadmin:`syncdb`. Então não use
``initial_data`` para dados que você possa querer editar.

Onde o Django encontra os arquivos fixture
------------------------------------------

Por padrão, O Django procura nos diretórios ``fixtures`` dentro de cada aplicação
por fixtures. Você pode configurar o :setting:`FIXTURE_DIRS` informando uma lista
de diretórios adicionais onde o Django deve procurar.

Quando estiver executando :djadmin:`manage.py loaddata <loaddata>`, você pode
também especificar um caminho absoluto até o arquivo fixture, o que evita a
procura normal nos diretórios.

.. seealso::

    Fixtures are also used by the :ref:`testing framework
    <topics-testing-fixtures>` to help set up a consistent test environment.

.. _provendo-dados-inicias-em-sql:

Providing initial SQL data
==========================

Django provides a hook for passing the database arbitrary SQL that's executed
just after the CREATE TABLE statements when you run :djadmin:`syncdb`. You can
use this hook to populate default records, or you could also create SQL
functions, views, triggers, etc.

The hook is simple: Django just looks for a file called ``sql/<modelname>.sql``,
in your app directory, where ``<modelname>`` is the model's name in lowercase.

So, if you had a ``Person`` model in an app called ``myapp``, you could add
arbitrary SQL to the file ``sql/person.sql`` inside your ``myapp`` directory.
Here's an example of what the file might contain:

.. code-block:: sql

    INSERT INTO myapp_person (first_name, last_name) VALUES ('John', 'Lennon');
    INSERT INTO myapp_person (first_name, last_name) VALUES ('Paul', 'McCartney');

Each SQL file, if given, is expected to contain valid SQL statements
which will insert the desired data (e.g., properly-formatted
``INSERT`` statements separated by semicolons).

The SQL files are read by the :djadmin:`sqlcustom`, :djadmin:`sqlreset`,
:djadmin:`sqlall` and :djadmin:`reset` commands in :doc:`manage.py
</ref/django-admin>`. Refer to the :doc:`manage.py documentation
</ref/django-admin>` for more information.

Note that if you have multiple SQL data files, there's no guarantee of
the order in which they're executed. The only thing you can assume is
that, by the time your custom data files are executed, all the
database tables already will have been created.

.. admonition:: Initial SQL data and testing

    This technique *cannot* be used to provide initial data for
    testing purposes. Django's test framework flushes the contents of
    the test database after each test; as a result, any data added
    using the custom SQL hook will be lost.

    If you require data for a test case, you should add it using
    either a :ref:`test fixture <topics-testing-fixtures>`, or
    programatically add it during the ``setUp()`` of your test case.

Database-backend-specific SQL data
----------------------------------

There's also a hook for backend-specific SQL data. For example, you
can have separate initial-data files for PostgreSQL and SQLite. For
each app, Django looks for a file called
``<appname>/sql/<modelname>.<backend>.sql``, where ``<appname>`` is
your app directory, ``<modelname>`` is the model's name in lowercase
and ``<backend>`` is the last part of the module name provided for the
:setting:`ENGINE` in your settings file (e.g., if you have defined a
database with an :setting:`ENGINE` value of
``django.db.backends.sqlite3``, Django will look for
``<appname>/sql/<modelname>.sqlite3.sql``).

Backend-specific SQL data is executed before non-backend-specific SQL
data. For example, if your app contains the files ``sql/person.sql``
and ``sql/person.sqlite3.sql`` and you're installing the app on
SQLite, Django will execute the contents of
``sql/person.sqlite.sql`` first, then ``sql/person.sql``.
