======================================
Provendo dados inicias para os modelos
======================================

As vezes é útil pré popular seu banco de dados com dados pré-definidos quando
você está iniciando sua aplicação pela primeira vez. Existem algumas formas do
Django criar esse dados automaticamente: você pode prover
`dados iniciais usando fixtures`_, ou pode prover `dados inicias em SQL`_.

De maneira geral, usar uma fixture é um métodos simples desde que o banco de
dados seja agnóstico, mas dados inicias com SQL podem ser um pouco mais
flexíveis.

.. _dados inicias com sql: `provendo dados inicias em sql`_
.. _dados iniciais usando fixtures: `provendo dados inicias com fixture`_

.. _dados-iniciais-usando-fixtures:

Provendo dados iniciais com fixtures
====================================

Uma fixture é uma coleção de dados que o Django sabe como importar para um
banco de dados. O jeito mais simples de criar uma fixture, caso você já tenha
algum dado, é usar o comando :djadmin:`manage.py dumpdata <dumpdata>`.
Ou, você pode escrever fixtures na mão; fixtures podem ser escritas em XML, YAML
ou documento JSON. A :doc:`documentação de serialização </topics/serialization>`
tem mais detalhes sobre cada
:ref:`formatos de serialização <serialization-formats>`.

As an example, though, here's what a fixture for a simple ``Person`` model might
look like in JSON:

.. code-block:: js

    [
      {
        "model": "myapp.person",
        "pk": 1,
        "fields": {
          "first_name": "John",
          "last_name": "Lennon"
        }
      },
      {
        "model": "myapp.person",
        "pk": 2,
        "fields": {
          "first_name": "Paul",
          "last_name": "McCartney"
        }
      }
    ]

And here's that same fixture as YAML:

.. code-block:: none

    - model: myapp.person
      pk: 1
      fields:
        first_name: John
        last_name: Lennon
    - model: myapp.person
      pk: 2
      fields:
        first_name: Paul
        last_name: McCartney

You'll store this data in a ``fixtures`` directory inside your app.

Loading data is easy: just call :djadmin:`manage.py loaddata <fixturename>
<loaddata>`, where ``<fixturename>`` is the name of the fixture file you've
created. Each time you run :djadmin:`loaddata`, the data will be read from the
fixture and re-loaded into the database. Note this means that if you change one
of the rows created by a fixture and then run :djadmin:`loaddata` again, you'll
wipe out any changes you've made.

Automatically loading initial data fixtures
-------------------------------------------

If you create a fixture named ``initial_data.[xml/yaml/json]``, that fixture will
be loaded every time you run :djadmin:`syncdb`. This is extremely convenient,
but be careful: remember that the data will be refreshed *every time* you run
:djadmin:`syncdb`. So don't use ``initial_data`` for data you'll want to edit.

Where Django finds fixture files
--------------------------------

By default, Django looks in the ``fixtures`` directory inside each app for
fixtures. You can set the :setting:`FIXTURE_DIRS` setting to a list of
additional directories where Django should look.

When running :djadmin:`manage.py loaddata <loaddata>`, you can also
specify an absolute path to a fixture file, which overrides searching
the usual directories.

.. seealso::

    Fixtures are also used by the :ref:`testing framework
    <topics-testing-fixtures>` to help set up a consistent test environment.

.. _initial-sql:

Providing initial SQL data
==========================

Django provides a hook for passing the database arbitrary SQL that's executed
just after the CREATE TABLE statements when you run :djadmin:`syncdb`. You can
use this hook to populate default records, or you could also create SQL
functions, views, triggers, etc.

The hook is simple: Django just looks for a file called ``sql/<modelname>.sql``,
in your app directory, where ``<modelname>`` is the model's name in lowercase.

So, if you had a ``Person`` model in an app called ``myapp``, you could add
arbitrary SQL to the file ``sql/person.sql`` inside your ``myapp`` directory.
Here's an example of what the file might contain:

.. code-block:: sql

    INSERT INTO myapp_person (first_name, last_name) VALUES ('John', 'Lennon');
    INSERT INTO myapp_person (first_name, last_name) VALUES ('Paul', 'McCartney');

Each SQL file, if given, is expected to contain valid SQL statements
which will insert the desired data (e.g., properly-formatted
``INSERT`` statements separated by semicolons).

The SQL files are read by the :djadmin:`sqlcustom`, :djadmin:`sqlreset`,
:djadmin:`sqlall` and :djadmin:`reset` commands in :doc:`manage.py
</ref/django-admin>`. Refer to the :doc:`manage.py documentation
</ref/django-admin>` for more information.

Note that if you have multiple SQL data files, there's no guarantee of
the order in which they're executed. The only thing you can assume is
that, by the time your custom data files are executed, all the
database tables already will have been created.

.. admonition:: Initial SQL data and testing

    This technique *cannot* be used to provide initial data for
    testing purposes. Django's test framework flushes the contents of
    the test database after each test; as a result, any data added
    using the custom SQL hook will be lost.

    If you require data for a test case, you should add it using
    either a :ref:`test fixture <topics-testing-fixtures>`, or
    programatically add it during the ``setUp()`` of your test case.

Database-backend-specific SQL data
----------------------------------

There's also a hook for backend-specific SQL data. For example, you
can have separate initial-data files for PostgreSQL and SQLite. For
each app, Django looks for a file called
``<appname>/sql/<modelname>.<backend>.sql``, where ``<appname>`` is
your app directory, ``<modelname>`` is the model's name in lowercase
and ``<backend>`` is the last part of the module name provided for the
:setting:`ENGINE` in your settings file (e.g., if you have defined a
database with an :setting:`ENGINE` value of
``django.db.backends.sqlite3``, Django will look for
``<appname>/sql/<modelname>.sqlite3.sql``).

Backend-specific SQL data is executed before non-backend-specific SQL
data. For example, if your app contains the files ``sql/person.sql``
and ``sql/person.sqlite3.sql`` and you're installing the app on
SQLite, Django will execute the contents of
``sql/person.sqlite.sql`` first, then ``sql/person.sql``.
