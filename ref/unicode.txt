..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11332 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _ref-unicode:

=======================
Dados Unicode no Django
=======================

.. versionadded:: 1.0

O Django nativamente suporta dados Unicode por toda parte. Proporcionando ao seu
banco de dados uma forma de armazenar os dados, e dando-lhe a segurança de
passar strings Unicode aos templates, models e pro banco de dados.

Este documento lhe conta o que você precisa saber se você estiver escrevendo
aplicações que usam dados ou templates que estão codificados em algum outro
formato ASCII.

Criando o banco de dados
========================

Esteja certo que seu banco de dados está configurado para armazenar strings
arbitrárias. Normalmente, isto significa tê-las numa codificação UTF-8 ou
UTF-16. Se você usa mais de uma codificação restritiva -- por exemplo, latin1
(iso8859-1) -- você não poderá armazenar certos caracteres no banco de dados,
e informações serão perdidas.

 * Usuários do MySQL, consultem o `manual do MySQL`_ (seção 10.3.2 para MySQL
   5.1) para detalhes sobre como setar ou alterar a codificação do banco de
   dados.
 * Usuários de PostgreSQL, consultem o `manual do PostgreSQL`_ (seção 21.2.2 no
   PostgresSQL 8) para detalhes sobre criar bancos de dados com a codificação
   correta.
 * Usuários de SQLite, não há nada que você precise fazer. O SQLite sepre usa o
   UTF-8 para codificação interna.

.. _manual do MySQL: http://www.mysql.org/doc/refman/5.1/en/charset-database.html
.. _manual do PostgreSQL: http://www.postgresql.org/docs/8.2/static/multibyte.html#AEN24104

Todos os backends de banco de dados do Django automaticamente covertem strings
Unicode para o formato apropriado do banco de dados. Eles também convertem
automaticamente strings recebidas de bancos de dados em strings Unicode do
Python. Você não precisa dizer ao Django qual codificação seu banco de dados
usa: isso é manipulado transparentemente.

Par mais, veja a seção "API de banco de dados" abaixo.

Manipulação genérica de string
==============================

Sempre que você usa strings com o Django -- e.g., no banco de dados,
renderização de templates ou algo mais -- você tem duas escolhas de codificação
de strings. Você pode usar strings Unicode, ou vocÊ pode usar strings normais (
algumas chamadas "bytestrings") que são codificadas usando UTF-8.

.. admonition:: Warning

    Uma bytestring não carrega qualquer informação com ela sobre sua
    codificação. Por esta razão, nós temos que fazer uma suposição, e o Django
    assume que toda bytestring é UTF-8.

    Se você passar uma string para o Django que já foi codificada em algum outro
    formato, as coisas podem ir por um caminho errado e de formas interessantes.
    Normalmente, o Django lançará um erro ``UnicodeDecodeError`` neste ponto.

Se seu código somente usa dados ASCII, ele é seguro para usar strings normais,
passando-as a vontade, porque o ASCII é sub-conjunto do UTF-8.

Não se engane em pensar que se sua configuração :setting:`DEFAULT_CHARSET` é
qualquer coisa diferente de ``'utf-8'`` que você pode usar nas suas bytestrings!
:setting:`DEFAULT_CHARSET` somente se aplica a strings geradas como resultado de
renderização de templates (e e-mail). O Django sempre assumirá a codificação
UTF-8 para bytestrings internas. A razão disso é que na verdade a configuração
:setting:`DEFAULT_CHARSET` não está sob seu controle (se você é um desenvolvedor
de aplicações). Está sob controle da pessoa que instala e usa sua aplicação --
e se essa pessoa escolher uma configuração diferente, seu código pode ainda
continuar funcionando. Portanto, ela não pode contar com essa configuração.

Na maioria dos casos quando o Django está lidando com strings, ele as converterá
para Unicode antes de fazer algo mais. Então, como uma regra geral, se você
passa uma bytestring, esteja preparado para receber uma string Unicode de volta
no resultado.

Strings traduzidas
------------------

Além das string Unicode e bytestrings, há um terceiro tipo de objeto do tipo
string que você pode encontrar enquanto usa o Django. As funcionalidades do
framework de internacionalização introduzem o conceito de uma "tradução
lazy" -- uma string que foi marcada como traduzida mas cujo resultado atual da
tradução não é determinado até que o objeto seja utilizado numa string. Esta
funcionalidade é útil em casos onde a localização da tradução é desconhecida até
que a string seja usada, mesmo pensando que a string possa ter sigo
originalmente criada quando o código foi importado pela primeira vez.

Normalmente, você não terá de se preocupar com traduções lazy. Somente esteja
alerta que se você examinar um objeto e ele afirma ser um objeto
``django.utils.functional.__proxy__``, ele é uma tradução lazy. Chamando
``unicode()`` com a tradução lazy como argumento gerará uma string Unicode na
localização atual.

Para mais detalhes sobre traduções tardias de objetos, leia a documentação de
:ref:`internacionalização <topics-i18n>`.

Utilitário de funções úteis
---------------------------

Por algumas operações de string serem muito repetitivas, o Django vem
acompanhado de funções úteis que devem fazer o trabalho com objetos Unicode e
bytestring ficar um pouco mais fácil.

Fuções de conversão
~~~~~~~~~~~~~~~~~~~

O módulo ``django.utils.encoding`` contém algumas funções que são capazes de
realizar conversões entre strings Unicode e bytestrings.

    * ``smart_unicode(s, encoding='utf-8', strings_only=False, errors='strict')``
      converte sua entrada para uma string Unicode. O parametro ``encoding``
      especifica a codificação da entrada. (Por exemplo, o Django usa isso
      internamente quando processa dados de formulários, que podem não ter
      codificação UTF-8.) O parametro ``strings_only ``, se setado como True,
      resultará em números Python, booleanos e ``None`` sem conversão para uma
      string (eles mantêm seus tipos originais). O parametro ``errors`` recebe
      qualquer um dos valores que são aceitos pela função ``unicode()`` do
      Python para sua manipulação de erros.

      Se você passar ao ``smart_unicode()`` um objeto que tem um método
      ``__unicode__``, ele usará este método para fazer a conversão.

    * ``force_unicode(s, encoding='utf-8', strings_only=False,
      errors='strict')`` é identico ao ``smart_unicode()`` em quase todos os
      casos. A diferença é quando o primeiro argumento é uma instância de
      :ref:`tradução lazy <lazy-translations>`. Enquanto ``smart_unicode()``
      preserva a tradução tardia, ``force_unicode()`` força estes objetos a
      serem strings Unicode (causando a ocorrência da tradução). Normalmente,
      você desejará usar ``smart_unicode()``. Entretanto, ``force_unicode()`` é
      útil em template tags e filtros que *devem* ter absolutamente uma string
      para trabalhar com, não algo que pode ser convertido numa string.

    * ``smart_str(s, encoding='utf-8', strings_only=False, errors='strict')``
      é essencialmente o oposto de ``smart_unicode()``. Ele força o primeiro
      argumento a ser uma bytestring. O parametro ``strings_only`` tem o mesmo
      comportamento que do ``smart_unicode()`` e ``force_unicode()``. Essa é uma
      semântica ligeiramente diferente da função nativa do Python ``str()``,
      mas a diferença é necessária em alguns poucos lugares internos do Django.


Normalmente, você somente precisará usar ``smart_unicode()``. Chamando-o tão
cedo quanto possível sobre qualquer entrada de dados que podem ser Unicode ou
bytestring, e a partir de então, você pode tratar os resultados como sempre faz
com Unicode.

Manipulação de URI e IRI
~~~~~~~~~~~~~~~~~~~~~~~~

Web frameworks have to deal with URLs (which are a type of IRI_). One
requirement of URLs is that they are encoded using only ASCII characters.
However, in an international environment, you might need to construct a
URL from an IRI_ -- very loosely speaking, a URI that can contain Unicode
characters. Quoting and converting an IRI to URI can be a little tricky, so
Django provides some assistance.

    * The function ``django.utils.encoding.iri_to_uri()`` implements the
      conversion from IRI to URI as required by the specification (`RFC
      3987`_).

    * The functions ``django.utils.http.urlquote()`` and
      ``django.utils.http.urlquote_plus()`` are versions of Python's standard
      ``urllib.quote()`` and ``urllib.quote_plus()`` that work with non-ASCII
      characters. (The data is converted to UTF-8 prior to encoding.)

These two groups of functions have slightly different purposes, and it's
important to keep them straight. Normally, you would use ``urlquote()`` on the
individual portions of the IRI or URI path so that any reserved characters
such as '&' or '%' are correctly encoded. Then, you apply ``iri_to_uri()`` to
the full IRI and it converts any non-ASCII characters to the correct encoded
values.

.. note::
    Technically, it isn't correct to say that ``iri_to_uri()`` implements the
    full algorithm in the IRI specification. It doesn't (yet) perform the
    international domain name encoding portion of the algorithm.

The ``iri_to_uri()`` function will not change ASCII characters that are
otherwise permitted in a URL. So, for example, the character '%' is not
further encoded when passed to ``iri_to_uri()``. This means you can pass a
full URL to this function and it will not mess up the query string or anything
like that.

An example might clarify things here::

    >>> urlquote(u'Paris & Orléans')
    u'Paris%20%26%20Orl%C3%A9ans'
    >>> iri_to_uri(u'/favorites/François/%s' % urlquote(u'Paris & Orléans'))
    '/favorites/Fran%C3%A7ois/Paris%20%26%20Orl%C3%A9ans'

If you look carefully, you can see that the portion that was generated by
``urlquote()`` in the second example was not double-quoted when passed to
``iri_to_uri()``. This is a very important and useful feature. It means that
you can construct your IRI without worrying about whether it contains
non-ASCII characters and then, right at the end, call ``iri_to_uri()`` on the
result.

The ``iri_to_uri()`` function is also idempotent, which means the following is
always true::

    iri_to_uri(iri_to_uri(some_string)) = iri_to_uri(some_string)

So you can safely call it multiple times on the same IRI without risking
double-quoting problems.

.. _URI: http://www.ietf.org/rfc/rfc2396.txt
.. _IRI: http://www.ietf.org/rfc/rfc3987.txt
.. _RFC 3987: IRI_

Models
======

Because all strings are returned from the database as Unicode strings, model
fields that are character based (CharField, TextField, URLField, etc) will
contain Unicode values when Django retrieves data from the database. This
is *always* the case, even if the data could fit into an ASCII bytestring.

You can pass in bytestrings when creating a model or populating a field, and
Django will convert it to Unicode when it needs to.

Choosing between ``__str__()`` and ``__unicode__()``
----------------------------------------------------

One consequence of using Unicode by default is that you have to take some care
when printing data from the model.

In particular, rather than giving your model a ``__str__()`` method, we
recommended you implement a ``__unicode__()`` method. In the ``__unicode__()``
method, you can quite safely return the values of all your fields without
having to worry about whether they fit into a bytestring or not. (The way
Python works, the result of ``__str__()`` is *always* a bytestring, even if you
accidentally try to return a Unicode object).

You can still create a ``__str__()`` method on your models if you want, of
course, but you shouldn't need to do this unless you have a good reason.
Django's ``Model`` base class automatically provides a ``__str__()``
implementation that calls ``__unicode__()`` and encodes the result into UTF-8.
This means you'll normally only need to implement a ``__unicode__()`` method
and let Django handle the coercion to a bytestring when required.

Taking care in ``get_absolute_url()``
-------------------------------------

URLs can only contain ASCII characters. If you're constructing a URL from
pieces of data that might be non-ASCII, be careful to encode the results in a
way that is suitable for a URL. The ``django.db.models.permalink()`` decorator
handles this for you automatically.

If you're constructing a URL manually (i.e., *not* using the ``permalink()``
decorator), you'll need to take care of the encoding yourself. In this case,
use the ``iri_to_uri()`` and ``urlquote()`` functions that were documented
above_. For example::

    from django.utils.encoding import iri_to_uri
    from django.utils.http import urlquote

    def get_absolute_url(self):
        url = u'/person/%s/?x=0&y=0' % urlquote(self.location)
        return iri_to_uri(url)

This function returns a correctly encoded URL even if ``self.location`` is
something like "Jack visited Paris & Orléans". (In fact, the ``iri_to_uri()``
call isn't strictly necessary in the above example, because all the
non-ASCII characters would have been removed in quoting in the first line.)

.. _above: `Manipulação de URI e IRI`_

A API de banco de dados
=======================

Você pode passar tanto strings Unicode ou bytestrings UTF-8 como argumentos para
os métodos ``filter()`` e seus semelhantes da API de banco de dados. Os dois
querysets a seguir são identicos::

    qs = People.objects.filter(name__contains=u'Å')
    qs = People.objects.filter(name__contains='\xc3\x85') # Codificação UTF-8 de Å

Templates
=========

Você pode usar tanto Unicode quanto bytestrings quando criar templates
manualmente::

	from django.template import Template
	t1 = Template('This is a bytestring template.')
	t2 = Template(u'This is a Unicode template.')

Porém o caso mais comum é ler os templates do sistema de arquivos, e isso gera
uma ligeira complicação: nem todos os sistemas de arquivos armazenam seus dados
codificados em UTF-8. Se seus arquivos de template não são armazenados com
codificação UTF-8, configure o :setting:`FILE_CHARSET` para codificar os
arquivos no disco. Quando o Django lê um arquivo de template, ele converterá
os dados dele para Unicode. (:setting:`FILE_CHARSET` é configurado como
``'utf-8'`` por padrão.)

A configuração :setting:`DEFAULT_CHARSET` controla a codificação de templates
renderizados. Isto é configurado como UTF-8 por padrão.

Template tags e filtros
-----------------------

Algumas dicas para se lembrar quando escrever suas próprias template tags e
filtros:

    * Sempre retorne strings Unicode de um método render de uma template tag e
      de um filtro.

    * Use ``force_unicode()`` de preferência, ao invés de ``smart_unicode()``
      nestes lugares. As chamadas de renderização de tags e filtros ocorrem
      quando o template estiver em renderização, assim não há vantagem em adiar
      a conversão de objetos de traduções lazy. É mais fácil trabalhar
      unicamente com strings Unicode neste ponto.

E-mail
======

O framework de email do Django (em ``django.core.mail``) suporta Unicode
transparentemente. Você pode usar dados Unicode no corpo das mensagens e
qualquer cabeçalho. Entretanto, você ainda será obrigado a respeitar os
requerimentos das especificações do e-mail, desta forma, por exemplo, endereços
de e-mail devem usar somente caracteres ASCII.

O seguinte código de exemplo demonstra que tudo, exceto endereços de e-mail,
podem ser não ASCII::

    from django.core.mail import EmailMessage

    subject = u'My visit to Sør-Trøndelag'
    sender = u'Arnbjörg Ráðormsdóttir <arnbjorg@example.com>'
    recipients = ['Fred <fred@example.com']
    body = u'...'
    EmailMessage(subject, body, sender, recipients).send()

Submissão de formulários
========================

Submissão de formulários HTML é uma área complicada. Não há garantias de que a
submissão incluirá informações de codificação, o que significa que o framework
pode ter de advinhar a codificação dos dados submetidos.

O Django adota uma abordagem "lazy" para decodificar dados de formulário. Os
dados num objeto ``HttpRequest`` é somente decodificado quando você o acessa. De
fato, a maior parte dos dados não é decodificada. Somente as estruturas de dados
``HttpRequest.GET`` e ``HttpRequest.POST`` tem qualquer decodificação aplicada
nelas. Estes dois campos retornar]ao seus membros como dados Unicode. Todos os
outros atributos e método do ``HttpRequest`` retornam exatamente o dado como
foi submetido pelo cliente.

Por padrão, a configuração :setting:`DEFAULT_CHARSET` é usada como a codificação
assumida pelos dados do formulário. Se você precisa mudar isso para um
formulário particular, você pode configurar o atributo ``encoding`` de uma
instância ``HttpRequest``. Por exemplo::

    def some_view(request):
        # Nós sabemos que os dados devem ser codificados como KOI8-R
        # (por alguma razão).
        request.encoding = 'koi8-r'
        ...

Você ainda pode mudar a codificação depois de accessado o ``request.GET`` ou
``request.POST``, e todos os acessos subsequentes usarão a nova codificação.

A maioria dos desenvolvedores não precisam se preocupar em mudar a codificação
de um formulário, mas essa é uma funcionalidade útil quando falamos de sistemas
legadas cuja codificação você não pode controlar.

O django não codifica dados de arquivos de upload, pois esses dados são
normalmente tratados como coleções de bytes, ao invés de strings. Qualquer
decodificação automática não alteraria o sentido do fluxo de bytes.

