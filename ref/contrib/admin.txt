..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11268 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _ref-contrib-admin:

======================
O site admin do Django
======================

.. module:: django.contrib.admin
   :synopsis: O site de administração do Django.

.. currentmodule:: django.contrib.admin

Uma das mais poderosas partes do Django é a inteface de administração
automática. Ela lê os metadados de seu model para fornecer uma inteface poderosa
e pronta para produção que produtores de conteúdo podem imediatamente usar para
começar a adicionar conteúdos ao site. Neste documento, nós discutimos como
ativar, usar e personalizar a interface de administração do Django.

.. admonition:: Nota

    O site admin foi significantemente refatorado desde a versão 0.96. Este
    documento descreve a versão mais nova do site admin, que permite
    customizações mais ricas. Se você acompanha o desenvolvimento do Django em
    si, você pode ter ouvido isso descrito como "newforms-admin."

Visão geral
===========

Há cinco passos para ativar o site admin do Django:

    1. Adicione ``django.contrib.admin`` no seu ``INSTALLED_APPS``.

    2. Determine quais models de aplicações devem ser editados pela interface
       admin.

    3. Para cada um destes models, opicionalmente, crie uma classe
       ``ModelAdmin`` que encapsula as funcionalidades customizadas do admin e
       opções para este model particular.

    4. Instancie um ``AdminSite`` e o informe sobre cada um de seus models e
       classes ``ModelAdmin``.

    5. Ligue a instância ``AdminSite`` ao seu URLconf.

.. seealso::

    Para informações sobre como servir arquivos de mídia (imagens, JavaScript, e
    CSS) associado ao admin em produção, veja :ref:`serving-media-files`.

Objetos ``ModelAdmin``
======================

.. class:: ModelAdmin

A classe ``ModelAdmin`` é a representação de um model na interface de
administração. Este são armazenados num arquivo chamado ``admin.py`` na sua
aplicação. Vamos dar uma olhada num exemplo muito simples de ``ModelAdmin``::

    from django.contrib import admin
    from myproject.myapp.models import Author

    class AuthorAdmin(admin.ModelAdmin):
        pass
    admin.site.register(Author, AuthorAdmin)

.. admonition:: Você precisa de um objeto ``ModelAdmin`` sempre?

    No exemplo anterior, a classe ``ModelAdmin`` não define quaisquer valores
    personalizados (ainda). Como um resultado, a interface admin padrão será
    fornecida. Se você estiver feliz com a interface admin padrão, você não
    precisa definir um objeto ``ModelAdmin`` sempre -- você poder registrar a
    classe model sem fornecer uma descrição do ``ModelAdmin``. O exemplo
    anterior poderia ser simplicado para::

        from django.contrib import admin
        from myproject.myapp.models import Author

        admin.site.register(Author)

Opções ``ModelAdmin``
---------------------

O ``ModelAdmin`` é muito flexível. Ele tem várias opções para lidar com
customização da interface. Todas as opções são definidas na subclasse
``ModelAdmin``::

    class AuthorAdmin(admin.ModelAdmin):
        date_hierarchy = 'pub_date'

.. attribute:: ModelAdmin.date_hierarchy

Sete o ``date_hierarchy`` com o nome de um ``DateField`` ou ``DateTimeField`` do
seu model, e a lista de dados incluirá uma navegação por data, utilizando o
campo informado.

Exemplo::

    date_hierarchy = 'pub_date'

.. attribute:: ModelAdmin.form

Por padrão um ``ModelForm`` é dinamicamente criado para seu model. Ele é usado
para criar o formulário apresentado em ambas as páginas adicionar/editar. Você
pode facilmente fornecer seu próprio ``ModelForm`` para sobrescrever qualquer
comportamento de formulário nas páginas adicionar/editar.

Para um exemplo veja a seção `Adicionando validação personalizada ao admin`_.

.. attribute:: ModelAdmin.fieldsets

Sete ``fieldsets`` para controlar o layout das páginas "adicionar" e "editar" do
admin.

``fieldsets`` é uma lista de tuplas duplas, em que cada tupla dupla representa
um ``<fieldset>`` sobre a página de formulário do admin. (Um ``<fieldset>`` é
uma "seção" do formulário.)

As tuplas duplas estão no formato ``(name, field_options)``, onde ``name`` é uma
string representando o título do fieldset e ``field_options`` é um dicionário
com informações sobre o fieldset, incluíndo uma lista de campos para serem
mostrados nele.

Um exemplo completo, recebido do model ``django.contrib.flatpages.FlatPage``::

    class FlatPageAdmin(admin.ModelAdmin):
        fieldsets = (
            (None, {
                'fields': ('url', 'title', 'content', 'sites')
            }),
            ('Advanced options', {
                'classes': ('collapse',),
                'fields': ('enable_comments', 'registration_required', 'template_name')
            }),
        )

Isso resulta numa página admin que parece com:

    .. image:: _images/flatfiles_admin.png

Se o ``fieldsets`` não for fornecido, o Django mostrará o padrão de cada campo
que não for um ``AutoField`` e tenha um ``editable=True``, em um fieldset único,
na mesma ordem em que os campos foram definidos no model.

O dicionário ``field_optinos`` pode ter as seguintes chaves:

    * ``fields``
        Uma tupla com nomes de campos que serão mostrados no fieldset. Esta
        chave é obrigatória.

        Exemplo::

            {
            'fields': ('first_name', 'last_name', 'address', 'city', 'state'),
            }

        Para mostrar vários campos na mesma linha, envolva-os em suas próprias
        tuplas. Neste exemplo, os campos ``first_name`` e ``last_name`` serão
        mostrados na mesma linha::

            {
            'fields': (('first_name', 'last_name'), 'address', 'city', 'state'),
            }

    * ``classes``
        Uma lista contendo classes extra de CSS para serem aplicadas ao
        fieldset.

        Exemplo::

            {
            'classes': ['wide', 'extrapretty'],
            }

        Duas classes úteis definidas por padrão no site admin são ``collapse``
        e ``wide``. Os fieldsets com o estilo ``collapse`` serão inicialmente
        encolhidos no admin e substituídos por um link "click para expandir".
        Os fieldsets com o estilo ``wide`` ocuparão um espaço horizontal extra.

    * ``description``
        Uma string de texto opcional extra para ser mostrado no topo de cada
        fieldset, abaixo do cabeçalho do fieldset.

        Note que este valor *não* tem o HTML escapado quando é mostrado na
        interface do admin. Isso permite você incluir HTML se assim desejar.
        Aleternativamente você poder usar texto plano e
        ``django.utils.html.escape()`` para escapar quaisquer caracteres
        especiais de HTML.

.. attribute:: ModelAdmin.fields

Use esta opção como uma alternativa ao ``fieldsets`` se o layout não importar
e se você deseja somente mostrar um sub-conjunto de campos disponíveis no
formulário. Por exemplo, você poderia definir uma versão mais simples do
formulário do admin para o model ``django.contrib.flatpages.FlatPage`` desta
forma::

    class FlatPageAdmin(admin.ModelAdmin):
        fields = ('url', 'title', 'content')

No exemplo acima, somente os campos 'url', 'title' e 'content' serão mostrados,
sequencialmente, no formulário.

.. admonition:: Nota

    Estas opções ``fields`` não devem ser confundidas com a chave de dicionário
    ``fields`` que fica dentro da opção ``fieldsets``, como descrito na seção
    anterior.

.. attribute:: ModelAdmin.exclude

Este atributo, se fornecido, deve ser uma lista com nomes de campos a se escluir
do formulário.

Por exemplo, vamos considerar o seguinte model::

    class Author(models.Model):
        name = models.CharField(max_length=100)
        title = models.CharField(max_length=3)
        birth_date = models.DateField(blank=True, null=True)

Se você deseja um formulário do model ``Author`` que inclui somente os campos
``name`` e ``title``, você poderia especificar ``fields`` ou ``exclude`` desta
forma::

    class AuthorAdmin(admin.ModelAdmin):
        fields = ('name', 'title')

    class AuthorAdmin(admin.ModelAdmin):
        exclude = ('birth_date',)

Assim o model Author somente terá três campos, ``name``, ``title``, e
``birth_date``, os formulários resultantes das declarações acima conterão
extamante os mesmos campos.

.. attribute:: ModelAdmin.filter_horizontal

Use a nifty unobtrusive JavaScript "filter" interface instead of the
usability-challenged ``<select multiple>`` in the admin form. The value is a
list of fields that should be displayed as a horizontal filter interface. See
``filter_vertical`` to use a vertical interface.

.. attribute:: ModelAdmin.filter_vertical

O mesmo que ``filter_horizontal``, mas é um display vertical do filtro.

.. attribute:: ModelAdmin.list_display

Configure o ``list_display`` para controlar quais campos são mostrados na
listagem do admin.

Exemplo::

    list_display = ('first_name', 'last_name')

Se você não seta ``list_display``, o site admin mostrará uma única coluna que
mostra o ``__unicode__()`` representando cada objeto.

Você tem quatro valores possível que podem ser usado no ``list_display``:

    * Uma campo de model. Por exemplo::

          class PersonAdmin(admin.ModelAdmin):
              list_display = ('first_name', 'last_name')

    * Uma função que aceita um paramêtro para a instância do model. Por
      exemplo::

          def upper_case_name(obj):
              return ("%s %s" % (obj.first_name, obj.last_name)).upper()
          upper_case_name.short_description = 'Name'

          class PersonAdmin(admin.ModelAdmin):
              list_display = (upper_case_name,)

    * Uma string representando um atributo no ``ModelAdmin``. Este se comporta
      da mesma forma que a função acima. Por exemplo::

          class PersonAdmin(admin.ModelAdmin):
              list_display = ('upper_case_name',)

              def upper_case_name(self, obj):
                return ("%s %s" % (obj.first_name, obj.last_name)).upper()
              upper_case_name.short_description = 'Name'

    * Uma string representando um atributo no model. Este se comporta quase como
      a função acima, a diferença é que o ``self`` neste contexto é a instância
      do model. Aqui temos um exemplo completo::

          class Person(models.Model):
              name = models.CharField(max_length=50)
              birthday = models.DateField()

              def decade_born_in(self):
                  return self.birthday.strftime('%Y')[:3] + "0's"
              decade_born_in.short_description = 'Birth decade'

          class PersonAdmin(admin.ModelAdmin):
              list_display = ('name', 'decade_born_in')

Uns poucos casos especiais para se tomar nota sobre o ``list_display``::

    * Se o campo é um ``ForeignKey``, o Django mostrará o ``__unicode`__()`` do
      objeto relacionado.

    * Campos ``ManyToManyField`` não são suportados, pois poderiam implicar em
    execução de consultas SQL em separado pra cada linha da tabela. Se você
    deseja fazer isso de qualquer forma, dê ao seu model um método
    personalizado, e adicione o nome desse método no ``list_display``. (Veja
    abaixo para saber mais sobre métodos personalizados no ``list_display``.)

    * Se o campo é um ``BooleanField`` ou ``NullBooleanField``, o Django
      mostrará um belo ícone "on" ou "off" ao invés de ``True`` ou ``False``.

    * Se a string fornecida é um método do model, ``ModelAdmin`` ou uma função,
      o Django espacará o HTML da saída por padrão. Se você gostaria de não
      escapar a saída do método, de ao método um atributo ``allow_tags`` cujo o
      valor é ``True``.

      Aqui temos um exemplo completo::

          class Person(models.Model):
              first_name = models.CharField(max_length=50)
              last_name = models.CharField(max_length=50)
              color_code = models.CharField(max_length=6)

              def colored_name(self):
                  return '<span style="color: #%s;">%s %s</span>' % (self.color_code, self.first_name, self.last_name)
              colored_name.allow_tags = True

          class PersonAdmin(admin.ModelAdmin):
              list_display = ('first_name', 'last_name', 'colored_name')

    * Se a string dada é um método do model, ``ModelAdmin`` ou uma função que
      retorna True ou False o Django mostrará um belo ícone "on" ou "off" se
      você der ao método um atributo ``boolean`` cujo o valor é ``True``.

      Aqui temos um exemplo completo do model::

          class Person(models.Model):
              first_name = models.CharField(max_length=50)
              birthday = models.DateField()

              def born_in_fifties(self):
                  return self.birthday.strftime('%Y')[:3] == '195'
              born_in_fifties.boolean = True

          class PersonAdmin(admin.ModelAdmin):
              list_display = ('name', 'born_in_fifties')

    * Os métodos ``__str__()`` e ``__unicode__()`` não só são válidos no
      ``list_display`` como em qualquer outro método de model, então é
      perfeitamente OK usar isso::

          list_display = ('__unicode__', 'some_other_field')

    * Normalmente, os elementos do ``list_display`` que não estão dentre os
      campos do bancos de dados atual não podem ser usado em ordenamentos (pois
      o Django não sabe como sortealos a nível de banco de dados).

      Entretanto, se um elemento de um ``list_display`` representa um certo
      campo do banco de dados, você pode indicar este fato configurando o
      atributo ``admin_order_field`` do item.

      Por exemplo::

        class Person(models.Model):
            first_name = models.CharField(max_length=50)
            color_code = models.CharField(max_length=6)

            def colored_first_name(self):
                return '<span style="color: #%s;">%s</span>' % (self.color_code, self.first_name)
            colored_first_name.allow_tags = True
            colored_first_name.admin_order_field = 'first_name'

        class PersonAdmin(admin.ModelAdmin):
            list_display = ('first_name', 'colored_first_name')

      O exemplo acima dirá ao Django para ordenar o campo ``first_name`` quando
      tentar sortear pelo ``colored_first_name`` no admin.

.. attribute:: ModelAdmin.list_display_links

Seta um ``list_display_links`` para controlar quais campos no ``list_display``
deveriam ser linkados à página de edição de um objeto.

Por padrão, a página de listagem linkará a primeira coluna -- o primeiro campo
especificado no ``list_display`` -- para a página de edição de cada item. Mas
``list_display_links`` permite você mudar quais colunas serão linkadas.
Configure ``list_display_links`` com uma lista de tuplas com nomes de campos (no
mesmo formato como ``list_display``) para linkar.

O ``list_display_links`` pode especificar um ou mais nomes de campos. Tantos
quanto os nomes dos campos que aparecerem no ``list_display``, o Django não se
preocupa com quantos campos (ou quão poucos) serão linkados. O único requisito
é: Se você usar ``list_display_links``, você deve definir ``list_display``.

Neste exemplo, os campos ``first_name`` e ``last_name`` serão linkados na página
de listagem::

    class PersonAdmin(admin.ModelAdmin):
        list_display = ('first_name', 'last_name', 'birthday')
        list_display_links = ('first_name', 'last_name')

.. attribute:: ModelAdmin.list_filter

Configure o ``list_filter`` para ativar os filtros na barra à direita da
listagem do admin. Este deve ser uma lista de nomes de campos, e cada campo
especificado devem ser ``BooleanField``, ``CharField``, ``DateField``,
``DateTimeField``, ``IntegerField`` ou ``ForeignKey``.

Este exemplo, pêgo do model ``django.contrib.auth.models.User``, mostra como
ambos ``list_display`` e ``list_filter`` funcionam::

    class UserAdmin(admin.ModelAdmin):
        list_display = ('username', 'email', 'first_name', 'last_name', 'is_staff')
        list_filter = ('is_staff', 'is_superuser')

O código acima resulta numa página de listagem do admim que parece com este:

    .. image:: _images/users_changelist.png

(Este exemplo tem um ``search_fields`` definido. Veja abaixo.)

.. attribute:: ModelAdmin.list_per_page

Configure o ``list_per_page`` para controlar quantos ítens devem aparecer em
cada página da paginação da listagem. Por padrão, é setado para ``100``.

.. attribute:: ModelAdmin.list_select_related

Configure ``list_select_related`` para dizer ao Django para usar
``select_related()`` na lista de objetos recebida na listagem do admin. Isso
pode poupar um monte de consultas no banco de dados.

O valor deve ser ``True`` ou ``False``. O padrão é ``False``.

Note que o Django usará ``select_related()``, indiferente desta configuração,
se um dos campos no ``list_display`` for um ``ForeignKey``.

Para mais sobre ``select_related()``, veja
:ref:`a documentação do select_related() <select-related>`.

.. attribute:: ModelAdmin.inlines

Veja objetos ``InlineModelAdmin`` abaixo.

.. attribute:: ModelAdmin.ordering

Configure ``ordering`` para especificar como os objetos na listagem do admin
devem ser ordenados. Este deve ser uma lista de tuplas no mesmo formato do
parâmetro ``ordering`` do model.

Se este não for fornecido, o Django admin usará o ordenamento padrão do model.

.. admonition:: Nota

    O Django somente honra o primeiro elemento na lista/tupla; qualquer outro
    será ignorado.

.. attribute:: ModelAdmin.prepopulated_fields

Configure ``prepopulated_fields`` com um mapeamento num dicionário com os campos
que devem ser pré-populados a partir de outro campo::

    class ArticleAdmin(admin.ModelAdmin):
        prepopulated_fields = {"slug": ("title",)}

Quando configurado, os campos dados usaram um pouco de JavaScript para popular
os campos atribuídos. O principal uso para esta funcionalidade é a de
automaticamente gerar um valor para campos ``SlugField`` a partir de um ou mais
campos. O valor gerado é produzido concatenando os valores do campo originário,
e então transformando este resultado num slug válido (e.g. substituíndo barras
por espaços).

O ``prepopulated_fields`` não aceita campos ``DateTimeField``, ``ForeignKey``,
nem ``ManyToManyField``.

.. attribute:: ModelAdmin.radio_fields

Por padrão, o admin do Django usa uma interface com select-box (<select>) para
campos que são ``ForeignKey`` ou que tem ``choices`` configurado. Se um campo é
apresentado no ``radio_fields``, o Django usará uma interface com radio-button
ao invés. Assumindo que ``group`` é um ``ForeignKey`` no model ``Person``::

    class PersonAdmin(admin.ModelAdmin):
        radio_fields = {"group": admin.VERTICAL}

Você tem a escolha de usar ``HORIZONTAL`` ou ``VERTICAL`` do módulo
``django.contrib.admin``.

Não inclua um campo no ``radio_fields`` a menos que seja um ``ForeignKey`` ou
tenha ``choices`` setado.

.. attribute:: ModelAdmin.raw_id_fields

By default, Django's admin uses a select-box interface (<select>) for
fields that are ``ForeignKey``. Sometimes you don't want to incur the
overhead of having to select all the related instances to display in the
drop-down.

``raw_id_fields`` is a list of fields you would like to change
into a ``Input`` widget for either a ``ForeignKey`` or ``ManyToManyField``::

    class ArticleAdmin(admin.ModelAdmin):
        raw_id_fields = ("newspaper",)

.. attribute:: ModelAdmin.save_as

Set ``save_as`` to enable a "save as" feature on admin change forms.

Normally, objects have three save options: "Save", "Save and continue editing"
and "Save and add another". If ``save_as`` is ``True``, "Save and add another"
will be replaced by a "Save as" button.

"Save as" means the object will be saved as a new object (with a new ID),
rather than the old object.

By default, ``save_as`` is set to ``False``.

.. attribute:: ModelAdmin.save_on_top

Set ``save_on_top`` to add save buttons across the top of your admin change
forms.

Normally, the save buttons appear only at the bottom of the forms. If you set
``save_on_top``, the buttons will appear both on the top and the bottom.

By default, ``save_on_top`` is set to ``False``.

.. attribute:: ModelAdmin.search_fields

Set ``search_fields`` to enable a search box on the admin change list page.
This should be set to a list of field names that will be searched whenever
somebody submits a search query in that text box.

These fields should be some kind of text field, such as ``CharField`` or
``TextField``. You can also perform a related lookup on a ``ForeignKey`` with
the lookup API "follow" notation::

    search_fields = ['foreign_key__related_fieldname']

When somebody does a search in the admin search box, Django splits the search
query into words and returns all objects that contain each of the words, case
insensitive, where each word must be in at least one of ``search_fields``. For
example, if ``search_fields`` is set to ``['first_name', 'last_name']`` and a
user searches for ``john lennon``, Django will do the equivalent of this SQL
``WHERE`` clause::

    WHERE (first_name ILIKE '%john%' OR last_name ILIKE '%john%')
    AND (first_name ILIKE '%lennon%' OR last_name ILIKE '%lennon%')

For faster and/or more restrictive searches, prefix the field name
with an operator:

``^``
    Matches the beginning of the field. For example, if ``search_fields`` is
    set to ``['^first_name', '^last_name']`` and a user searches for
    ``john lennon``, Django will do the equivalent of this SQL ``WHERE``
    clause::

        WHERE (first_name ILIKE 'john%' OR last_name ILIKE 'john%')
        AND (first_name ILIKE 'lennon%' OR last_name ILIKE 'lennon%')

    This query is more efficient than the normal ``'%john%'`` query, because
    the database only needs to check the beginning of a column's data, rather
    than seeking through the entire column's data. Plus, if the column has an
    index on it, some databases may be able to use the index for this query,
    even though it's a ``LIKE`` query.

``=``
    Matches exactly, case-insensitive. For example, if
    ``search_fields`` is set to ``['=first_name', '=last_name']`` and
    a user searches for ``john lennon``, Django will do the equivalent
    of this SQL ``WHERE`` clause::

        WHERE (first_name ILIKE 'john' OR last_name ILIKE 'john')
        AND (first_name ILIKE 'lennon' OR last_name ILIKE 'lennon')

    Note that the query input is split by spaces, so, following this example,
    it's currently not possible to search for all records in which
    ``first_name`` is exactly ``'john winston'`` (containing a space).

``@``
    Performs a full-text match. This is like the default search method but uses
    an index. Currently this is only available for MySQL.

.. attribute:: ModelAdmin.change_list_template

Path to a custom template that will be used by the model objects "change list"
view. Templates can override or extend base admin templates as described in
`Overriding Admin Templates`_.

If you don't specify this attribute, a default template shipped with Django
that provides the standard appearance is used.

.. attribute:: ModelAdmin.change_form_template

Path to a custom template that will be used by both the model object creation
and change views. Templates can override or extend base admin templates as
described in `Overriding Admin Templates`_.

If you don't specify this attribute, a default template shipped with Django
that provides the standard appearance is used.

.. attribute:: ModelAdmin.object_history_template

Path to a custom template that will be used by the model object change history
display view. Templates can override or extend base admin templates as
described in `Overriding Admin Templates`_.

If you don't specify this attribute, a default template shipped with Django
that provides the standard appearance is used.

.. attribute:: ModelAdmin.delete_confirmation_template

Path to a custom template that will be used by the view responsible of showing
the confirmation page when the user decides to delete one or more model
objects. Templates can override or extend base admin templates as described in
`Overriding Admin Templates`_.

If you don't specify this attribute, a default template shipped with Django
that provides the standard appearance is used.

.. _model-admin-methods:

``ModelAdmin`` methods
----------------------

.. method:: ModelAdmin.save_model(self, request, obj, form, change)

The ``save_model`` method is given the ``HttpRequest``, a model instance,
a ``ModelForm`` instance and a boolean value based on whether it is adding or
changing the object. Here you can do any pre- or post-save operations.

For example to attach ``request.user`` to the object prior to saving::

    class ArticleAdmin(admin.ModelAdmin):
        def save_model(self, request, obj, form, change):
            obj.user = request.user
            obj.save()

.. method:: ModelAdmin.save_formset(self, request, form, formset, change)

The ``save_formset`` method is given the ``HttpRequest``, the parent
``ModelForm`` instance and a boolean value based on whether it is adding or
changing the parent object.

For example to attach ``request.user`` to each changed formset
model instance::

    class ArticleAdmin(admin.ModelAdmin):
        def save_formset(self, request, form, formset, change):
            instances = formset.save(commit=False)
            for instance in instances:
                instance.user = request.user
                instance.save()
            formset.save_m2m()

Other methods
~~~~~~~~~~~~~

.. method:: ModelAdmin.add_view(self, request, form_url='', extra_context=None)

Django view for the model instance addition page. See note below.

.. method:: ModelAdmin.change_view(self, request, object_id, extra_context=None)

Django view for the model instance edition page. See note below.

.. method:: ModelAdmin.changelist_view(self, request, extra_context=None)

Django view for the model instances change list/actions page. See note below.

.. method:: ModelAdmin.delete_view(self, request, object_id, extra_context=None)

Django view for the model instance(s) deletion confirmation page. See note below.

.. method:: ModelAdmin.history_view(self, request, object_id, extra_context=None)

Django view for the page that shows the modification history for a given model
instance.

Unlike the hook-type ``ModelAdmin`` methods detailed in the previous section,
these five methods are in reality designed to be invoked as Django views from
the admin application URL dispatching handler to render the pages that deal
with model instances CRUD operations. As a result, completely overriding these
methods will significantly change the behavior of the admin application.

One comon reason for overriding these methods is to augment the context data
that is provided to the template that renders the view. In the following
example, the change view is overridden so that the rendered template is
provided some extra mapping data that would not otherwise be available::

    class MyModelAdmin(admin.ModelAdmin):

        # A template for a very customized change view:
        change_form_template = 'admin/myapp/extras/openstreetmap_change_form.html'

        def get_osm_info(self):
            # ...

        def change_view(self, request, object_id, extra_context=None):
            my_context = {
                'osm_data': self.get_osm_info(),
            }
            return super(MyModelAdmin, self).change_view(request, object_id,
                extra_context=my_context)

``ModelAdmin`` media definitions
--------------------------------

There are times where you would like add a bit of CSS and/or JavaScript to
the add/change views. This can be accomplished by using a Media inner class
on your ``ModelAdmin``::

    class ArticleAdmin(admin.ModelAdmin):
        class Media:
            css = {
                "all": ("my_styles.css",)
            }
            js = ("my_code.js",)

Keep in mind that this will be prepended with ``MEDIA_URL``. The same rules
apply as :ref:`regular media definitions on forms <topics-forms-media>`.

Adicionando validação personalizada ao admin
--------------------------------------------

Adding custom validation of data in the admin is quite easy. The automatic admin
interface reuses :mod:`django.forms`, and the ``ModelAdmin`` class gives you
the ability define your own form::

    class ArticleAdmin(admin.ModelAdmin):
        form = MyArticleAdminForm

``MyArticleAdminForm`` can be defined anywhere as long as you import where
needed. Now within your form you can add your own custom validation for
any field::

    class MyArticleAdminForm(forms.ModelForm):
        class Meta:
            model = Article

        def clean_name(self):
            # do something that validates your data
            return self.cleaned_data["name"]

It is important you use a ``ModelForm`` here otherwise things can break. See the
:ref:`forms <ref-forms-index>` documentation on :ref:`custom validation
<ref-forms-validation>` and, more specifically, the
:ref:`model form validation notes <overriding-modelform-clean-method>` for more
information.

.. _admin-inlines:

``InlineModelAdmin`` objects
============================

The admin interface has the ability to edit models on the same page as a
parent model. These are called inlines. Suppose you have these two models::

     class Author(models.Model):
        name = models.CharField(max_length=100)

     class Book(models.Model):
        author = models.ForeignKey(Author)
        title = models.CharField(max_length=100)

You can edit the books authored by an author on the author page. You add
inlines to a model by specifying them in a ``ModelAdmin.inlines``::

    class BookInline(admin.TabularInline):
        model = Book

    class AuthorAdmin(admin.ModelAdmin):
        inlines = [
            BookInline,
        ]

Django provides two subclasses of ``InlineModelAdmin`` and they are:

    * ``TabularInline``
    * ``StackedInline``

The difference between these two is merely the template used to render them.

``InlineModelAdmin`` options
-----------------------------

The ``InlineModelAdmin`` class is a subclass of ``ModelAdmin`` so it inherits
all the same functionality as well as some of its own:

``model``
~~~~~~~~~

The model in which the inline is using. This is required.

``fk_name``
~~~~~~~~~~~

The name of the foreign key on the model. In most cases this will be dealt
with automatically, but ``fk_name`` must be specified explicitly if there are
more than one foreign key to the same parent model.

``formset``
~~~~~~~~~~~

This defaults to ``BaseInlineFormSet``. Using your own formset can give you
many possibilities of customization. Inlines are built around
:ref:`model formsets <model-formsets>`.

``form``
~~~~~~~~

The value for ``form`` defaults to ``BaseModelForm``. This is what is
passed through to ``formset_factory`` when creating the formset for this
inline.

``extra``
~~~~~~~~~

This controls the number of extra forms the formset will display in addition
to the initial forms. See the
:ref:`formsets documentation <topics-forms-formsets>` for more information.

``max_num``
~~~~~~~~~~~

This controls the maximum number of forms to show in the inline. This doesn't
directly correlate to the number of objects, but can if the value is small
enough. See :ref:`model-formsets-max-num` for more information.

``raw_id_fields``
~~~~~~~~~~~~~~~~~

By default, Django's admin uses a select-box interface (<select>) for
fields that are ``ForeignKey``. Sometimes you don't want to incur the
overhead of having to select all the related instances to display in the
drop-down.

``raw_id_fields`` is a list of fields you would like to change
into a ``Input`` widget for either a ``ForeignKey`` or ``ManyToManyField``::

    class BookInline(admin.TabularInline):
        model = Book
        raw_id_fields = ("pages",)

``template``
~~~~~~~~~~~~

The template used to render the inline on the page.

``verbose_name``
~~~~~~~~~~~~~~~~

An override to the ``verbose_name`` found in the model's inner ``Meta`` class.

``verbose_name_plural``
~~~~~~~~~~~~~~~~~~~~~~~

An override to the ``verbose_name_plural`` found in the model's inner ``Meta``
class.

Working with a model with two or more foreign keys to the same parent model
---------------------------------------------------------------------------

It is sometimes possible to have more than one foreign key to the same model.
Take this model for instance::

    class Friendship(models.Model):
        to_person = models.ForeignKey(Person, related_name="friends")
        from_person = models.ForeignKey(Person, related_name="from_friends")

If you wanted to display an inline on the ``Person`` admin add/change pages
you need to explicitly define the foreign key since it is unable to do so
automatically::

    class FriendshipInline(admin.TabularInline):
        model = Friendship
        fk_name = "to_person"

    class PersonAdmin(admin.ModelAdmin):
        inlines = [
            FriendshipInline,
        ]

Working with Many-to-Many Intermediary Models
----------------------------------------------

By default, admin widgets for many-to-many relations will be displayed inline
on whichever model contains the actual reference to the ``ManyToManyField``.
However, when you specify an intermediary model using the ``through``
argument to a ``ManyToManyField``, the admin will not display a widget by
default. This is because each instance of that intermediary model requires
more information than could be displayed in a single widget, and the layout
required for multiple widgets will vary depending on the intermediate model.

However, we still want to be able to edit that information inline. Fortunately,
this is easy to do with inline admin models. Suppose we have the following
models::

    class Person(models.Model):
        name = models.CharField(max_length=128)

    class Group(models.Model):
        name = models.CharField(max_length=128)
        members = models.ManyToManyField(Person, through='Membership')

    class Membership(models.Model):
        person = models.ForeignKey(Person)
        group = models.ForeignKey(Group)
        date_joined = models.DateField()
        invite_reason = models.CharField(max_length=64)

The first step in displaying this intermediate model in the admin is to
define an inline class for the ``Membership`` model::

    class MembershipInline(admin.TabularInline):
        model = Membership
        extra = 1

This simple example uses the default ``InlineModelAdmin`` values for the
``Membership`` model, and limits the extra add forms to one. This could be
customized using any of the options available to ``InlineModelAdmin`` classes.

Now create admin views for the ``Person`` and ``Group`` models::

    class PersonAdmin(admin.ModelAdmin):
        inlines = (MembershipInline,)

    class GroupAdmin(admin.ModelAdmin):
        inlines = (MembershipInline,)

Finally, register your ``Person`` and ``Group`` models with the admin site::

    admin.site.register(Person, PersonAdmin)
    admin.site.register(Group, GroupAdmin)

Now your admin site is set up to edit ``Membership`` objects inline from
either the ``Person`` or the ``Group`` detail pages.

Using generic relations as an inline
------------------------------------

It is possible to use an inline with generically related objects. Let's say
you have the following models::

    class Image(models.Model):
        image = models.ImageField(upload_to="images")
        content_type = models.ForeignKey(ContentType)
        object_id = models.PositiveIntegerField()
        content_object = generic.GenericForeignKey("content_type", "object_id")

    class Product(models.Model):
        name = models.CharField(max_length=100)

If you want to allow editing and creating ``Image`` instance on the ``Product``
add/change views you can simply use ``GenericInlineModelAdmin`` provided by
``django.contrib.contenttypes.generic``. In your ``admin.py`` for this
example app::

    from django.contrib import admin
    from django.contrib.contenttypes import generic

    from myproject.myapp.models import Image, Product

    class ImageInline(generic.GenericTabularInline):
        model = Image

    class ProductAdmin(admin.ModelAdmin):
        inlines = [
            ImageInline,
        ]

    admin.site.register(Product, ProductAdmin)

``django.contrib.contenttypes.generic`` provides both a ``GenericTabularInline``
and ``GenericStackedInline`` and behave just like any other inline. See the
:ref:`contenttypes documentation <ref-contrib-contenttypes>` for more specific
information.

Overriding Admin Templates
==========================

It is relatively easy to override many of the templates which the admin module
uses to generate the various pages of an admin site. You can even override a few
of these templates for a specific app, or a specific model.

Set up your projects admin template directories
-----------------------------------------------

The admin template files are located in the ``contrib/admin/templates/admin``
directory.

In order to override one or more of them, first create an ``admin`` directory in
your project's ``templates`` directory. This can be any of the directories you
specified in ``TEMPLATE_DIRS``.

Within this ``admin`` directory, create sub-directories named after your app.
Within these app subdirectories create sub-directories named after your models.
Note, that the admin app will lowercase the model name when looking for the
directory, so make sure you name the directory in all lowercase if you are going
to run your app on a case-sensitive filesystem.

To override an admin template for a specific app, copy and edit the template
from the ``django/contrib/admin/templates/admin`` directory, and save it to one
of the directories you just created.

For example, if we wanted to add a tool to the change list view for all the
models in an app named ``my_app``, we would copy
``contrib/admin/templates/admin/change_list.html`` to the
``templates/admin/my_app/`` directory of our project, and make any necessary
changes.

If we wanted to add a tool to the change list view for only a specific model
named 'Page', we would copy that same file to the
``templates/admin/my_app/page`` directory of our project.

Overriding vs. replacing an admin template
------------------------------------------

Because of the modular design of the admin templates, it is usually neither
necessary nor advisable to replace an entire template. It is almost always
better to override only the section of the template which you need to change.

To continue the example above, we want to add a new link next to the ``History``
tool for the ``Page`` model. After looking at ``change_form.html`` we determine
that we only need to override the ``object-tools`` block. Therefore here is our
new ``change_form.html`` :

.. code-block:: html+django

    {% extends "admin/change_form.html" %}
    {% load i18n %}
    {% block object-tools %}
    {% if change %}{% if not is_popup %}
      <ul class="object-tools">
        <li><a href="history/" class="historylink">{% trans "History" %}</a></li>
        <li><a href="mylink/" class="historylink">My Link</a></li>
        {% if has_absolute_url %}
            <li><a href="../../../r/{{ content_type_id }}/{{ object_id }}/" class="viewsitelink">
                {% trans "View on site" %}</a>
            </li>
        {% endif%}
      </ul>
    {% endif %}{% endif %}
    {% endblock %}

And that's it! If we placed this file in the ``templates/admin/my_app``
directory, our link would appear on every model's change form.

Templates which may be overridden per app or model
--------------------------------------------------

Not every template in ``contrib/admin/templates/admin`` may be overridden per
app or per model. The following can:

    * ``change_form.html``
    * ``change_list.html``
    * ``delete_confirmation.html``
    * ``object_history.html``

For those templates that cannot be overridden in this way, you may still
override them for your entire project. Just place the new version in your
``templates/admin`` directory. This is particularly useful to create custom 404
and 500 pages.

.. note::

    Some of the admin templates, such as ``change_list_request.html`` are used
    to render custom inclusion tags. These may be overridden, but in such cases
    you are probably better off creating your own version of the tag in question
    and giving it a different name. That way you can use it selectively.

Root and login templates
------------------------

If you wish to change the index or login templates, you are better off
creating your own ``AdminSite`` instance (see below), and changing the
:attr:`AdminSite.index_template` or :attr:`AdminSite.login_template`
properties.

``AdminSite`` objects
=====================

A Django administrative site is represented by an instance of
``django.contrib.admin.sites.AdminSite``; by default, an instance of
this class is created as ``django.contrib.admin.site`` and you can
register your models and ``ModelAdmin`` instances with it.

If you'd like to set up your own administrative site with custom
behavior, however, you're free to subclass ``AdminSite`` and override
or add anything you like. Then, simply create an instance of your
``AdminSite`` subclass (the same way you'd instantiate any other
Python class), and register your models and ``ModelAdmin`` subclasses
with it instead of using the default.

``AdminSite`` attributes
------------------------

.. attribute:: AdminSite.index_template

Path to a custom template that will be used by the admin site main index view.
Templates can override or extend base admin templates as described in
`Overriding Admin Templates`_.

.. attribute:: AdminSite.login_template

Path to a custom template that will be used by the admin site login view.
Templates can override or extend base admin templates as described in
`Overriding Admin Templates`_.

Hooking ``AdminSite`` instances into your URLconf
-------------------------------------------------

The last step in setting up the Django admin is to hook your ``AdminSite``
instance into your URLconf. Do this by pointing a given URL at the
``AdminSite.urls`` method.

In this example, we register the default ``AdminSite`` instance
``django.contrib.admin.site`` at the URL ``/admin/`` ::

    # urls.py
    from django.conf.urls.defaults import *
    from django.contrib import admin

    admin.autodiscover()

    urlpatterns = patterns('',
        ('^admin/(.*)', admin.site.root),
    )

Above we used ``admin.autodiscover()`` to automatically load the
``INSTALLED_APPS`` admin.py modules.

In this example, we register the ``AdminSite`` instance
``myproject.admin.admin_site`` at the URL ``/myadmin/`` ::

    # urls.py
    from django.conf.urls.defaults import *
    from myproject.admin import admin_site

    urlpatterns = patterns('',
        ('^myadmin/(.*)', admin_site.root),
    )

There is really no need to use autodiscover when using your own ``AdminSite``
instance since you will likely be importing all the per-app admin.py modules
in your ``myproject.admin`` module.

Note that the regular expression in the URLpattern *must* group everything in
the URL that comes after the URL root -- hence the ``(.*)`` in these examples.

Multiple admin sites in the same URLconf
----------------------------------------

It's easy to create multiple instances of the admin site on the same
Django-powered Web site. Just create multiple instances of ``AdminSite`` and
root each one at a different URL.

In this example, the URLs ``/basic-admin/`` and ``/advanced-admin/`` feature
separate versions of the admin site -- using the ``AdminSite`` instances
``myproject.admin.basic_site`` and ``myproject.admin.advanced_site``,
respectively::

    # urls.py
    from django.conf.urls.defaults import *
    from myproject.admin import basic_site, advanced_site

    urlpatterns = patterns('',
        ('^basic-admin/(.*)', basic_site.root),
        ('^advanced-admin/(.*)', advanced_site.root),
    )

