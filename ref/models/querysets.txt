..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11268 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _ref-models-querysets:

==========================
Referência da API QuerySet
==========================

.. currentmodule:: django.db.models

Este documento descreve os detalhes da API do ``QuerySet``. Ela se baseia no
material apresentado nos guias :ref:`model <topics-db-models>` e :ref:`query de
banco de dados <topics-db-queries>`, então você provavelmente vai querer ler e
entender esses documentos antes de ler este aqui.

Por toda essa referência nós iremos usar os :ref:`models do exemplo weblog
<queryset-model-example>` apresentado em :ref:`guia de consulta de banco de
dados <topics-db-queries>`.

.. _when-querysets-are-evaluated:

Quando QuerySets são avaliados
==============================

Internamente, um ``QuerySet`` pode ser construído, filtrado, dividido, e
geralmente passado adiante sem, bem na verdade, atingir o banco de dados.
Nenhuma atividade de banco de dados realmente ocorre, até que você faça algo
que avalie o queryset.

Você pode avaliar um ``QuerySet`` das seguintes formas:

    * **Iteração.** Um ``QuerySet`` é iterável, e ele executa suas consultas de
      banco de dados na primeira vez que você itera sobre ele. Por exemplo, isso
      irá imprimir o título de todas as entradas do banco de dados::

          for e in Entry.objects.all():
              print e.headline

    * **Fatiando/Dividindo.** Como explicado em :ref:`limiting-querysets`, um
      ``QuerySet`` pode ser dividido, usando a sintaxe de fatiamento do Python.
      Geralmente fatiar um ``QuerySet`` retorna um outro (não avalidado)
      ``QuerySet``, mas o Django executará a consulta do banco de dados se você
      usar o parametro "step" da sintaxe de fatiamento.

    * **Preservamento/Cacheamento.** Veja a seguinte seção para detalhes que é
      envolvida quando se `preservando QuerySets`_. A coisa importante para
      proposta desta seção é que os resultados são lidos do banco de dados.

    * **repr().** Um ``QuerySet`` é avaliado quando você chama ``repr()`` sobre
      ele. Este é por conveniencia um interpretador Python interativo, então
      você pode imediatamente ver seus resultados quando estiver usando a API
      interativamente.

    * **len().** Um ``QuerySet`` e avaliado quando você chama ``len()`` sobre
      ele. Isso, como você pode esperar, retorna o comprimento da lista de
      resultados.

      Nota: *Não* use ``len()`` sobre ``QuerySet``\s se tudo que você quer fazer
      é determinar o número de dados de um conjunto. É muito mais eficiente
      manipular um contador a nível de banco de dados, usando um SQL
      ``SELECT COUNT(*)``, e o Django provê um método ``count()`` justamente
      por esta razão. Veja ``count()`` abaixo.

    * **list().** Força a avaliação de um ``QuerySet`` chamando ``list()`` sobre
      ele. Por exemplo::

          entry_list = list(Entry.objects.all())

      Esteja avisado, no entanto, que isso poderia resultar num grande consumo
      de memória, porque o Django carregará cada elemento da lista na sua
      memória. Em contrast, iterando sobre um ``QuerySet`` você tirará vantagem
      de seu banco de dados para carregar os dados e instânciar os objetos sobre
      quando precisar deles.

.. _pickling QuerySets:

Preservando QuerySets
---------------------

Se você preserva_ um ``QuerySet``, este forçará todos os resultados a serem
carregados em memória para conservação. O preservamento é geralmente usado como
um precursor para o cache, quando o cache do queryset é reacarregado, você
terá os resultados já presentes e prontos para o uso (lendo do banco de dados
pode tomar algum tempo, anulando a proposta do cache). Isto significa que quando
você desconserva um ``QuerySet``, ele contém os resultados do momento em que foi
preservado, ao invés dos resultados que estão atualmente no banco de dados.

Se você somente quer preservar as informações necessárias para recriar o
``QuerySet`` do banco de dados desde a última vez, conserve o atributo ``query``
do ``QuerySet``. Você pode então recriar o ``QuerySet`` original (sem qualquer
resultado carregado) usando algum código como este::

    >>> import pickle
    >>> query = pickle.loads(s)     # Assumindo 's' como uma string conservada.
    >>> qs = MyModel.objects.all()
    >>> qs.query = query            # Restaura o 'query' original.

O atributo ``query`` é um objeto opaco. Ele representa o construção interna da
query e não parte da API pública. Entretanto, ele é seguro (e completamente
suportado) para preservar e reconstruir os conteúdos dos atributos como descrito
aqui.

.. _preserva: http://docs.python.org/lib/module-pickle.html

.. _queryset-api:

API QuerySet
============

Embora você geralmente não criará uma manualmente -- você passará um
:class:`Manager` -- aqui tem a declaração formal de um ``QuerySet``:

.. class:: QuerySet([model=None])

Normalemente quando você for interagir com um ``QuerySet`` você o usará com
:ref:`filtros encadeados <chaining-filters>`. Para fazer isto funcionar, a
maioria dos métodos do ``QuerySet`` retorna novos querysets.

Métodos de QuerySet que retornam novos QuerySets
------------------------------------------------

O Django fornece uma gama de métodos de refinamento do ``QuerySet`` que modifica
cada tipo de resultados retornados pelo ``QuerySet`` ou a forma como sua
consulta SQL é executada.

``filter(**kwargs)``
~~~~~~~~~~~~~~~~~~~~

Retorna um novo ``QuerySet`` contendo objetos que combinam com os paramêtros
dados.

Os parametros (``**kwargs``) devem ser no formato descrito em `Campos de
Pesquisa`_ abaixo. Vários parametros são mesclados via ``AND`` e regras SQL
subjacentes.

``exclude(**kwargs)``
~~~~~~~~~~~~~~~~~~~~~

Retorna um novo ``QuerySet`` contendo objetos que *não* combinam com os
paramêtros dados.

Os parametros (``**kwargs``) devem ser no formato descrito em `Campos de
Pesquisa`_ abaixo. Vários parametros são mesclados via ``AND`` e regras SQL
subjacentes, e todoa coisa é envolvida por um ``NOT()``.

Este exemplo exclui todas as entradas cujo ``pub_date`` é maior que 2005-1-3
e (AND) cujo ``headline`` é igual "Hello"::

    Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')

Em termos SQL, isso seria::

    SELECT ...
    WHERE NOT (pub_date > '2005-1-3' AND headline = 'Hello')

Este exemplo exclui entradas cujo ``pub_date`` é maior que 2005-1-3 ou (OR) cujo
``headline`` é "Hello"::

    Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3)).exclude(headline='Hello')

Em termos SQL, isso seria::

    SELECT ...
    WHERE NOT pub_date > '2005-1-3'
    OR NOT headline = 'Hello'

Note que o segundo exemplo e mais restritivo.

``order_by(*fields)``
~~~~~~~~~~~~~~~~~~~~~

Por padrão, os resultados retornados por um ``QuerySet`` são ordenado por uma
tupla dada pela opção ``ordering`` no ``Meta`` do model. Você pode sobrescrever
isso para uma ``QuerySet`` basicamente usando o método ``order_by``.
Exemplo::

    Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')

O resultado acima será ordenado por ``pub_date`` descrescendo, e então por
``headline`` ascendendo. O sinal negativo na frente do ``"-pub_date"`` indica
o ordenamento *descendente*. O ordenamento ascendente é implícito. Para ordenar
randômicamente, use ``"?"``, desta forma::

    Entry.objects.order_by('?')

Nota: a consulta ``order_by('?')`` pode ser custosa e lenta, dependendo do
backend e banco de dados que estiver usando.

Para ordenar por um campo de um model diferente, use a mesma sintaxe como quando
você consulta através de relações de models. Isto é, o nome do campo, seguido
por um underscore duplo (``__``), seguido pelo nome do campo no novo model, faça
assim para todos os models que você deseja juntar na consulta. Por exemplo::

    Entry.objects.order_by('blog__name', 'headline')

Se você tentar ordenar por um campo que é relacionado a outro model, o Django
usará o ordenamento padrão do model relacionado (ou ordenará pela chave primária
do model relacionado se ele não tiver um ``Meta.ordering`` especificado. Por
exemplo::

    Entry.objects.order_by('blog')

...é identico a::

    Entry.objects.order_by('blog__id')

...desde que o model ``Blog`` não tenha o ordenamento especificado.

Seja cauteloso quando ordenar por campos de models relacionados se você também
estiver usando ``distinct()``. Veja a nota na seção `distinct()`_ para uma
explicação e como um model relacionado ordenado pode mudar os resultados
esperados.

It is permissible to specify a multi-valued field to order the results by (for
example, a ``ManyToMany`` field). Normally this won't be a sensible thing to
do and it's really an advanced usage feature. However, if you know that your
queryset's filtering or available data implies that there will only be one
ordering piece of data for each of the main items you are selecting, the
ordering may well be exactly what you want to do. Use ordering on multi-valued
fields with care and make sure the results are what you expect.

Admite-se especificar um campo com multi-valor para ordenar resultados (por
exemplo, um campo ``ManyToMany``). Normalmente isso não será uma coisa sensível
a se fazer e ele realmente é uma funcionalidade avançada de uso.

.. versionadded:: 1.0

Se você não quer que qualquer ordenamento seja aplicado a consulta, nem mesmo o
ordenamento padrão, chame ``order_by()`` sem parametros.
.. versionadded:: 1.0

A sintax de para ordenamento através de models relacionados mudou. Veja a
`documentação do Django 0.96`_ para os comportamentos antigos.

.. _documentação do Django 0.96: http://www.djangoproject.com/documentation/0.96/model-api/#floatfield

Não há formas de especificar se o ordenamento deve ser sensível a maiúsculas e
minúsculas. Com respeito a case-sensitivity, o Django não ordena resultados por
mais que seu backend de banco de dados normalmente o faça.

``reverse()``
~~~~~~~~~~~~~

.. versionadded:: 1.0

Use the ``reverse()`` method to reverse the order in which a queryset's
elements are returned. Calling ``reverse()`` a second time restores the
ordering back to the normal direction.

To retrieve the ''last'' five items in a queryset, you could do this::

    my_queryset.reverse()[:5]

Note that this is not quite the same as slicing from the end of a sequence in
Python. The above example will return the last item first, then the
penultimate item and so on. If we had a Python sequence and looked at
``seq[-5:]``, we would see the fifth-last item first. Django doesn't support
that mode of access (slicing from the end), because it's not possible to do it
efficiently in SQL.

Also, note that ``reverse()`` should generally only be called on a
``QuerySet`` which has a defined ordering (e.g., when querying against
a model which defines a default ordering, or when using
``order_by()``). If no such ordering is defined for a given
``QuerySet``, calling ``reverse()`` on it has no real effect (the
ordering was undefined prior to calling ``reverse()``, and will remain
undefined afterward).

``distinct()``
~~~~~~~~~~~~~~

Returns a new ``QuerySet`` that uses ``SELECT DISTINCT`` in its SQL query. This
eliminates duplicate rows from the query results.

By default, a ``QuerySet`` will not eliminate duplicate rows. In practice, this
is rarely a problem, because simple queries such as ``Blog.objects.all()``
don't introduce the possibility of duplicate result rows. However, if your
query spans multiple tables, it's possible to get duplicate results when a
``QuerySet`` is evaluated. That's when you'd use ``distinct()``.

.. note::
    Any fields used in an `order_by(*fields)`_ call are included in the SQL
    ``SELECT`` columns. This can sometimes lead to unexpected results when
    used in conjunction with ``distinct()``. If you order by fields from a
    related model, those fields will be added to the selected columns and they
    may make otherwise duplicate rows appear to be distinct. Since the extra
    columns don't appear in the returned results (they are only there to
    support ordering), it sometimes looks like non-distinct results are being
    returned.

    Similarly, if you use a ``values()`` query to restrict the columns
    selected, the columns used in any ``order_by()`` (or default model
    ordering) will still be involved and may affect uniqueness of the results.

    The moral here is that if you are using ``distinct()`` be careful about
    ordering by related models. Similarly, when using ``distinct()`` and
    ``values()`` together, be careful when ordering by fields not in the
    ``values()`` call.


``values(*fields)``
~~~~~~~~~~~~~~~~~~~

Returns a ``ValuesQuerySet`` -- a ``QuerySet`` that evaluates to a list of
dictionaries instead of model-instance objects.

Each of those dictionaries represents an object, with the keys corresponding to
the attribute names of model objects.

This example compares the dictionaries of ``values()`` with the normal model
objects::

    # This list contains a Blog object.
    >>> Blog.objects.filter(name__startswith='Beatles')
    [<Blog: Beatles Blog>]

    # This list contains a dictionary.
    >>> Blog.objects.filter(name__startswith='Beatles').values()
    [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]

``values()`` takes optional positional arguments, ``*fields``, which specify
field names to which the ``SELECT`` should be limited. If you specify the
fields, each dictionary will contain only the field keys/values for the fields
you specify. If you don't specify the fields, each dictionary will contain a
key and value for every field in the database table.

Exemplo::

    >>> Blog.objects.values()
    [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}],
    >>> Blog.objects.values('id', 'name')
    [{'id': 1, 'name': 'Beatles Blog'}]

A couple of subtleties that are worth mentioning:

    * The ``values()`` method does not return anything for
      :class:`~django.db.models.ManyToManyField` attributes and will raise an
      error if you try to pass in this type of field to it.
    * If you have a field called ``foo`` that is a
      :class:`~django.db.models.ForeignKey`, the default ``values()`` call
      will return a dictionary key called ``foo_id``, since this is the name
      of the hidden model attribute that stores the actual value (the ``foo``
      attribute refers to the related model). When you are calling
      ``values()`` and passing in field names, you can pass in either ``foo``
      or ``foo_id`` and you will get back the same thing (the dictionary key
      will match the field name you passed in).

      For Exemplo::

        >>> Entry.objects.values()
        [{'blog_id: 1, 'headline': u'First Entry', ...}, ...]

        >>> Entry.objects.values('blog')
        [{'blog': 1}, ...]

        >>> Entry.objects.values('blog_id')
        [{'blog_id': 1}, ...]
    * When using ``values()`` together with ``distinct()``, be aware that
      ordering can affect the results. See the note in the `distinct()`_
      section, above, for details.

.. versionadded:: 1.0

Previously, it was not possible to pass ``blog_id`` to ``values()`` in the above
example, only ``blog``.

A ``ValuesQuerySet`` is useful when you know you're only going to need values
from a small number of the available fields and you won't need the
functionality of a model instance object. It's more efficient to select only
the fields you need to use.

Finally, note a ``ValuesQuerySet`` is a subclass of ``QuerySet``, so it has all
methods of ``QuerySet``. You can call ``filter()`` on it, or ``order_by()``, or
whatever. Yes, that means these two calls are identical::

    Blog.objects.values().order_by('id')
    Blog.objects.order_by('id').values()

The people who made Django prefer to put all the SQL-affecting methods first,
followed (optionally) by any output-affecting methods (such as ``values()``),
but it doesn't really matter. This is your chance to really flaunt your
individualism.

``values_list(*fields)``
~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

Este é similar ao ``values()`` exceto que ao invés de retornar uma lista de
dicionários, ele retorna uma lista de tuplas. Cada tupla contém o valor do
respectivo campo passado dentro da chamada ``values_list()`` -- então o primeiro
item é o primeiro campo, etc. Por exemplo::

    >>> Entry.objects.values_list('id', 'headline')
    [(1, u'First entry'), ...]

Se você somente passa um campo singular, você também pode passar num paramêtro
``flat``. Se ``True``, isto significará que os resultados retornados são valores
únicos, ao invés de uma tupla. Um exemplo deve fazer a diferença::

    >>> Entry.objects.values_list('id').order_by('id')
    [(1,), (2,), (3,), ...]

    >>> Entry.objects.values_list('id', flat=True).order_by('id')
    [1, 2, 3, ...]

É um erro passa o ``flat`` quando há mais de um campo.

Se você não passar quaisquer valores ao ``values_list()``, ele irá retornar
todos os campos no model, na ordem em que foram declarados.

``dates(field, kind, order='ASC')``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Retorna um ``DateQuerySet`` -- um ``QuerySet`` que avalia uma lista de objetos
``datetime.datetime`` representando todos as datas disponíveis de um tipo
particular dentro dos conteúdos do ``QuerySet``.

O ``field`` deve ser o nome de um ``DateField`` ou ``DateTimeField`` de seu
model.

O ``kind`` deve ser ``"year"``, ``"month"`` ou ``"day"``. Cada objeto
``datetime.datetime`` na lista de resultados é "trucado" para o ``type`` dado.

    * ``"year"`` retorna uma lista de todos os valores de anos distintos para o
      campo.
    * ``"month"`` retorna uma lista de todos os valores anos/mês para o campo.
    * ``"day"`` retorna uma lista de todos os valores ano/mês/dia para o campo.

O ``order``, que por padrão é ``'ASC'``, deve ser ``'ASC'`` ou ``'DESC'``. Isto
especifica como ordenar os resultados.

Exemplos::

    >>> Entry.objects.dates('pub_date', 'year')
    [datetime.datetime(2005, 1, 1)]
    >>> Entry.objects.dates('pub_date', 'month')
    [datetime.datetime(2005, 2, 1), datetime.datetime(2005, 3, 1)]
    >>> Entry.objects.dates('pub_date', 'day')
    [datetime.datetime(2005, 2, 20), datetime.datetime(2005, 3, 20)]
    >>> Entry.objects.dates('pub_date', 'day', order='DESC')
    [datetime.datetime(2005, 3, 20), datetime.datetime(2005, 2, 20)]
    >>> Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
    [datetime.datetime(2005, 3, 20)]

``none()``
~~~~~~~~~~

.. versionadded:: 1.0

Retorna um ``EmptyQuerySet`` -- um ``QuerySet`` que sempre avalia para uma lista
vazia. Este pode ser usado nos casos onde você sabe que você deve retornar uma
lista de resultados vazia e sua chamada está esperando um objeto ``QuerySet``
(ao invés de retornar uma lista vazia, por exemplo.)

Exemplos::

    >>> Entry.objects.none()
    []

``all()``
~~~~~~~~~~

.. versionadded:: 1.0

Retorna uma ''cópia'' do ``QuerySet`` atual (ou extende o ``QuerySet`` que você
passou). Isso pode ser útil em algumas situações onde você pode querer passar
em cada model manager ou um ``QuerySet`` e fazer uma filtragem maior do
resultado. Você pode seguramente chamar ``all()`` em cada objeto e então você
definitivamente terá um ``QuerySet`` para trabalhar com.

.. _select-related:

``select_related()``
~~~~~~~~~~~~~~~~~~~~

Retorna um ``QuerySet`` que automaticamente "seguirá" chaves estrangeiras de
relacionamentos, selecionando os dados adicionais de objetos relacionados quando
executar sua consulta. Isso é um aumentador de performance com resultados em
(algumas vezes mais) consultas maiores, mas significa mais uso de
relacionamentos de chave estrangeira que não vão exigir consultas de banco de
dados.

O seguinte exemplo ilustra a diferença entre pesquisas planas e pesquisas
``select_related()``. Aqui a pesquisa padrão::

    # Acerta o banco de dados.
    e = Entry.objects.get(id=5)

    # Acerta o banco de dados novmante para pegar o objeto Blog relacionado.
    b = e.blog

E aqui uma pesquisa ``select_related``::

    # Acerta o banco de dados.
    e = Entry.objects.select_related().get(id=5)

    # Não acerta o banco de dados, porque e.blog já foi populado numa consulta
    # anterior.
    b = e.blog

O ``select_related()`` segue chaves estrangeiras tão longe quanto possível. Se
você tem os seguintes models::

    class City(models.Model):
        # ...

    class Person(models.Model):
        # ...
        hometown = models.ForeignKey(City)

    class Book(models.Model):
        # ...
        author = models.ForeignKey(Person)

...então uma chamada para ``Book.objects.select_related().get(id=4)`` fará cache
do objeto relacionado ``Person`` *e* do ``City``::

    b = Book.objects.select_related().get(id=4)
    p = b.author         # Não acerta o banco de dados.
    c = p.hometown       # Não acerta o banco de dados.

    b = Book.objects.get(id=4) # Nenhum select_related() neste exemplo.
    p = b.author         # Acerta o banco de dados.
    c = p.hometown       # Acerta o banco de dados.

Note que, por padrão, ``selected_related()`` não segue chaves estrangeiras que
tenham ``null=True``.

Normalmente, usar o ``select_related()`` pode melhorar muito a performance
pois sua aplicação pode evitar muitas chamadas de banco de dados. Entretanto,
em situações com conjuntos profundamente aninhados de relacionamentos, o
``select_related`` pode algumas vezes acabar seguindo "relacionamentos de mais",
e pode gerar consultas tão grandes que elas acabam sendo lentas.

Nestas situações, você pode usar o argumento ``depth`` para controlar quantos
"níveis" de relações o ``select_related()`` realmente irá seguir::

    b = Book.objects.select_related(depth=1).get(id=4)
    p = b.author         # Não acerta o banco de dados.
    c = p.hometown       # Requer uma chamada de banco de dados.

Algumas vezes você somente quer acessar um model específico que está relacionado
ao seu model raiz, não todos os models relacionados. Nestes casos, você pode
passar os nomes dos campos ao ``select_related()`` e ele somente seguirá estas
relações.
Você pode até fazer isso para os models que estão a mais de uma relação de
distância, separando os nomes dos campos com underscores duplos, assim como nos
filtros. Por exemplo, se você tem este model::

    class Room(models.Model):
        # ...
        building = models.ForeignKey(...)

    class Group(models.Model):
        # ...
        teacher = models.ForeignKey(...)
        room = models.ForeignKey(Room)
        subject = models.ForeignKey(...)

...e você somente precisa trabalhar com os atributos ``room`` e ``subject``,
você poderia escrever isso::

    g = Group.objects.select_related('room', 'subject')

Isso também é válido::

    g = Group.objects.select_related('room__building', 'subject')

...e também puxar a relação ``building``.

Você somente pode referenciar à relações ``ForeignKey`` na lista de campos
passada ao ``selected_related``. Você *pode* referenciar chaves estrangeiras que
tenham ``null=True`` (indiferente da chamada padrão do ``select_related()``). É
um erro usar ambos, uma lista de campos e o paramêtro ``depth``, na mesma
chamada do ``select_related()``, já que eles são opções conflitantes.

.. versionadded:: 1.0

Ambos, o argumento ``depth`` e a abilidade de especificar nomes de campos em
chamadas do ``select_related()``, são novidades do Django 1.0.

.. _extra:

``extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sometimes, the Django query syntax by itself can't easily express a complex
``WHERE`` clause. For these edge cases, Django provides the ``extra()``
``QuerySet`` modifier -- a hook for injecting specific clauses into the SQL
generated by a ``QuerySet``.

By definition, these extra lookups may not be portable to different database
engines (because you're explicitly writing SQL code) and violate the DRY
principle, so you should avoid them if possible.

Specify one or more of ``params``, ``select``, ``where`` or ``tables``. None
of the arguments is required, but you should use at least one of them.

``select``
    The ``select`` argument lets you put extra fields in the ``SELECT`` clause.
    It should be a dictionary mapping attribute names to SQL clauses to use to
    calculate that attribute.

    Exemplo::

        Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})

    As a result, each ``Entry`` object will have an extra attribute,
    ``is_recent``, a boolean representing whether the entry's ``pub_date`` is
    greater than Jan. 1, 2006.

    Django inserts the given SQL snippet directly into the ``SELECT``
    statement, so the resulting SQL of the above example would be::

        SELECT blog_entry.*, (pub_date > '2006-01-01')
        FROM blog_entry;


    The next example is more advanced; it does a subquery to give each
    resulting ``Blog`` object an ``entry_count`` attribute, an integer count
    of associated ``Entry`` objects::

        Blog.objects.extra(
            select={
                'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'
            },
        )

    (In this particular case, we're exploiting the fact that the query will
    already contain the ``blog_blog`` table in its ``FROM`` clause.)

    The resulting SQL of the above example would be::

        SELECT blog_blog.*, (SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id) AS entry_count
        FROM blog_blog;

    Note that the parenthesis required by most database engines around
    subqueries are not required in Django's ``select`` clauses. Also note that
    some database backends, such as some MySQL versions, don't support
    subqueries.

    .. versionadded:: 1.0

    In some rare cases, you might wish to pass parameters to the SQL fragments
    in ``extra(select=...)``. For this purpose, use the ``select_params``
    parameter. Since ``select_params`` is a sequence and the ``select``
    attribute is a dictionary, some care is required so that the parameters
    are matched up correctly with the extra select pieces.  In this situation,
    you should use a ``django.utils.datastructures.SortedDict`` for the
    ``select`` value, not just a normal Python dictionary.

    This will work, for Exemplo::

        Blog.objects.extra(
            select=SortedDict([('a', '%s'), ('b', '%s')]),
            select_params=('one', 'two'))

    The only thing to be careful about when using select parameters in
    ``extra()`` is to avoid using the substring ``"%%s"`` (that's *two*
    percent characters before the ``s``) in the select strings. Django's
    tracking of parameters looks for ``%s`` and an escaped ``%`` character
    like this isn't detected. That will lead to incorrect results.

``where`` / ``tables``
    You can define explicit SQL ``WHERE`` clauses -- perhaps to perform
    non-explicit joins -- by using ``where``. You can manually add tables to
    the SQL ``FROM`` clause by using ``tables``.

    ``where`` and ``tables`` both take a list of strings. All ``where``
    parameters are "AND"ed to any other search criteria.

    Exemplo::

        Entry.objects.extra(where=['id IN (3, 4, 5, 20)'])

    ...translates (roughly) into the following SQL::

        SELECT * FROM blog_entry WHERE id IN (3, 4, 5, 20);

    Be careful when using the ``tables`` parameter if you're specifying
    tables that are already used in the query. When you add extra tables
    via the ``tables`` parameter, Django assumes you want that table included
    an extra time, if it is already included. That creates a problem,
    since the table name will then be given an alias. If a table appears
    multiple times in an SQL statement, the second and subsequent occurrences
    must use aliases so the database can tell them apart. If you're
    referring to the extra table you added in the extra ``where`` parameter
    this is going to cause errors.

    Normally you'll only be adding extra tables that don't already appear in
    the query. However, if the case outlined above does occur, there are a few
    solutions. First, see if you can get by without including the extra table
    and use the one already in the query. If that isn't possible, put your
    ``extra()`` call at the front of the queryset construction so that your
    table is the first use of that table. Finally, if all else fails, look at
    the query produced and rewrite your ``where`` addition to use the alias
    given to your extra table. The alias will be the same each time you
    construct the queryset in the same way, so you can rely upon the alias
    name to not change.

``order_by``
    If you need to order the resulting queryset using some of the new fields
    or tables you have included via ``extra()`` use the ``order_by`` parameter
    to ``extra()`` and pass in a sequence of strings. These strings should
    either be model fields (as in the normal ``order_by()`` method on
    querysets), of the form ``table_name.column_name`` or an alias for a column
    that you specified in the ``select`` parameter to ``extra()``.

    For Exemplo::

        q = Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})
        q = q.extra(order_by = ['-is_recent'])

    This would sort all the items for which ``is_recent`` is true to the front
    of the result set (``True`` sorts before ``False`` in a descending
    ordering).

    This shows, by the way, that you can make multiple calls to
    ``extra()`` and it will behave as you expect (adding new constraints each
    time).

``params``
    The ``where`` parameter described above may use standard Python database
    string placeholders -- ``'%s'`` to indicate parameters the database engine
    should automatically quote. The ``params`` argument is a list of any extra
    parameters to be substituted.

    Exemplo::

        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

    Always use ``params`` instead of embedding values directly into ``where``
    because ``params`` will ensure values are quoted correctly according to
    your particular backend. (For example, quotes will be escaped correctly.)

    Bad::

        Entry.objects.extra(where=["headline='Lennon'"])

    Good::

        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

Métodos do QuerySet que não retornam QuerySets
----------------------------------------------

Os seguintes métodos do ``QuerySet`` avaliam o ``QuerySet`` e retornam *algo*
diferente de um ``QuerySet``.

Estes métodos não usam um cache (veja :ref:`caching-and-querysets`). Ao invés,
eles consultam o banco de dados toda vez que são chamados.

.. _get-kwargs:

``get(**kwargs)``
~~~~~~~~~~~~~~~~~

Retorna o objeto combinado com o dado parametro, que deve estar no formato
descrito em `Campos de pesquisa`_.

O ``get()`` lança um ``MultipleObjectsReturned`` se mais de um objeto for
encontrado. A exceção ``MultipleObjectsReturned`` é um atributo da classe model.

O ``get()`` lança uma exceção ``DoesNotExist`` se um objeto não foi encontrado
para os parametros dados. Esta exceção também é um atributo da classe model.
Exemplo::

    Entry.objects.get(id='foo') # raises Entry.DoesNotExist

A exceção ``DoesNotExist`` herda do
``django.core.exceptions.ObjectDoesNotExist``, então você pode atingir várias
exceções ``DoesNotExist``. Exemplo::

    from django.core.exceptions import ObjectDoesNotExist
    try:
        e = Entry.objects.get(id=3)
        b = Blog.objects.get(id=1)
    except ObjectDoesNotExist:
        print "Ou entry ou blog não existe."

``create(**kwargs)``
~~~~~~~~~~~~~~~~~~~~

Um método conveniente para criar um objeto e salvá-lo em um passo. Deste modo::

    p = Person.objects.create(first_name="Bruce", last_name="Springsteen")

e::

    p = Person(first_name="Bruce", last_name="Springsteen")
    p.save(force_insert=True)

são equivalentes.

The :ref:`force_insert <ref-models-force-insert>` parameter is documented
elsewhere, but all it means is that a new object will always be created.
Normally you won't need to worry about this. However, if your model contains a
manual primary key value that you set and if that value already exists in the
database, a call to ``create()`` will fail with an ``IntegrityError`` since
primary keys must be unique. So remember to be prepared to handle the
exception if you are using manual primary keys.

``get_or_create(**kwargs)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Um método conveniente para procurar um objeto com os argumentos, e criá-lo se
necessário.

Retorna um tupla de ``(object, created)``, onde ``object`` é objeto recebido ou
criado e ``created`` é um booleano especificando se um novo objeto foi criado.

Isto age como um atalho de código e é mais útil para scripts de importação de
dados. Por exemplo::

    try:
        obj = Person.objects.get(first_name='John', last_name='Lennon')
    except Person.DoesNotExist:
        obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
        obj.save()

This pattern gets quite unwieldy as the number of fields in a model goes up.
The above example can be rewritten using ``get_or_create()`` like so::

    obj, created = Person.objects.get_or_create(first_name='John', last_name='Lennon',
                      defaults={'birthday': date(1940, 10, 9)})

Any keyword arguments passed to ``get_or_create()`` -- *except* an optional one
called ``defaults`` -- will be used in a ``get()`` call. If an object is found,
``get_or_create()`` returns a tuple of that object and ``False``. If an object
is *not* found, ``get_or_create()`` will instantiate and save a new object,
returning a tuple of the new object and ``True``. The new object will be
created roughly according to this algorithm::

    defaults = kwargs.pop('defaults', {})
    params = dict([(k, v) for k, v in kwargs.items() if '__' not in k])
    params.update(defaults)
    obj = self.model(**params)
    obj.save()

In English, that means start with any non-``'defaults'`` keyword argument that
doesn't contain a double underscore (which would indicate a non-exact lookup).
Then add the contents of ``defaults``, overriding any keys if necessary, and
use the result as the keyword arguments to the model class. As hinted at
above, this is a simplification of the algorithm that is used, but it contains
all the pertinent details. The internal implementation has some more
error-checking than this and handles some extra edge-conditions; if you're
interested, read the code.

Se você tem um campo chamado ``defaults`` e quer usá-lo numa pesquisa exata no
``get_or_create()``, é só usar ``'defaults__extact'``, desta forma::

    Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})

The ``get_or_create()`` method has similar error behaviour to ``create()``
when you are using manually specified primary keys. If an object needs to be
created and the key already exists in the database, an ``IntegrityError`` will
be raised.

Finally, a word on using ``get_or_create()`` in Django views. As mentioned
earlier, ``get_or_create()`` is mostly useful in scripts that need to parse
data and create new records if existing ones aren't available. But if you need
to use ``get_or_create()`` in a view, please make sure to use it only in
``POST`` requests unless you have a good reason not to. ``GET`` requests
shouldn't have any effect on data; use ``POST`` whenever a request to a page
has a side effect on your data. For more, see `Safe methods`_ in the HTTP spec.

.. _Safe methods: http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1

``count()``
~~~~~~~~~~~

Retorna um inteiro representando o número de objetos no banco de dados
combinando com o ``QuerySet``. O ``count()`` nunca lança exceções.

Exemplo::

    # Retorna o numero total de entradas no banco de dados.
    Entry.objects.count()

    # Retorna o número de entradas cujo headline contém 'Lennon'
    Entry.objects.filter(headline__contains='Lennon').count()

O ``count()`` realiza um ``SELECT COUNT(*)`` por trás das cenas, então você deve
sempre usar ``count()`` ao invés de carregar todos os objetos do banco e chamar
``len()`` sobre o resultado.

Dependendo de qual banco de dados você estiver usando (e.g. PostgreSQL vs.
MySQL), ``count()`` pode retornar um inteiro long ao invés de um inteiro normal
do Python. Esta é uma implementação evasiva subjacente que não deve causar
quaisquer problemas no mundo real.

``in_bulk(id_list)``
~~~~~~~~~~~~~~~~~~~~

Recebe uma lista de valores de chaves primárias e retorna um dicionário mapeando
cada valor de chave primária para uma instância de objeto com o dado ID.

Exemplo::

    >>> Blog.objects.in_bulk([1])
    {1: <Blog: Beatles Blog>}
    >>> Blog.objects.in_bulk([1, 2])
    {1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>}
    >>> Blog.objects.in_bulk([])
    {}

Se você passar ao ``in_bulk()`` uma lista vazia, você terá um dicionário vazio.

``iterator()``
~~~~~~~~~~~~~~

Avalia o ``QuerySet`` (para realizar uma consulta) e retorna um `iterador`_
sobre os resultados. Um ``QuerySet`` tipicamente lê todos os seus resultados e
instancia todos os objetos correspondentes na primeira vez que você acessá-los;
o ``iterator()``, no entanto, lerá os resultados e instanciará objetos em
pedaços discretos, fornecendo-os um por vez. Para um ``QuerySet`` que retorna um
número grande de objetos, este frequentemente resulta em melhor performance e
redução significante no uso de memória.

Note que usando o ``iterator()`` sobre um ``QuerySet`` que já foi avaliado, irá
forçá-lo a avaliá-lo novamente, repetindo a consulta.

.. _iterador: http://www.python.org/dev/peps/pep-0234/

``latest(field_name=None)``
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Retorna o último objeto na tabela, por data, usando o ``field_name`` fornecido
como o campo de data.

Este exemplo retorna a última ``Entry`` na tabela, de acordo com o campo
``pub_date``::

    Entry.objects.latest('pub_date')

Se o ``Meta`` do seu model especifica ``get_latest_by``, você pode deixar vazio
o argumento ``field_name`` do ``latest()``. O Django usará o campo especificado
em `get_latest_by`` por padrão.

Assim como ``get()``, ``latest()`` lançam ``DoesNotExist`` se um objeto não existe com
os paramêtros fornecidos.

Note que ``latest()`` existe puramente por conveniência e legibilidade.

.. _field-lookups:

Campos de Pesquisa
------------------

Campos de pesquis são como você especifica o cerne de uma cláusula SQL
``WHERE``. Eles são especificados como argumentos nomeados dos métodos do
``QuerySet`` ``filter()``, ``exclude()`` e ``get()``.

Para uma introdução, veja :ref:`field-lookups-intro`.

exact
~~~~~

Combinação exata. Se o valor fornecido para comparação for ``None``, ele será
interpretado como um SQL ``NULL`` (Veja isnull_ para mais detalhes).

Exemplos::

    Entry.objects.get(id__exact=14)
    Entry.objects.get(id__exact=None)

SQL equivalente::

    SELECT ... WHERE id = 14;
    SELECT ... WHERE id IS NULL;

.. versionchanged:: 1.0
   A semântica de ``id__exact=None`` mudou no Django 1.0. Anteriormente, ela era
   (intencionalmente) convetido para ``WHERE id = NULL`` a nível de SQL, o que
   nunca combinaria com nada. Agora ela foi mudada para fazer o mesmo utilizando
   ``id__isnull=True``.

.. admonition:: MySQL comparisons

    No MySQL, uma configuração de "collation" de tabela do banco de dados
    determina se comparações ``exact`` são sensíveis a maiúsculas. Essa é uma
    configuração de banco de dados, *não* uma configuração do Django. É possível
    configurar suas tabelas MySQL para usar a comparação sensível a maiúsculas,
    mas algumas pecinhas estão envolvidas. Para mais informação sobre isto, veja
    a :ref:`seção collation <mysql-collation>` na documentação de
    :ref:`banco de dados <ref-databases>`.


iexact
~~~~~~

Combinação exata sensível a maiúsculas.

Exemplo::

    Blog.objects.get(name__iexact='beatles blog')

SQL equivalente::

    SELECT ... WHERE name ILIKE 'beatles blog';

Note que isto combinará ``'Beatles Blog'``, ``'beatles blog'``, ``'BeAtLes
BLoG'``, etc.

.. admonition:: SQLite users

    Quando estiver usando o backend SQLite e strings Unicode (não ASCII), tenha
    em mente a :ref:`anotação de banco de dados <sqlite-string-matching>` sobre
    comparação de strings. O SQLite não faz checagem não sensivel a maiúsculas
    em strings Unicode.

contains
~~~~~~~~

Teste de contimento sensível a maiúsculas.

Exemplo::

    Entry.objects.get(headline__contains='Lennon')

SQL equivalente::

    SELECT ... WHERE headline LIKE '%Lennon%';

Note que este combinará o headline  ``'Today Lennon honored'`` mas não
``'today lennon honored'``.

O SQLite não suporta regras ``LIKE`` sensíveis a maiúsculas; ``contains`` age
como ``icontains`` no SQLite.

icontains
~~~~~~~~~

Teste de contimento insensível a maiúsculas.

Exemplo::

    Entry.objects.get(headline__icontains='Lennon')

SQL equivalente::

    SELECT ... WHERE headline ILIKE '%Lennon%';

.. admonition:: SQLite users

    Quando estiver usando o backend SQLite e strings Unicode (não ASCII), tenha
    em mente a :ref:`anotação de banco de dados <sqlite-string-matching>` sobre
    comparação de strings.

in
~~

Numa dada lista.

Exemplo::

    Entry.objects.filter(id__in=[1, 3, 4])

SQL equivalente::

    SELECT ... WHERE id IN (1, 3, 4);

Você pode também usar um queryset para avaliar dinamicamente a lista de valores
ao invés de fornecer uma lista de valores literais. O queryset deve ser reduzido
a uma lista de valores individuais usando o método ``values()``, e então
convertido dentro de uma consulta usando o atributo ``query``::

    q = Blog.objects.filter(name__contains='Cheddar').values('pk').query
    e = Entry.objects.filter(blog__in=q)

.. warning::

    Este atributo ``query`` deve ser considerado um atributo interno opaco. É
    legal usá-lo como acima, mas sua API pode mudar entre as versões do Django.

Este queryset será avaliado como uma regra de subselect::

    SELECT ... WHERE blog.id IN (SELECT id FROM ... WHERE NAME LIKE '%Cheddar%')

gt
~~

Maior que.

Exemplo::

    Entry.objects.filter(id__gt=4)

SQL equivalente::

    SELECT ... WHERE id > 4;

gte
~~~

Maior ou igual a.

lt
~~

Menor que.

lte
~~~

Menor ou igual a.

startswith
~~~~~~~~~~

Começa com sensível a maiúsculas.

Exemplo::

    Entry.objects.filter(headline__startswith='Will')

SQL equivalente::

    SELECT ... WHERE headline LIKE 'Will%';

O SQLite não suporta regras ``LIKE`` sensíveis a maiúsculas; o ``startswith``
age como ``istartswith`` no SQLite.

istartswith
~~~~~~~~~~~

Começa com insensível a maiúsculas.

Exemplo::

    Entry.objects.filter(headline__istartswith='will')

SQL equivalente::

    SELECT ... WHERE headline ILIKE 'Will%';

.. admonition:: SQLite users

    Quando estiver usando o backend SQLite e strings Unicode (não ASCII), tenha
    em mente a :ref:`anotação de banco de dados <sqlite-string-matching>` sobre
    comparação de strings.

endswith
~~~~~~~~

Termina com sensível a maiúsculas.

Exemplo::

    Entry.objects.filter(headline__endswith='cats')

SQL equivalente::

    SELECT ... WHERE headline LIKE '%cats';

O SQLite não suporta regras ``LIKE`` sensíveis a maiúsculas; o ``endswith``
age como ``iendswith`` no SQLite.

iendswith
~~~~~~~~~

Termina com insensível a maiúsculas.

Exemplo::

    Entry.objects.filter(headline__iendswith='will')

SQL equivalente::

    SELECT ... WHERE headline ILIKE '%will'

.. admonition:: SQLite users

    Quando estiver usando o backend SQLite e strings Unicode (não ASCII), tenha
    em mente a :ref:`anotação de banco de dados <sqlite-string-matching>` sobre
    comparação de strings.

range
~~~~~

Teste de faixa (inclusivo).

Exemplo::

    start_date = datetime.date(2005, 1, 1)
    end_date = datetime.date(2005, 3, 31)
    Entry.objects.filter(pub_date__range=(start_date, end_date))

SQL equivalente::

    SELECT ... WHERE pub_date BETWEEN '2005-01-01' and '2005-03-31';

Você pode usar ``range`` onde você puder usar ``BETWEEN`` no SQL -- para datas,
números ou mesmo caracteres.

year
~~~~

Para campos date/datetime, combinação exata de ano. Recebe um ano com quatro
dígitos.

Exemplo::

    Entry.objects.filter(pub_date__year=2005)

SQL equivalente::

    SELECT ... WHERE EXTRACT('year' FROM pub_date) = '2005';

(A sintaxe exata do SQL varia para cada motor de banco de dados.)

month
~~~~~

Para campos date/datetime, combinação exata de mês. Recebe um inteiro 1
(Janeiro) até 12 (Dezembro).

Exemplo::

    Entry.objects.filter(pub_date__month=12)

SQL equivalente::

    SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';

(A sintaxe exata do SQL varia para cada motor de banco de dados.)

day
~~~

Para campos date/datetime, combinação exata de dia.

Exemplo::

    Entry.objects.filter(pub_date__day=3)

SQL equivalente::

    SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';

(A sintaxe exata do SQL varia para cada motor de banco de dados.)

Note que isto combinará com qualquer dado com um pub_date no terceiro dia do
mês, como Janeiro 3, Julho 3, etc.

isnull
~~~~~~

Recebe um ``True`` ou ``False``, que coresponde a consultas SQL ``IS NULL`` e
``IS NOT NULL``, respectivamente.

Exemplo::

    Entry.objects.filter(pub_date__isnull=True)

SQL equivalente::

    SELECT ... WHERE pub_date IS NULL;

search
~~~~~~

Um booleano de busca full-text, recebendo vantagem do indexamento full-text.
Este é como o ``contains`` mas é significativamente mais rápido, devido ao
indexamento full-text.

Exemplo::

    Entry.objects.filter(headline__search="+Django -jazz Python")

SQL equivalente::

    SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);

Note que isso somente está disponível no MySQL e requer manipulação direta do
banco de dados para adicionar o index full-text. Por padrão o Django usa
BOOLEAN MODE nas buscas em full-text. `Por favor verifique a documentação do
MySQL para detalhes adicionais.
<http://dev.mysql.com/doc/refman/5.1/en/fulltext-boolean.html>`_


regex
~~~~~

.. versionadded:: 1.0

Combinação por expressão regular sensível a maiúsculas.

A sintaxe de expressão regular é a que o beckend do banco de dados usa. No caso
do SQLite, que não suporta nativamente, pesquisa com expressões regulares, a
sintaxe é a do módulo Python ``re``.

Exemplo::

    Entry.objects.get(title__regex=r'^(An?|The) +')

SQL equivalentes::

    SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL

    SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'c'); -- Oracle

    SELECT ... WHERE title ~ '^(An?|The) +'; -- PostgreSQL

    SELECT ... WHERE title REGEXP '^(An?|The) +'; -- SQLite

Using raw strings (e.g., ``r'foo'`` instead of ``'foo'``) for passing in the
regular expression syntax is recommended.

iregex
~~~~~~

.. versionadded:: 1.0

Combinação por expressão regular insensível a maiúsculas.

Exemplo::

    Entry.objects.get(title__iregex=r'^(an?|the) +')

SQL equivalentes::

    SELECT ... WHERE title REGEXP '^(an?|the) +'; -- MySQL

    SELECT ... WHERE REGEXP_LIKE(title, '^(an?|the) +', 'i'); -- Oracle

    SELECT ... WHERE title ~* '^(an?|the) +'; -- PostgreSQL

    SELECT ... WHERE title REGEXP '(?i)^(an?|the) +'; -- SQLite

