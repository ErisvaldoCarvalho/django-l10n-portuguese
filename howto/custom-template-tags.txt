..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11332 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _howto-custom-template-tags:

=========================================
Tags e filtros de template personalizados
=========================================

Introdução
==========

O sistema de template do Django vem com uma larga variedade de :ref:`tags e
filtros embutidos <ref-templates-builtins>` projetados para direcionar a lógida
da apresentação que sua aplicação. Todavia, você pode se encontrar precisando de
funcionalidades que não são cobertas pelo conjunto de primitivas de template.
Você pode extender o motor de template definindo tags e filtros personalizados
usando Python, e então torná-los disponíveis aos seus templates usando a tag
``{% load %}``.

Layout do código
----------------

Tags e filtros de template customizados devem estar dentro de uma Django app. Se
elas estão relacionadas a uma app existente, faz mais sentido estarem
empacotados na app; caso contrário, você deveria criar uma nova app para
armazená-los.

A app deve conter um diretório ``templatetags``, no mesmo nível do
``models.py``, ``views.py``, etc. Se ele não existe ainda, é só criá-lo - não
esqueça o arquivo ``__init__.py`` para assegurar que o diretório seja tratado
como um pacote Python.

Suas tags e filtros personalizados ficaram nesse módulo dentro do diretório
``templatetags``. O nome do arquivo do módulo é o nome que você usará para
carregar as tags depois, então seja cuidadoso ao criar um nome que não colida
com as tags e filtros de outras apps.

Por exemplo, se sua tags/filtros estão num arquivo chamado ``poll_extras.py``,
o layout de sua app deve parecer com isso::

    polls/
        models.py
        templatetags/
            __init__.py
            poll_extras.py
        views.py

E nos seus templates você poderia usar o seguinte:

.. code-block:: html+django

    {% load poll_extras %}

A app que contém as tags personalizadas deve estar no :setting:`INSTALLED_APPS`
para que a tag ``{% load %}`` funcione. Esta é uma medida de segunrança: Ela
permite que você armazene código Python para muitas bibliotecas de template num
único servidor, sem permitir o acesso a todas elas para toda instalação do
Django.

Não há limites de quantos módulos você pode colocar no pácote ``templatetags``.
Só tenha em mente que uma declaração ``{% load %}`` carregará tags/filtros para
uma dado nome de módulo Python, não o nome da app.

Para uma biblioteca de tag ser válida, o módulo deve conter uma variável chamada
``register`` que é uma instância do ``templates.Library``, na qual todas as tags
e filtros são registrados. Então, no topo de seu módulo, coloque o seguinte::

    from django import template

    register = template.Library()

.. admonition:: Por trás das cenas

    Para uma tonelada de exemplos, leia o código font dos filtros e tags padrão
    do Django. Eles estão em ``django/templates/defaultfilters.py`` e
    ``django/template/defaulttags.py``, respectivamente.


Escrevendo filtros de template personalizados
---------------------------------------------

Filtros personalizados são como funções Python que recebem um ou dois
argumentos:

    * O valor de uma variável (input) -- não necessariamente uma string.
    * O valor de um argumento -- este pode ter um valor padrão, ou ser deixado
      de fora.

Por exemplo, no filtro ``{{ var|foo:"bar"}}``, ao filtro ``foo`` seria passado
a variável ``var`` e o argumento ``"bar"``.

Funções filtro devem sem retornar algo. Elas não lançam exceções. Elas falham
silenciosamente. No caso de um erro, elas devem retornar a entrada original ou
uma string vazia -- o que fizer mais sentido.

Aqui temos um exemplo de definição de filtro::

    def cut(value, arg):
        "Remove todos os valores do arg da string fornecida."
        return value.replace(arg, '')

E aqui tem um exemplo de como este filtro poderia ser usado:

.. code-block:: html+django

    {{ somevariable|cut:"0" }}

A maioria dos filtros não recebem argumentos. Neste caso, é só deixar o
argumento fora de sua função. Exemplo::

    def lower(value): # Somente um argumento.
        "Converte uma string para minúsculo"
        return value.lower()

Filtros de template que esperam strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se você estiver escrevendo um filtro de template que somente expera uma string
como o primeiro argumento, você deve usar o decorador ``stringfilter``. Este
converterá um objeto para seu valor em string antes de ser passado para a sua
função::

    from django.template.defaultfilters import stringfilter

    @stringfilter
    def lower(value):
        return value.lower()

Desta forma, você será poderá passar, digo, um inteiro para este filtro, e ele
não causará um ``AttributeError`` (pois inteiros não possuem métodos
``lower()``).

Registrando filtros personalizados
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Uma vez que tenha escrito sua definição de filtro, você precisa registrá-lo na
sua instância ``Library``, para torná-lo disponível na linguagem de template do
Django::

    register.filter('cut', cut)
    register.filter('lower', lower)

O método ``Library.filter()`` recebe dois argumentos:

    1. O nome do filtro -- uma string.
    2. A função de compilação -- uma função Python (não o nome da função como
       uma string).

Se você estiver usando Python 2.4 ou superior, você pode usar
``register.filter()`` como um decorador, no entanto::

    @register.filter(name='cut')
    @stringfilter
    def cut(value, arg):
        return value.replace(arg, '')

    @register.filter
    @stringfilter
    def lower(value):
        return value.lower()

Se você deixa desligado o argumento ``name``, como no segundo exemplo acima, o
Django usará o nome da função como o nome do filtro.

Filtros e auto-escaping
~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

Quando esiver escrevendo um filtro personalizado, pense um pouco em como o
filtro irá interagir com o comportamento de auto-escaping do Django. Note que há
três tipos de strings que podem ser passadas por dentro de um código de
template:

    * **Strings puras** são tipos nativos do Python ``str`` ou ``unicode``. Na
      saída, elas são escapadas se o auto-escaping estiver em efeito e
      apresenta-se inalterado.

    * **Strings seguras** são strings que foram marcadas como seguras por um
      escape fora de tempo. Qualquer escape necessário já foi feito.
      Elas são comumente usados para a saída que contém HTML puro que destina-se
      a ser interpretado, assim como está, no lado do cliente.

      Internamente, estas strings são do typo ``SafeString`` ou ``SafeUnicode``.
      Elas compartilham uma classe básica comum de ``SafeData``, então você pode
      testá-las usando um código como este::

          if isinstance(value, SafeData):
              # Faça algo com a string "safe".

    * **Strings marcadas como "precisando escapar"** são *sempre* escapadas na
      saída, indiferente se elas estão num bloco ``autoescape`` ou não.
      Essas strings são somente escapadas uma vez, contudo, mesmo se o
      auto-escaping se aplica.

      Internamente, estas strings são do tipo ``EscapeString`` ou
      ``EscapeUnicode``. Geralmente você não tem de se preocupar com eles; eles
      existem para implementação do filtro ``escape``.

Código de filtros de template caem em uma de duas situações:

    1. Seu filtro não introduz quaisquer caracteres HTML não seguros (``<``,
       ``>``, ``'``, ``"`` or ``&``) no resultado que ainda não foi
       aprensentado. Neste caso, você pode deixar o Django se preocupar com todo
       o auto-escaping por você. Tudo que você precisa fazer é colocar o
       atributo ``is_safe`` sobre o sua função filtro e setá-lo como ``True``,
       assim::

           @register.filter
           def myfilter(value):
               return value
           myfilter.is_safe = True

       Este atributo diz ao Django que se uma string "safe" é passada para o seu
       filtro, o resultado será mantido "safe" e se uma string não-safe é
       passada, o Django automaticamente a escapará, se necessário.

       Você pode pensar que nisso como significando "este filtro é seguro --
       ele não introduz qualquer possibilidade de HTML não seguro."

       A razão de ``is_safe`` ser necessário é porque há abundância de
       operadores de string normais que tornarão um objeto ``SafeData`` uma
       string normal ``str`` ou ``unicode`` e, ao invés de tentar pegá-los
       todos, o que será muito difícil, o Django repara o dano depois que o
       filtro foi completado.

       Por exemplo, suponhamos que você tem um filtro que adiciona uma string
       ``xx`` no final de uma entrada. Já que isso não introduz caracteres HTML
       perigosos ao resultado (com exceção de alguns que já estavam presentes),
       você deve marcar seu filtro com ``is_safe``::

           @register.filter
           def add_xx(value):
               return '%sxx' % value
           add_xx.is_safe = True

       Quando este filtro é usado num template onde auto-escaping está
       habilitado, o Django escapa a saída sempre que a entrada já não estiver
       marcada como "safe".

       Por padrão, ``is_safe`` é ``False``, e você pode omiti-lo de qualquer
       filtro onde ele não é requerido.

       Seja cuidadoso quando decidir se seu filtro realmente deixa strings safe
       como safe. Se estiver *removendo* caracteres, você pode inadvertidamente
       deixa tabs HTML desbalanceadas ou entidades no resultado. Por exemplo,
       removendo um ``>`` de uma entrada por tornar um ``<a>`` em ``<a``, que
       seria necessário escapar na saída para evitar problemas. Similarmente,
       remover um ponto-e-vírgula (``;``) pode transformar um ``&amp;`` em
       ``&amp``, que não é uma entidade válida e isso precisa ser escapado. Na
       maioria dos casos não será tão complicado, mas mantenha o olho aberto
       quanto a problemas como esse ao revisar o seu código.

       Marcando um filtro como ``is_safe`` forçará o valor de retorno do filtro
       a ser uma string. Se seu filtro deve retornar um booleano ou outro
       valor não string, marcando-o ``is_safe`` provavelmente terá consequências
       intencionais (como uma conversão do booleano False para uma string
       'False').

    2. Alternativamente, o código do seu filtro pode manualmente se preocupar
       com qualquer escape. Isso é necessário quando você estiver introduzindo
       uma nova marcação HTML dentro do resultado. Você quer marcar a saída de
       escape como seguro de forma que sua marcação HTML não foi escapada,
       então você precisará manipular a saída você mesmo.

       Para marcar a saída como uma string safe, use
       :func:`django.utils.safestring.mark_safe`.

       Seja cuidadoso, contudo. Você precisa fazer mais do que somente marcar a
       saída como safe. Você precisa assegurar-se de que realmente *é* safe, e o
       que você faz depende de se auto-escaping está em vigor. A idéia é
       escrever filtros que possam operar nos templates onde auto-escaping está
       ligado ou desligado para tornar as coisas mais fáceis para os seus
       autores de template.

       A fim de seu filtro saber o estado de auto-escaping atual, configure o
       atributo ``needs_autoescape`` como ``True`` na sua função. (Se você não
       especificar este atributo, o padrão é ``False``). Este atributo diz ao
       Django que sua função filtro espera um argumento extra, chamado
       ``autoescape``, que é ``True`` se auto-escaping está em vigor é ``False``
       caso contrário.

       Por exemplo, vamos escrever um filtro que emfatiza o primeiro caracter de
       uma string::

           from django.utils.html import conditional_escape
           from django.utils.safestring import mark_safe

           def initial_letter_filter(text, autoescape=None):
               first, other = text[0], text[1:]
               if autoescape:
                   esc = conditional_escape
               else:
                   esc = lambda x: x
               result = '<strong>%s</strong>%s' % (esc(first), esc(other))
               return mark_safe(result)
           initial_letter_filter.needs_autoescape = True

       The ``needs_autoescape`` attribute on the filter function and the
       ``autoescape`` keyword argument mean that our function will know whether
       automatic escaping is in effect when the filter is called. We use
       ``autoescape`` to decide whether the input data needs to be passed
       through ``django.utils.html.conditional_escape`` or not. (In the latter
       case, we just use the identity function as the "escape" function.) The
       ``conditional_escape()`` function is like ``escape()`` except it only
       escapes input that is **not** a ``SafeData`` instance. If a ``SafeData``
       instance is passed to ``conditional_escape()``, the data is returned
       unchanged.

       Finalmente, no exemplo acima, nós lembramos de marcar o resultado como
       safe, para que nosso HTML seja inserido diretamente dentro do template
       sem escape adicional.

       Não há necessidade de se preocupar com o atributo ``is_safe`` neste
       caso (embora não inclua não doerá nada). Sempre que você manipular
       manualmente as questões de auto-escaping e retornar uma string safe, o
       atributo ``is_safe`` não mudará nada de qualquer forma.

Escrevendo tags de template personalizado
-----------------------------------------

Tags são mais complexas que filtros, porquê tags podem fazer qualquer coisa.

Uma rápida visão geral
~~~~~~~~~~~~~~~~~~~~~~

Acima, nesse documento é explicado que o sistema de template funciona num
processo de dois passos: compilação e renderização. Para definir uma tag de
template personalizada, você especifica com a compilação funciona e como a
renderização funciona.

Quando o Django compila um template, ele divide o texto do template puro dentro
de ''nodes''. Cada nodo é uma instância do ``django.template.Node`` e tem um
método ``render()``. Um template compilado é, simplesmente, uma lista de objetos
``Node``. Quando você chama ``render()`` sobre um objeto de template compilado,
o template chama ``render()`` em cada ``Node`` na sua lista, com o dado
contexto. Os resultados são todos concatenados para formar a saída do template.

Deste modo, para definir uma tag de template personalizada, você especifica como
o template puro é convertido num ``Node`` (a função compilação), e o que o
método ``render()`` do nodo faz.

Escrevendo a função de compilação
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Para cada template tag o parser de template encontra, ele chama uma função
Python com o conteúdo da tag e o objeto parser em si. Esta função é responsável
por retornar uma instância ``Node`` baseado nos conteúdos da tag.

Por exemplo, vamos escrever uma template tag, ``{% current_time %}``, que mostra
o data/hora atual, formatado de acordo com o paramêtro dado na tag, na `sintaxe
do strftime`_. É uma boa idéia decidir a sintaxe da tag antes de qualquer outra
coisa. No nosso caso, vamos dizer que a tag deve ser usada desta forma:

.. code-block:: html+django

    <p>A hora é {% current_time "%Y-%m-%d %I:%M %p" %}.</p>

.. _`sintaxe do strftime`: http://docs.python.org/library/time.html#time.strftime

O parser para esta função deve abarrar o parâmetro e criar um objeto ``Node``::

    from django import template
    def do_current_time(parser, token):
        try:
            # split_contents() knows not to split quoted strings.
            tag_name, format_string = token.split_contents()
        except ValueError:
            raise template.TemplateSyntaxError, "%r tag requires a single argument" % token.contents.split()[0]
        if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
            raise template.TemplateSyntaxError, "%r tag's argument should be in quotes" % tag_name
        return CurrentTimeNode(format_string[1:-1])

Notes:

    * O ``parser`` é o objeto parser de template. Não não precisamos dele nesse
      exemplo.

    * O ``token.contents`` é uma string de conteúdos puros da tag. No nosso
      exemplo, é ``'current_time "%Y-%m-%d %I:%M %p"'``.

    * The ``token.split_contents()`` method separates the arguments on spaces
      while keeping quoted strings together. The more straightforward
      ``token.contents.split()`` wouldn't be as robust, as it would naively
      split on *all* spaces, including those within quoted strings. It's a good
      idea to always use ``token.split_contents()``.

    * Essa função é responsável por lançar
      ``django.template.TemplateSyntaxError``, com mensagens úteis, para
      qualquer erro de sintaxe.

    * The ``TemplateSyntaxError`` exceptions use the ``tag_name`` variable.
      Don't hard-code the tag's name in your error messages, because that
      couples the tag's name to your function. ``token.contents.split()[0]``
      will ''always'' be the name of your tag -- even when the tag has no
      arguments.

    * The function returns a ``CurrentTimeNode`` with everything the node needs
      to know about this tag. In this case, it just passes the argument --
      ``"%Y-%m-%d %I:%M %p"``. The leading and trailing quotes from the
      template tag are removed in ``format_string[1:-1]``.

    * The parsing is very low-level. The Django developers have experimented
      with writing small frameworks on top of this parsing system, using
      techniques such as EBNF grammars, but those experiments made the template
      engine too slow. It's low-level because that's fastest.

Escrevendo o renderizador
~~~~~~~~~~~~~~~~~~~~~~~~~

O segundo passo em escrever tags personalizadas é definir uma subclasse ``Node``
que tem um método ``render()``.

Continuando o exemplo acima, nós precisamos definir ``CurrentTimeNode``::

    from django import template
    import datetime
    class CurrentTimeNode(template.Node):
        def __init__(self, format_string):
            self.format_string = format_string
        def render(self, context):
            return datetime.datetime.now().strftime(self.format_string)

Notes:

    * ``__init__()`` gets the ``format_string`` from ``do_current_time()``.
      Always pass any options/parameters/arguments to a ``Node`` via its
      ``__init__()``.

    * The ``render()`` method is where the work actually happens.

    * ``render()`` should never raise ``TemplateSyntaxError`` or any other
      exception. It should fail silently, just as template filters should.

Ultimately, this decoupling of compilation and rendering results in an
efficient template system, because a template can render multiple contexts
without having to be parsed multiple times.

Auto-escaping considerations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

The output from template tags is **not** automatically run through the
auto-escaping filters. However, there are still a couple of things you should
keep in mind when writing a template tag.

If the ``render()`` function of your template stores the result in a context
variable (rather than returning the result in a string), it should take care
to call ``mark_safe()`` if appropriate. When the variable is ultimately
rendered, it will be affected by the auto-escape setting in effect at the
time, so content that should be safe from further escaping needs to be marked
as such.

Also, if your template tag creates a new context for performing some
sub-rendering, set the auto-escape attribute to the current context's value.
The ``__init__`` method for the ``Context`` class takes a parameter called
``autoescape`` that you can use for this purpose. For example::

    def render(self, context):
        # ...
        new_context = Context({'var': obj}, autoescape=context.autoescape)
        # ... Do something with new_context ...

This is not a very common situation, but it's useful if you're rendering a
template yourself. For example::

    def render(self, context):
        t = template.loader.get_template('small_fragment.html')
        return t.render(Context({'var': obj}, autoescape=context.autoescape))

If we had neglected to pass in the current ``context.autoescape`` value to our
new ``Context`` in this example, the results would have *always* been
automatically escaped, which may not be the desired behavior if the template
tag is used inside a ``{% autoescape off %}`` block.

Registering the tag
~~~~~~~~~~~~~~~~~~~

Finally, register the tag with your module's ``Library`` instance, as explained
in "Writing custom template filters" above. Example::

    register.tag('current_time', do_current_time)

The ``tag()`` method takes two arguments:

    1. The name of the template tag -- a string. If this is left out, the
       name of the compilation function will be used.
    2. The compilation function -- a Python function (not the name of the
       function as a string).

As with filter registration, it is also possible to use this as a decorator, in
Python 2.4 and above::

    @register.tag(name="current_time")
    def do_current_time(parser, token):
        # ...

    @register.tag
    def shout(parser, token):
        # ...

If you leave off the ``name`` argument, as in the second example above, Django
will use the function's name as the tag name.

Passing template variables to the tag
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Although you can pass any number of arguments to a template tag using
``token.split_contents()``, the arguments are all unpacked as
string literals. A little more work is required in order to pass dynamic
content (a template variable) to a template tag as an argument.

While the previous examples have formatted the current time into a string and
returned the string, suppose you wanted to pass in a ``DateTimeField`` from an
object and have the template tag format that date-time:

.. code-block:: html+django

    <p>This post was last updated at {% format_time blog_entry.date_updated "%Y-%m-%d %I:%M %p" %}.</p>

Initially, ``token.split_contents()`` will return three values:

    1. The tag name ``format_time``.
    2. The string "blog_entry.date_updated" (without the surrounding quotes).
    3. The formatting string "%Y-%m-%d %I:%M %p". The return value from
       ``split_contents()`` will include the leading and trailing quotes for
       string literals like this.

Now your tag should begin to look like this::

    from django import template
    def do_format_time(parser, token):
        try:
            # split_contents() knows not to split quoted strings.
            tag_name, date_to_be_formatted, format_string = token.split_contents()
        except ValueError:
            raise template.TemplateSyntaxError, "%r tag requires exactly two arguments" % token.contents.split()[0]
        if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
            raise template.TemplateSyntaxError, "%r tag's argument should be in quotes" % tag_name
        return FormatTimeNode(date_to_be_formatted, format_string[1:-1])

.. versionchanged:: 1.0
    Variable resolution has changed in the 1.0 release of Django. ``template.resolve_variable()``
    has been deprecated in favor of a new ``template.Variable`` class.

You also have to change the renderer to retrieve the actual contents of the
``date_updated`` property of the ``blog_entry`` object.  This can be
accomplished by using the ``Variable()`` class in ``django.template``.

To use the ``Variable`` class, simply instantiate it with the name of the
variable to be resolved, and then call ``variable.resolve(context)``. So,
for example::

    class FormatTimeNode(template.Node):
        def __init__(self, date_to_be_formatted, format_string):
            self.date_to_be_formatted = template.Variable(date_to_be_formatted)
            self.format_string = format_string

        def render(self, context):
            try:
                actual_date = self.date_to_be_formatted.resolve(context)
                return actual_date.strftime(self.format_string)
            except template.VariableDoesNotExist:
                return ''

Variable resolution will throw a ``VariableDoesNotExist`` exception if it cannot
resolve the string passed to it in the current context of the page.

Shortcut for simple tags
~~~~~~~~~~~~~~~~~~~~~~~~

Many template tags take a number of arguments -- strings or a template variables
-- and return a string after doing some processing based solely on
the input argument and some external information. For example, the
``current_time`` tag we wrote above is of this variety: we give it a format
string, it returns the time as a string.

To ease the creation of the types of tags, Django provides a helper function,
``simple_tag``. This function, which is a method of
``django.template.Library``, takes a function that accepts any number of
arguments, wraps it in a ``render`` function and the other necessary bits
mentioned above and registers it with the template system.

Our earlier ``current_time`` function could thus be written like this::

    def current_time(format_string):
        return datetime.datetime.now().strftime(format_string)

    register.simple_tag(current_time)

In Python 2.4, the decorator syntax also works::

    @register.simple_tag
    def current_time(format_string):
        ...

A couple of things to note about the ``simple_tag`` helper function:

    * Checking for the required number of arguments, etc., has already been
      done by the time our function is called, so we don't need to do that.
    * The quotes around the argument (if any) have already been stripped away,
      so we just receive a plain string.
    * If the argument was a template variable, our function is passed the
      current value of the variable, not the variable itself.

When your template tag does not need access to the current context, writing a
function to work with the input values and using the ``simple_tag`` helper is
the easiest way to create a new tag.

.. _howto-custom-template-tags-inclusion-tags:

Inclusion tags
~~~~~~~~~~~~~~

Another common type of template tag is the type that displays some data by
rendering *another* template. For example, Django's admin interface uses custom
template tags to display the buttons along the bottom of the "add/change" form
pages. Those buttons always look the same, but the link targets change depending
on the object being edited -- so they're a perfect case for using a small
template that is filled with details from the current object. (In the admin's
case, this is the ``submit_row`` tag.)

These sorts of tags are called "inclusion tags".

Writing inclusion tags is probably best demonstrated by example. Let's write a
tag that outputs a list of choices for a given ``Poll`` object, such as was
created in the :ref:`tutorials <creating-models>`. We'll use the tag like this:

.. code-block:: html+django

    {% show_results poll %}

...and the output will be something like this:

.. code-block:: html

    <ul>
      <li>First choice</li>
      <li>Second choice</li>
      <li>Third choice</li>
    </ul>

First, define the function that takes the argument and produces a dictionary of
data for the result. The important point here is we only need to return a
dictionary, not anything more complex. This will be used as a template context
for the template fragment. Example::

    def show_results(poll):
        choices = poll.choice_set.all()
        return {'choices': choices}

Next, create the template used to render the tag's output. This template is a
fixed feature of the tag: the tag writer specifies it, not the template
designer. Following our example, the template is very simple:

.. code-block:: html+django

    <ul>
    {% for choice in choices %}
        <li> {{ choice }} </li>
    {% endfor %}
    </ul>

Now, create and register the inclusion tag by calling the ``inclusion_tag()``
method on a ``Library`` object. Following our example, if the above template is
in a file called ``results.html`` in a directory that's searched by the template
loader, we'd register the tag like this::

    # Here, register is a django.template.Library instance, as before
    register.inclusion_tag('results.html')(show_results)

As always, Python 2.4 decorator syntax works as well, so we could have
written::

    @register.inclusion_tag('results.html')
    def show_results(poll):
        ...

...when first creating the function.

Sometimes, your inclusion tags might require a large number of arguments,
making it a pain for template authors to pass in all the arguments and remember
their order. To solve this, Django provides a ``takes_context`` option for
inclusion tags. If you specify ``takes_context`` in creating a template tag,
the tag will have no required arguments, and the underlying Python function
will have one argument -- the template context as of when the tag was called.

For example, say you're writing an inclusion tag that will always be used in a
context that contains ``home_link`` and ``home_title`` variables that point
back to the main page. Here's what the Python function would look like::

    # The first argument *must* be called "context" here.
    def jump_link(context):
        return {
            'link': context['home_link'],
            'title': context['home_title'],
        }
    # Register the custom tag as an inclusion tag with takes_context=True.
    register.inclusion_tag('link.html', takes_context=True)(jump_link)

(Note that the first parameter to the function *must* be called ``context``.)

In that ``register.inclusion_tag()`` line, we specified ``takes_context=True``
and the name of the template. Here's what the template ``link.html`` might look
like:

.. code-block:: html+django

    Jump directly to <a href="{{ link }}">{{ title }}</a>.

Then, any time you want to use that custom tag, load its library and call it
without any arguments, like so:

.. code-block:: html+django

    {% jump_link %}

Note that when you're using ``takes_context=True``, there's no need to pass
arguments to the template tag. It automatically gets access to the context.

The ``takes_context`` parameter defaults to ``False``. When it's set to *True*,
the tag is passed the context object, as in this example. That's the only
difference between this case and the previous ``inclusion_tag`` example.

Setting a variable in the context
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

O exemplo acima simplesmente mostra um valor. Geralmente, é mais flexível se
suas template tags configurarem variáveis ou invés de mostrar valores. Desta
forma os autores de templates podem reusar os valores que suas templates tags
criam.

Para setar uma variável no contexto, é só usar atribuição de dicionário no
contexto de objeto no método ``render()``. Aqui temos uma versão atualizada do
``CurrentTimeNode`` que configura uma variável de template ``current_time`` ao
invés de mostrá-la::

    class CurrentTimeNode2(template.Node):
        def __init__(self, format_string):
            self.format_string = format_string
        def render(self, context):
            context['current_time'] = datetime.datetime.now().strftime(self.format_string)
            return ''

Note que ``render()`` retorna uma string vazia. O ``render()`` deve sempre
retornar uma string. Se tudo o que a template tag faz é setar uma variável, o
``render()`` deve retornar uma string vazia.

Aqui temos como poderiámos usar esta nova versão de tag:

.. code-block:: html+django

    {% current_time "%Y-%M-%d %I:%M %p" %}<p>The time is {{ current_time }}.</p>

Porém, há um problema com ``CurrentTimeNode2``: O nome da variável
``current_time`` é nativo. Isso significa que você precisará
assegurar-se de que seu template não use ``{{ current_time }}`` em nenhum lugar
mais, por que o ``{% current_time %}`` será cegamente sobrescrito pelo valor
desta variável. Uma solução clara é fazer uma template tag especificar o nome da
variável de saída, desta forma::

.. code-block:: html+django

    {% get_current_time "%Y-%M-%d %I:%M %p" as my_current_time %}
    <p>The current time is {{ my_current_time }}.</p>

Para fazer isso, você precisar refatorar ambos funções de compilação e classe
``Node``, tipo::

    class CurrentTimeNode3(template.Node):
        def __init__(self, format_string, var_name):
            self.format_string = format_string
            self.var_name = var_name
        def render(self, context):
            context[self.var_name] = datetime.datetime.now().strftime(self.format_string)
            return ''

    import re
    def do_current_time(parser, token):
        # Essa versão usa uma expressão regular para parsear a o conteúdo da tag.
        try:
            # Separando None == separando por espaços.
            tag_name, arg = token.contents.split(None, 1)
        except ValueError:
            raise template.TemplateSyntaxError, "%r tag requires arguments" % token.contents.split()[0]
        m = re.search(r'(.*?) as (\w+)', arg)
        if not m:
            raise template.TemplateSyntaxError, "%r tag had invalid arguments" % tag_name
        format_string, var_name = m.groups()
        if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
            raise template.TemplateSyntaxError, "%r tag's argument should be in quotes" % tag_name
        return CurrentTimeNode3(format_string[1:-1], var_name)

A diferença aqui é que o ``do_current_time()`` pega a string de formato e o nome
da variável, passando ambos ao ``CurrenttimeNode3``.

Parseando até outro tag de bloco
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Template tags podem funcionar em conjunto. Por exemplo, a tag padrão
``{% comment %}`` esconde tudo até o ``{% endcomment %}``. Para criar uma
template tag como esta, use ``parser.parse()`` na sua função de compilação.

Aqui temos como a tag padrão ``{% comment %}`` é implementado::

    def do_comment(parser, token):
        nodelist = parser.parse(('endcomment',))
        parser.delete_first_token()
        return CommentNode()

    class CommentNode(template.Node):
        def render(self, context):
            return ''

O ``parser.parse()`` recebe uma tupla de nomes de tags de bloco ''para parsear
até ela''. Ela retorna uma instância do ``django.template.NodeList``, que é uma
lista de todos objetos ``Node`` que o parser encontrar ''antes'' de encontrar
quaisquer tags chamadas na tupla.

No ``"nodelist = parser.parse(('endcomment',))"`` do exemplo acima,
``nodelist`` é uma lista de todos os nodos entre o ``{% comment %}`` e
``{% endcomment %}``, não contando ``{% comment %}`` e ``{% endcomment %}``.

Depois que ``parser.parse()`` é chamado, o parser ainda não "consumiu" a tag
``{% endcomment %}``, assim o código precisa explicitamente chamar
``parser.delete_first_token()``.

O ``CommentNode.render()`` simplesmente retorna uma string vazia. Qualquer coisa
entre ``{% comment %}`` e ``{% endcomment %}`` é ignorado.

Parseando até outra tag de bloco, e salvando conteúdos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

No exemplo anterior, ``do_comment()`` tudo descartado entre ``{% comment %}`` e
``{% endcomment %}``. Ao invés de fazer isso, é possível fazer algo com o código
entre as tags de bloco.

Por exemplo, há uma template tag personalizada, ``{% upper %}``, que capitaliza
tudo entre ela mesma e ``{% endupper %}``.

Uso:

.. code-block:: html+django

    {% upper %}Isso irá aparecer em maiúsuclas, {{ your_name }}.{% endupper %}

Como no exemplo anterior, nós usaremos ``parser.parse()``. Mas dessa vez, nós
passamos o resultado ``nodelist`` para o ``Node``::

    def do_upper(parser, token):
        nodelist = parser.parse(('endupper',))
        parser.delete_first_token()
        return UpperNode(nodelist)

    class UpperNode(template.Node):
        def __init__(self, nodelist):
            self.nodelist = nodelist
        def render(self, context):
            output = self.nodelist.render(context)
            return output.upper()

O único conceito novo aqui é o ``self.nodelist.render(context)`` no
``UpperNode.render()``.

Para mais exemplos de complexidade de renderização, vej o código fonte
``{% if %}``, ``{% for %}``, ``{% ifequal %}`` e ``{% ifchanged %}``. Eles estão
em ``django/template/defaulttags.py``.

