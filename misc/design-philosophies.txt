..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: Done, waiting for revision. $
..   $OriginalRevision: 9368 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _misc-design-philosophies:

===================
Filosofia de design
===================

Este documento explica algumas filosofias fundamentais dos desenvolvedores 
do Django, que as tem usado na criação do framework. O objetivo é explicar o
passado e guiar para o futuro.

Em toda parte
=============

.. _loose-coupling:

Loose coupling
--------------

.. index:: coupling; loose

Um objetivo fundamental da pilha do Django é `loose coupling and tight cohesion`_.
As várias camadas do framework não devem saber saber sobre si, a menos que seja
absolutamente necessário.

Por exemplo, o sistema de template não saber nada sobre requisição Web, a camada
de banco de dados não sabe nada sobre visualização e sistema de visualização não
se preocupa com que sistema de template o programador está usando.

Apesar do Django vir com uma pilha completa por conveniencia, as peçãs de uma 
pilha são independentes de qualquer outra que possa existir.

.. _`loose coupling and tight cohesion`: http://c2.com/cgi/wiki?CouplingAndCohesion

.. _less-code:

Menos código
------------

Aplicações Django deveriam, se possível, usar menos código; elas deveriam fugir
do padrão. O Django deveria tirar pleno proveito das capacidades dinâmicas do 
Python, tais como a introspecção.

.. _quick-development:

Desenvolvimento ágil
--------------------

O ponto forte de um framework Web no século 21, é transformar um trabalho 
tedioso de desenvolvimento Web, mais rápido. O Django deve permitir um 
desenvolvimento Web incrivelmente rápido.

.. _dry:

Não repita a si mesmo - `Don't repeat yourself` (DRY)
-----------------------------------------------------

.. index::
   single: DRY
   single: Don't repeat yourself

Todo conceito distinto e/ou pedaço de dado deve existir em um, e somente em um, 
lugar. Redundância é ruim. Normalização é bom.

O framework, por uma razão, deve deduzir tão bem quanto possível as pequenas
possibilidades.

.. seealso::

    A `discussão sobre DRY no repositório Portland Pattern`__

    __ http://c2.com/cgi/wiki?DontRepeatYourself
    
.. _explicit-is-better-than-implicit:

Explícito é melhor que implícito
--------------------------------

Este, um `princípio do núcleo do Python`_, significa que o Django não deve fazer
muita "mágica". Mágica não deveria acontecer a menos que haja realmente uma boa
razão para ela. Vale a pena usar mágica somente se ele cria uma enorme 
conveniência inatingíveis de outras formas, e não é aplicada de uma forma que 
confunde desenvolvedores que estão tentando aprender a usar este recurso.

.. _`princípio do núcleo do Python`: http://www.python.org/dev/peps/pep-0020/

.. _consistency:

Consistência
------------

O framework deve ser consistente em todos os níveis. Consistência aplicá-se para
tudo desde o baixo-nível (estilo de código Python usado) até o alto-nível (a
"experiência" de uso do Django).

Modelos
=======

Explícito é melhor que implícito
--------------------------------

Os campos não devem assumir certos comportamentos baseado unicamente no nome 
do campo. Isto exige muito conhecimento de sistema e é propenso a erros.
Em vez disso, os comportamentos devem ser baseadas em argumentos palavra-chave 
e, em alguns casos, sobre o tipo do campo

Domínio incluem todas as lógicas
--------------------------------

Modelos devem encapsular todo aspecto de um "objeto", seguindo o padrão de 
desenho do Martin Fowler `Active Record`_.

É assim porquê ambos, dado representado por um modelo e informação sobre ele 
(seu nome legível por humanos, opções como ordenamento padrão, etc.), são 
definidos in uma classe de modelo; todas as informações necessárias para 
compreender um determinado modelo deve ser armazenado *no* modelo.

.. _`Active Record`: http://www.martinfowler.com/eaaCatalog/activeRecord.html

API de banco de dados
=====================

Os objetivos do núcleo da API de banco de dados são:

Eficiência de SQL
-----------------

Ele deve executar declarações SQL o mais rápido possível, e deve otimizar as
consultas internamente.

Esta é a razão pela qual os desenvolvedores devem executar ``save()`` 
explicitamente, em vez do framework salvar coisas por traz das cenas 
silenciosamente.

Esta também é a razão dos métodos ``selecte_related()`` ``QuerySet`` existirem.
É como um otimizador opcional de performance para o caso comum de selecionar
"tudo que está relacionado a um objeto".

Lapidar, poderosa sintaxe
-------------------------

A API de banco de dados deve permitir ricas, expressivas consultas em uma 
sintaxe mais simples possível. Ela não deve depender de outros módulos ou 
da importação de objetos auxiliares.

Joins devem ser executados automaticamente, por trás das cenas, quando 
necessário.

Todo objeto deve ser capaz de acessar todo conteúdo relacionado a ela. Este 
acesso deve funcionar nos dois sentidos.

Opção de usar SQL puro facilmente, quando necessário
----------------------------------------------------

O framework deve tornar fácil a escrita de SQL customizado -- consultas 
inteiras, ou simplesmente a clausula ``WHERE`` como paramêtros customizados para
chamada da API.

URL design
==========

Loose coupling
--------------

URLs nas aplicações Django não devem ser acopladas a códigos Python subjacentes.
Subordinando URLs a nomes de funções do Python é uma coisa ruim e feia de se
fazer.

Ao longo destas linhas, o sistema de URL do Django deve permitir que URLs para 
uma mesma aplicação sejam diferentes em diferentes contextos. Por exemplo, um
site pode ter notícias em ``/stories/``, enquanto outros caminho usado é ``/news/``.

Flexibilidade infinita
----------------------

URLs devem ser tão flexiveis quanto possível. Qualquer URL concebível deve ser
permitida.

Encorajar as melhores práticas
------------------------------

O framework deve tornar fácil (ou até mais fácil) o design de URLs bonitas.

Extensões de arquivos na URLs das páginas devem ser evitadas.

Vignette-style vírgulas em URLs merecem castigo servero.

.. _definitive-urls:

URLs definitivas
----------------

.. index:: urls; definitive

Técnicamente, ``foo.com/bar`` e ``foo.com/bar/`` são duas URLs diferentes, e 
robos de motores de busca (e alguns analizadores de trafego na Web) irão 
tratá-las como páginas separadas. O Django deve fazer um esforço para 
"normalizar" as URLs, a fim de que os robôs de motore de busca não se confundam.

Este é o raciocínio por trás da configuração :setting:`APPEND_SLASH`.

Sistema de template
===================

.. _separation-of-logic-and-presentation:

Separar a lógica da apresentação
--------------------------------

Nós vemos um sistema de template como uma ferramenta que controla a apresentação
e a lógica relacionada à apresentação -- e era isso. O sistema de template não
deve suportar funcionalidades que vão além de seu objetivo básico.

Se quiséssemos colocar tudo em moldes, deveríamos estar usando PHP. Estivemos 
lá, feito isso, estamos aqui. 

Desencorajar redundância
------------------------

A maioria dos Web sites dinâmicos utilizam algum tipo de design comum -- um
cabeçalho comum, rodapé, barra de navegação, etc. O sistema de template do 
Django deve tornar fácil de armazenar estes elementos em um único lugar, 
eliminando código duplicado.

Esta é a filosofia por trás da :ref:`herança de templates 
<template-inheritance>`.

Ser dissociado do HTML
----------------------

O sistema de template não deve ser projetado para gerar somente saída HTML. Ele
deve ser igualmente bom para geração de outros formatos baseados em texto, ou
só texto plano.

XML não deve ser usado como modelo de línguas
---------------------------------------------

.. index:: xml; suckiness of

Usando um motor de XML para fazer parse nos templates, introduz um novo mundo de 
erro humano na edição templates -- e incorre em um nível inaceitável de 
retro-modelo em transformação.

Presume competência do desinger
-------------------------------

O sistema de template não deve ser projetado de modo que necessariamente seja
exibido simpaticamente nos editores WYSIWYG, como o Dreamweaver. Isso é tão 
grave, que passa a ser uma limitação e não permitiria a sintaxe ser tão legal
como ela é. O Django espera que os autores de templates estejam confortáveis
editando HTML diretamente.

Trate espaços em branco obviamente
----------------------------------

O sistema de template não deve fazer coisas mágicas com espaços em branco. Se um
tempalte inclui espaços em branco, o sistema deve tratá-los como se trata um 
texto -- simplesmente mostre-o. Qualquer espaço em branco que não está em uma 
tag de template deve ser mostrada.

Não invente uma linguagem de programação
----------------------------------------

O sistema de template intencionalmente não permite o seguinte:

    * Atribuição de variáveis
    * Lógica avançada

O objetivo é não inventar uma linguagem de programação. O objetivo é oferecer
somente funcionalidades suficientes, como ramificações e laços, que são 
essenciais para se contruir decisões em apresentações relacionadas.

O sistema de template do Django reconhece que templates são mais frequentemente
escritos por *designers*, não *programadores*, e por isso não devem possuir
conhecimento em Python.

Segurança
---------

O sistema de template, fora da caixa, deve proíbir a inclusão de códigos 
maliciosos -- como comandos que deletam dados no banco de dados.

Esta é outra razão para o sistema de template não permitir código Python 
arbritário.

Extensibility
-------------

O sistema de template deve reconhecer que autores avançados de templates podem
querer extender sua tecnologia.

Está é a filosofia por trás das tags e filtros customizados dos templates.

Views
=====

Simplicidade
------------

Escrever uma view deve ser tão simples quanto escrever uma função Python. Os
desenvolvedores não deveriam ter que instanciar uma classe quando uma função já
irá fazê-lo.

Use objetos de requisição
-------------------------

Views devem ter acesso ao objeto `request` -- um objeto que armazena metadados 
sobre a requisição corrente. O objeto deve ser passado diretamente para a função
view, ao invés da função view ter quer acessar o request de uma variável global.
Isto se faz leve, limpo e fácil de testar visões passando-a objetos de 
requisição "falsos".

Loose coupling
--------------

Um view deveria se preocupar sobre qual sistema de template o desenvolvedor 
utiliza -- ou mesmo se ele usa algum sistema de template --.

Diferenciamento entre GET e POST
--------------------------------

GET é POST são distintos; os desenvolvedores devem explicitamente usar um ou o 
outro. O framework deve tornar a distinção fácil entre os dados GET e POST.
