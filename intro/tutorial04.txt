..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9368 $
..   $TranslationAuthors: None $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _intro-tutorial04:

=================================================
Escrevendo sua primeira aplicação Django, parte 4
=================================================

Este tutorial inicia-se onde o:ref:`Tutorial 3 <intro-tutorial03>` terminou.
Estamos continuando a aplicação Web de Enquete e vai focar em uma forma simples
de processamnto de formulario e a redução de nosso código.

Escreva um simples formulário
=============================

Vamos atualizar o template de detalhes da enquete ("polls/detail.html") do último
tutorial, para que ele contenha um elemento HTML <Form>:

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %}

    <form action="/polls/{{ poll.id }}/vote/" method="post">
    {% for choice in poll.choice_set.all %}
        <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}" />
        <label for="choice{{ forloop.counter }}">{{ choice.choice }}</label><br />
    {% endfor %}
    <input type="submit" value="Vote" />
    </form>

Uma rápida explicação:

    * O template acima exibe um botão radio para cada opção da enquete.
      O ``value`` de cada botão radio está associado ao ID da opção.
      O ``name`` de cada botão radio é a escolha (``choice``). Isso significa
      que, quando alguém escolhe um dos botões de radio e submete a formulário,
      ele vai enviar ``choice=3`` por POST. Este são os formulários HTML 101.

    * Nós definimos o parametro ``action`` do formulário para
      /polls/{{ poll.id }}/vote/, e setamos ``method=post``. Usando ``method=post``
      (em vez de ``method=get``) é muito importante, porque o ato de enviar este
      formulário irá alterar dados do lado servidor. Sempre que criar um
      formulário que modifique os dados do lado do servidor, utilize 
      ``method="post"``. Esta dica não é específica do Django; mais sim uma boa
      prática para o desenvolvimento é Web.

    * ``forloop.counter`` indica quantas vezes a tag :ttag`for` atravessou o seu
      ciclo.

Agora, vamos criar uma ``view`` Django que manipula os dados submetidos e faz
algo com eles. Lembre-se, no :ref:`Tutorial 3 <intro-tutorial03>`, criámos uma
URLconf para a aplicação de enquete que inclui esta linha::

    (r'^(?P<poll_id>\d+)/vote/$', 'mysite.polls.views.vote'),

Entao, vamos criar um função ``vote()`` em ``mysite/polls/views.py``::

    from django.shortcuts import get_object_or_404, render_to_response
    from django.http import HttpResponseRedirect
    from django.core.urlresolvers import reverse
    from mysite.polls.models import Choice, Poll
    # ...
    def vote(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        try:
            selected_choice = p.choice_set.get(pk=request.POST['choice'])
        except (KeyError, Choice.DoesNotExist):
            # Redisplay the poll voting form.
            return render_to_response('polls/detail.html', {
                'poll': p,
                'error_message': "You didn't select a choice.",
            })
        else:
            selected_choice.votes += 1
            selected_choice.save()
            # Always return an HttpResponseRedirect after successfully dealing
            # with POST data. This prevents data from being posted twice if a
            # user hits the Back button.
            return HttpResponseRedirect(reverse('mysite.polls.views.results', args=(p.id,)))

Este código inclui algumas coisas que ainda não foram cobertos, neste tutorial:

    * :attr:`request.POST <django.http.HttpRequest.POST>` é um objeto como
      dicionários que lhe permite acessar os dados submetidos pelas suas chaves.
      Neste caso, ``request.POST['choice']`` retorna o ID da opção selecionada,
      tal como uma string. Os valores de :attr:`request.POST
      <django.http.HttpRequest.POST>` são sempre strings.

      Note que Django também prove :attr:`request.GET 
      <django.http.HttpRequest.GET>` para acesar dados GET da mesma forma -- mas
      nós estamos usando :attr:`request.GET <django.http.HttpRequest.GET>`
      explicitamente no nosso código, para garantir que os dados só podem ser
      alterados por meio de uma chamada POST.

    * ``request.POST['choice']`` irá levantar a exceção :exc:`KeyError` caso uma
      ``choice`` não seja fornecida via POST. O código acima checa por 
      :exc:`KeyError` e re-exibe o formulário da enquete com as mensagens de
      erro se uma ``choice`` não é fornecida.
 
    * Após incrementar uma opção, o código retorna um
      :class:`~django.http.HttpResponseRedirect` em vez de um normal
      :class:`~django.http.HttpResponse`.
      :class:`~django.http.HttpResponseRedirect`` recebe um único argumento:
      a URL para o qual o usuário será redirecionado (veja o ponto
      seguinte para saber como nos construimos a URL, neste caso).

      Como o comentário Python acima salienta, você deve sempre retornar uma
      :class:`~django.http.HttpResponseRedirect` depois de lidar com sucesso com
      dados POST. Esta dica não é específica do Django; mais sim uma boa prática
      para o desenvolvimento Web.

      As the Python comment above points out, you should always return an
      :class:`~django.http.HttpResponseRedirect` after successfully dealing with
      POST data. This tip isn't specific to Django; it's just good Web
      development practice.

    * Estamos usando a função :func:`~django.core.urlresolvers.reverse` no
      contrutor do class:`~django.http.HttpResponseRedirect` neste exemplo.
      Essa função ajuda a evitar ter que escrever na mão a URL na função view.
      É dado o nome da view de que queremos passar o controle e uma porção da
      variável do padrão de URL que aponta para essa view. Neste caso, usando o
      URLConf criado no Tutorial 3, esta chamada a
      :func:`~django.core.urlresolvers.reverse` irá retornar uma string como::

        '/polls/3/results/'

      ... Onde o ``3`` é o valor de ``p.id``. Esta URL redirecionada irá então
      chamar a view``'results'`` afim de exibir a página final. Note que você 
      precisará usar o nome completo da ``view`` aqui (incluindo o prefixo).


Como mencionado no Tutorial 3, ``request`` é um objeto 
:class:`~django.http.HttpRequest`. Para mais informações sobre o objeto 
:class:`~django.http.HttpRequest`, veja :ref:` documentacao do request e
response <ref-request-response>`.


Depois que alguém votar em uma enquete, a view ``vote()``  redireciona para a
página de resultados da enquete. Vamos escrever essa ``view``::

    def results(request, poll_id):
        p = get_object_or_404(Poll, pk=poll_id)
        return render_to_response('polls/results.html', {'poll': p})

Isto é quase exatamente o mesmo que a view ``detail()`` do :ref:`Tutorial 3
<intro-tutorial03>`. A única diferença é o nome do template. Iremos corrigir
esta redundância depois.

Agora, crie um template ``results.html``::

.. code-block:: html+django

    <h1>{{ poll.question }}</h1>

    <ul>
    {% for choice in poll.choice_set.all %}
        <li>{{ choice.choice }} -- {{ choice.votes }} vote{{ choice.votes|pluralize }}</li>
    {% endfor %}
    </ul>

Agora, vá para ``/polls/1/`` no seu navegador e vote em uma enquete. Você deverá
ver uma página de resultados que será atualizado cada vez que você votar. Se
você enviar o formulário sem ter escolhido uma opção, você deverá ver a mensagem
de erro.

Use generic views: Less code is better
======================================

The ``detail()`` (from :ref:`Tutorial 3 <intro-tutorial03>`) and ``results()``
views are stupidly simple -- and, as mentioned above, redundant. The ``index()``
view (also from Tutorial 3), which displays a list of polls, is similar.

These views represent a common case of basic Web development: getting data from
the database according to a parameter passed in the URL, loading a template and
returning the rendered template. Because this is so common, Django provides a
shortcut, called the "generic views" system.

Generic views abstract common patterns to the point where you don't even need
to write Python code to write an app.

Let's convert our poll app to use the generic views system, so we can delete a
bunch of our own code. We'll just have to take a few steps to make the
conversion.

.. admonition:: Why the code-shuffle?

    Generally, when writing a Django app, you'll evaluate whether generic views
    are a good fit for your problem, and you'll use them from the beginning,
    rather than refactoring your code halfway through. But this tutorial
    intentionally has focused on writing the views "the hard way" until now, to
    focus on core concepts.

    You should know basic math before you start using a calculator.

First, open the ``polls/urls.py`` URLconf. It looks like this, according to the
tutorial so far::

    from django.conf.urls.defaults import *

    urlpatterns = patterns('mysite.polls.views',
        (r'^$', 'index'),
        (r'^(?P<poll_id>\d+)/$', 'detail'),
        (r'^(?P<poll_id>\d+)/results/$', 'results'),
        (r'^(?P<poll_id>\d+)/vote/$', 'vote'),
    )

Change it like so::

    from django.conf.urls.defaults import *
    from mysite.polls.models import Poll

    info_dict = {
        'queryset': Poll.objects.all(),
    }

    urlpatterns = patterns('',
        (r'^$', 'django.views.generic.list_detail.object_list', info_dict),
        (r'^(?P<object_id>\d+)/$', 'django.views.generic.list_detail.object_detail', info_dict),
        url(r'^(?P<object_id>\d+)/results/$', 'django.views.generic.list_detail.object_detail', dict(info_dict, template_name='polls/results.html'), 'poll_results'),
        (r'^(?P<poll_id>\d+)/vote/$', 'mysite.polls.views.vote'),
    )

We're using two generic views here:
:func:`~django.views.generic.list_detail.object_list` and
:func:`~django.views.generic.list_detail.object_detail`. Respectively, those two
views abstract the concepts of "display a list of objects" and "display a detail
page for a particular type of object."

    * Each generic view needs to know what data it will be acting upon. This
      data is provided in a dictionary. The ``queryset`` key in this dictionary
      points to the list of objects to be manipulated by the generic view.

    * The :func:`~django.views.generic.list_detail.object_detail` generic view
      expects the ID value captured from the URL to be called ``"object_id"``,
      so we've changed ``poll_id`` to ``object_id`` for the generic views.

    * We've added a name, ``poll_results``, to the results view so that we have
      a way to refer to its URL later on (see the documentation about
      :ref:`naming URL patterns <naming-url-patterns>` for information). We're
      also using the :func:`~django.conf.urls.default.url` function from
      :mod:`django.conf.urls.defaults` here. It's a good habit to use
      :func:`~django.conf.urls.defaults.url` when you are providing a pattern
      name like this.

By default, the :func:`~django.views.generic.list_detail.object_detail` generic
view uses a template called ``<app name>/<model name>_detail.html``. In our
case, it'll use the template ``"polls/poll_detail.html"``. Thus, rename your
``polls/detail.html`` template to ``polls/poll_detail.html``, and change the
:func:`~django.shortcuts.render_to_response` line in ``vote()``.

Similarly, the :func:`~django.views.generic.list_detail.object_list` generic
view uses a template called ``<app name>/<model name>_list.html``. Thus, rename
``polls/index.html`` to ``polls/poll_list.html``.

Because we have more than one entry in the URLconf that uses
:func:`~django.views.generic.list_detail.object_detail` for the polls app, we
manually specify a template name for the results view:
``template_name='polls/results.html'``. Otherwise, both views would use the same
template. Note that we use ``dict()`` to return an altered dictionary in place.

.. note:: :meth:`django.db.models.QuerySet.all` is lazy

    It might look a little frightening to see ``Poll.objects.all()`` being used
    in a detail view which only needs one ``Poll`` object, but don't worry;
    ``Poll.objects.all()`` is actually a special object called a
    :class:`~django.db.models.QuerySet`, which is "lazy" and doesn't hit your
    database until it absolutely has to. By the time the database query happens,
    the :func:`~django.views.generic.list_detail.object_detail` generic view
    will have narrowed its scope down to a single object, so the eventual query
    will only select one row from the database.

    If you'd like to know more about how that works, The Django database API
    documentation :ref:`explains the lazy nature of QuerySet objects
    <querysets-are-lazy>`.

In previous parts of the tutorial, the templates have been provided with a
context that contains the ``poll`` and ``latest_poll_list`` context variables.
However, the generic views provide the variables ``object`` and ``object_list``
as context. Therefore, you need to change your templates to match the new
context variables. Go through your templates, and modify any reference to
``latest_poll_list`` to ``object_list``, and change any reference to ``poll``
to ``object``.

You can now delete the ``index()``, ``detail()`` and ``results()`` views
from ``polls/views.py``. We don't need them anymore -- they have been replaced
by generic views.

The ``vote()`` view is still required. However, it must be modified to match the
new context variables. In the :func:`~django.shortcuts.render_to_response` call,
rename the ``poll`` context variable to ``object``.

The last thing to do is fix the URL handling to account for the use of generic
views. In the vote view above, we used the
:func:`~django.core.urlresolvers.reverse` function to avoid hard-coding our
URLs. Now that we've switched to a generic view, we'll need to change the
:func:`~django.core.urlresolvers.reverse` call to point back to our new generic
view. We can't simply use the view function anymore -- generic views can be (and
are) used multiple times -- but we can use the name we've given::

    return HttpResponseRedirect(reverse('poll_results', args=(p.id,)))

Run the server, and use your new polling app based on generic views.

For full details on generic views, see the :ref:`generic views documentation
<topics-http-generic-views>`.

Coming soon
===========

The tutorial ends here for the time being. Future installments of the tutorial
will cover:

    * Advanced form processing
    * Using the RSS framework
    * Using the cache framework
    * Using the comments framework
    * Advanced admin features: Permissions
    * Advanced admin features: Custom JavaScript

In the meantime, you might want to check out some pointers on :ref:`where to go
from here <intro-whatsnext>`
