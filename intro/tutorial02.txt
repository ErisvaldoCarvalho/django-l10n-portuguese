..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9368 $
..   $TranslationAuthors: Anderson Santos $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..

.. _intro-tutorial02:

=================================================
Escrevendo sua primeira aplicação Django, parte 2
=================================================

Este tutorial inicia-se onde o :ref:`Tutorial 1 <intro-tutorial01>` terminou.
Vamos continuar a aplicação web de enquete focando agora no site de administração
automática do Django.

.. admonition:: Filosofia

    Gerar sites de administração para sua equipe ou clientes adicionarem,
    editarem ou excluírem conteúdo é um trabalho entediante que não requer
    muita criatividade. Por essa razão, o Django automatiza toda a criação da
    interface de administração para modelos.

    O Django foi desenvolvido em um ambiente de redacao, onde havia
    uma clara separação entre "produtores de conteúdo" e o site "público".
    Gerentes de site usam o sistema para adicionar notícias, eventos,
    resultado de esportes, etc, e o conteúdo é exibido no site público. O
    Django soluciona o problema de criar uma interface unificada para os
    administradores editarem o conteúdo.

    A administração não foi desenvolvida necessariamente para ser usada pelos
    visitantes do site, mas sim pelos gerentes.

Ative o site de administração do Django
=======================================

O site de administração não vem ativado por padrão -- ele é opcional. Para
ativá-lo para sua instalação, siga estes três passos:

    * Adicione ``"django.contrib.admin"`` às suas configurações de
      :setting:`INSTALLED_APPS`.

    * Execute ``python manage.py syncdb``. Já que uma nova aplicação foi
      adicionada ao :setting:`INSTALLED_APPS`, as tabelas do banco de dados
      precisam ser atualizadas.

    * Edite seu arquivo ``meusite/urls.py`` e retire o comentário das linhas
      abaixo de "Uncomment the next two lines...". Esse arquivo é um URLconf;
      entraremos em detalhes sobre URLconfs no próximo tutorial. Por enquanto,
      tudo o que você tem a saber é que ele mapeia as URL principais para as
      aplicações. No final você deve ter um ``urls.py`` parecido com este:

      .. parsed-literal::

          from django.conf.urls.defaults import *

          # Uncomment the next two lines to enable the admin:
          **from django.contrib import admin**
          **admin.autodiscover()**

          urlpatterns = patterns('',
              # Example:
              # (r'^mysite/', include('mysite.foo.urls')),

              # Uncomment the admin/doc line below and add 'django.contrib.admindocs'
              # to INSTALLED_APPS to enable admin documentation:
              # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

              # Uncomment the next line to enable the admin:
              **(r'^admin/(.*)', admin.site.root),**
          )

      (As linhas em negrito são as que precisam ser descomentadas.)

Inicie o servidor de desenvolvimento
====================================

Vamos iniciar o servidor de desenvolvimento e explorar o site de administração.

Lembre-se do Tutorial 1 onde você iniciou o servidor com:

.. code-block:: bash

    python manage.py runserver

Agora, abra o navegador de internet e vá para "/admin/" no seu domínio local --
e.g., http://127.0.0.1:8000/admin/. Você deverá ver a tela de login:

.. image:: _images/admin01.png
   :alt:  Tela de login do Django admin

Entre no site de administração
==============================

Agora tente acessar o sistema. (Você criou uma conta de superusuário na
primeira parte deste tutorial, lembra?). Você deverá ver a página inicial do
Django admin:

.. image:: _images/admin02t.png
   :alt: Página inicial do Django admin

Você deverá ver alguns outros tipos de conteúdos editáveis, incluindo grupos,
usuários e sites. Essas são as funcionalidades centrais que o Django inclui por
padrão.

Torne a aplicação de enquetes editável no site de administração
===============================================================

Mas onde está nossa aplicação de enquete? Ela não está visível na página
principal do admin.

Somente uma coisa para ser feita: Nos temos que dizer para o site de
administração que os objetos "Poll" possuem uma interface de administração.
Para fazer isto, crie um arquivo chamado ``admin.py`` em seu diretorio ``polls``,
E edite para que se pareca com isto::

    from mysite.polls.models import Poll
    from django.contrib import admin

    admin.site.register(Poll)

Você precisara reiniciar o servidor de desenvolvimento para ver suas modificações.
Normalmente, o servidor recarregar automaticamente toda a vez que você modifica
um arquivo, mais a ação de criar um novo arquivo não dispara a logica de
recargar automaticamente.

Explore a funcionalidade de administração gratuita
==================================================

Agora que nós registramos ``Poll``, o Django sabe que ele deve ser exibida na
página principal do site de administração:

.. image:: _images/admin03t.png
   :alt: Página principal de administração, agora com enquetes exibidas

Clique em "Polls". Agora você está na página "lista de alteração" para
as enquetes. Essa página exibe todas as enquetes do banco de dados e deixa
que você escolha uma para alterar. Existe a enquete "What's up?" criada no
primeiro tutorial:

.. image:: _images/admin04t.png
   :alt: Lista de alteração de enquetes

Clique na enquete "What's up?" para editá-la:

.. image:: _images/admin05t.png
   :alt: Formulário de edição para a enquete

Coisas para notar aqui:

    * O formulário é gerado automaticamente para modelo Poll.

    * Os diferentes tipos de campos (:class:`~django.db.models.DateTimeField`,
      :class:`~django.db.models.CharField`) correspondem aos respectivos widgets
      HTML de inserção. Cada tipo de campo sabe como exibir a si mesmo no site de
      administração do Django.

    * Cada :class:`~django.db.models.DateTimeField` ganha um atalho JavaScript
      gratuito. Datas têm um atalho "Hoje" e um calendário popup, e horas têm
      um atalho "Agora" e um conveniente popup com listas de horas comumente
      usadas.

A parte inferior da página fornece uma série de opções:

    * Salvar -- Salva as alterações e retorna à lista para edição para este tipo
      de objeto.

    * Salvar e continuar editando -- Salva as alterações e retorna à página para
      este objeto.

    * Salvar e adicionar outro -- Salva as informações e abre um formulário em
      branco para este tipo de objeto.

    * Deletar -- Exibe uma página de confirmação de exclusão.


Altere a "Publication date" clicando nos atalhos "Hoje" e "Agora". Em seguida,
clique em "Salvar e continuar editando." Então clique em "Histórico" no canto
superior direito. Você verá uma página exibindo todas as alterações feitas neste
objeto pelo site de administração do Django, com a hora e o nome de usuário d
pessoa que fez a alteração:

.. image:: _images/admin06t.png
   :alt: Página de histórico para o objeto Poll.

Personalize o formulário de Administração
=========================================

Tire alguns minutos para apreciar todo o código que você não teve que escrever.
Quando você chama ``admin.site.register(Poll)``, o Django simplesmente permite
que você edite o objeto e "adivinha" como exibi-lo dentro do admin. Com
freqüência, você desejará controlar como o site de administração se parece e
funciona. Você fará isso informando ao Django sobre as opções que você quer
quando registra o objeto.

Vamos ver como isso funciona reordenando os campos no formulário de edição.
Substitua a linha ``admin.site.register(Poll)`` por::

    class PollAdmin(admin.ModelAdmin):
        fields = ['pub_date', 'question']

    admin.site.register(Poll, PollAdmin)

Você seguirá este padrão -- criar um objeto modelo no site de administração e então
passá-lo como segundo argumento para o ``admin.site.register()`` -- sempre que
precisar alterar as opções do site de administração para um objeto.

Essa mudança específica no código acima faz com que a "Publication date" apareça
antes do campo "Question":

.. image:: _images/admin07.png
   :alt: Os campos foram reordenados

Isso não é impressionante com apenas dois campos, mas para formulários com
dúzias deles, escolher uma ordem intuitiva é um detalhe importante para a
usabilidade.

E por falar em dúzias de campos, você pode querer dividir o formulário em
grupos (fieldsets)::

    class PollAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question']}),
            ('Date information', {'fields': ['pub_date']}),
        ]

    admin.site.register(Poll, PollAdmin)

O primeiro elemento de cada tupla em ``fieldsets`` é o título do grupo. Aqui
está a aparência do nosso formulário agora:

.. image:: _images/admin08t.png
   :alt: O formulário possui grupos para campos agora

Você pode atribuir classes HTML arbitrárias para cada grupo. O Django fornece
uma classe ``"collapse"`` que exibe um grupo particular inicialmente recolhido.
Isso é útil quando você tem um formulário longo que contém um grupo de campos
que não são comumente utilizados::

        class PollAdmin(admin.ModelAdmin):
            fieldsets = [
                (None,               {'fields': ['question']}),
                ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
            ]

.. image:: _images/admin09.png
   :alt: Grupo de campos inicialmente recolhido

Adicionando objetos relacionados
================================

OK, temos nossa página de administração de Enquetes. Mas uma ``Poll`` tem
múltiplas ``Choices``, e a página de administração não exibe as opções.

Ainda.

Há duas formas de solucionar esse problema. A primeira é registrar ``Choice``
no site de  administração, assim como fizemos com ``Poll``. Isto é fácil::

    from mysite.polls.models import Choice

    admin.site.register(Choice)

Agora "Choices" é uma opção disponível no site de administração do Django.
O formulário de "Add choice" se parece com isto:

.. image:: _images/admin10.png
   :alt: Página de admininitracao para Choice

Nesse formulário, o campo "Poll" é uma caixa de seleção contendo todas as
enquetes no banco de dados. O Django sabe que :class:`~django.db.models.ForeignKey`
deve ser representada no site de administracao como um campo ``<select>``. No
nosso caso, só existe uma enquete até agora.

Observe também o link "Add Another" ao lado de "Poll". Todo objeto com um
relacionamento de chave estrangeira para outro ganha essa opção gratuitamente.
Quando você clica em "Add Another", você terá uma janela popup com o formulário
"Add poll". Se você adicionar uma enquete na janela e clicar em "Save", o Django
salvará a enquete no banco de dados e irá dinamicamente adicionar a opção já
selecionada ao formulário "Add choice" que você está vendo.

Mas, sério, essa é uma maneira ineficiente de adicionar objetos Choice ao
sistema. Seria muito melhor se você pudesse adicionar várias opções diretamente
quando criasse um objeto Poll. Vamos fazer isso acontecer.

Remova a chamada ``register()`` do modelo Choice. Então edite o código de
registro de ``Poll`` para que fique assim::

    class ChoiceInline(admin.StackedInline):
        model = Choice
        extra = 3

    class PollAdmin(admin.ModelAdmin):
        fieldsets = [
            (None,               {'fields': ['question']}),
            ('Date information', {'fields': ['pub_date'], 'classes': ['collapse']}),
        ]
        inlines = [ChoiceInline]

    admin.site.register(Poll, PollAdmin)

Isso informa ao Django: "Objetos Choice são editados na mesma página de
administração de Poll. Por padrão, forneça campos suficientes para 3 Choices."

Carregue a página "Add poll" para ver como está:

.. image:: _images/admin11t.png
   :alt: Página Add Poll contém Choices agora

Funciona assim: Há três blocos para Choices relacionados -- como especificado
em ``extra`` --, mas a cada vez que você retorna à página de "Alteração"
para um objeto já criado, você ganha outros três slots extras.

No entanto, há um pequeno problema. Um monte de espaço na tela é tomado para
exibir todos os três objetos Choice relacionados a serem inseridos. Por essa
razão, o Django oferece uma maneira alternativa para exibir cada objeto
relacionado em uma única linha; você só precisa alterar a declaração
``ChoiceInline`` para que seja::

    class ChoiceInline(admin.TabularInline):
        #...

Com o ``TabularInline`` (em vez de ``StackedInline``), os objetos relacionados
são exibidos de uma maneira mais compacta, formatada em tabela:

.. image:: _images/admin12.png
   :alt: A página Add poll agora com opções mais compactas

Customize the admin change list
===============================

Now that the Poll admin page is looking good, let's make some tweaks to the
"change list" page -- the one that displays all the polls in the system.

Here's what it looks like at this point:

.. image:: _images/admin04t.png
   :alt: Polls change list page

By default, Django displays the ``str()`` of each object. But sometimes it'd be
more helpful if we could display individual fields. To do that, use the
``list_display`` admin option, which is a tuple of field names to display, as
columns, on the change list page for the object::

    class PollAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question', 'pub_date')

Just for good measure, let's also include the ``was_published_today`` custom
method from Tutorial 1::

    class PollAdmin(admin.ModelAdmin):
        # ...
        list_display = ('question', 'pub_date', 'was_published_today')

Now the poll change list page looks like this:

.. image:: _images/admin13t.png
   :alt: Polls change list page, updated

You can click on the column headers to sort by those values -- except in the
case of the ``was_published_today`` header, because sorting by the output of
an arbitrary method is not supported. Also note that the column header for
``was_published_today`` is, by default, the name of the method (with
underscores replaced with spaces). But you can change that by giving that
method a ``short_description`` attribute::

    def was_published_today(self):
        return self.pub_date.date() == datetime.date.today()
    was_published_today.short_description = 'Published today?'

Let's add another improvement to the Poll change list page: Filters. Add the
following line to ``PollAdmin``::

    list_filter = ['pub_date']

That adds a "Filter" sidebar that lets people filter the change list by the
``pub_date`` field:

.. image:: _images/admin14t.png
   :alt: Polls change list page, updated

The type of filter displayed depends on the type of field you're filtering on.
Because ``pub_date`` is a DateTimeField, Django knows to give the default
filter options for DateTimeFields: "Any date," "Today," "Past 7 days,"
"This month," "This year."

This is shaping up well. Let's add some search capability::

    search_fields = ['question']

That adds a search box at the top of the change list. When somebody enters
search terms, Django will search the ``question`` field. You can use as many
fields as you'd like -- although because it uses a ``LIKE`` query behind the
scenes, keep it reasonable, to keep your database happy.

Finally, because Poll objects have dates, it'd be convenient to be able to
drill down by date. Add this line::

    date_hierarchy = 'pub_date'

That adds hierarchical navigation, by date, to the top of the change list page.
At top level, it displays all available years. Then it drills down to months
and, ultimately, days.

Now's also a good time to note that change lists give you free pagination. The
default is to display 50 items per page. Change-list pagination, search boxes,
filters, date-hierarchies and column-header-ordering all work together like you
think they should.

Customize the admin look and feel
=================================

Clearly, having "Django administration" at the top of each admin page is
ridiculous. It's just placeholder text.

That's easy to change, though, using Django's template system. The Django admin
is powered by Django itself, and its interfaces use Django's own template
system. (How meta!)

Open your settings file (``mysite/settings.py``, remember) and look at the
:setting:`TEMPLATE_DIRS` setting. :setting:`TEMPLATE_DIRS` is a tuple of
filesystem directories to check when loading Django templates. It's a search
path.

By default, :setting:`TEMPLATE_DIRS` is empty. So, let's add a line to it, to
tell Django where our templates live::

    TEMPLATE_DIRS = (
        "/home/my_username/mytemplates", # Change this to your own directory.
    )

Now copy the template ``admin/base_site.html`` from within the default Django
admin template directory (``django/contrib/admin/templates``) into an ``admin``
subdirectory of whichever directory you're using in :setting:`TEMPLATE_DIRS`.
For example, if your :setting:`TEMPLATE_DIRS` includes
``"/home/my_username/mytemplates"``, as above, then copy
``django/contrib/admin/templates/admin/base_site.html`` to
``/home/my_username/mytemplates/admin/base_site.html``. Don't forget that
``admin`` subdirectory.

Then, just edit the file and replace the generic Django text with your own
site's name as you see fit.

Note that any of Django's default admin templates can be overridden. To
override a template, just do the same thing you did with ``base_site.html`` --
copy it from the default directory into your custom directory, and make
changes.

Astute readers will ask: But if :setting:`TEMPLATE_DIRS` was empty by default,
how was Django finding the default admin templates? The answer is that, by
default, Django automatically looks for a ``templates/`` subdirectory within
each app package, for use as a fallback. See the :ref:`template loader
documentation <template-loaders>` for full information.

Customize the admin index page
==============================

On a similar note, you might want to customize the look and feel of the Django
admin index page.

By default, it displays all the apps in :setting:`INSTALLED_APPS` that have been
registered with the admin application, in alphabetical order. You may want to
make significant changes to the layout. After all, the index is probably the
most important page of the admin, and it should be easy to use.

The template to customize is ``admin/index.html``. (Do the same as with
``admin/base_site.html`` in the previous section -- copy it from the default
directory to your custom template directory.) Edit the file, and you'll see it
uses a template variable called ``app_list``. That variable contains every
installed Django app. Instead of using that, you can hard-code links to
object-specific admin pages in whatever way you think is best.

When you're comfortable with the admin site, read :ref:`part 3 of this tutorial
<intro-tutorial03>` to start working on public poll views.
