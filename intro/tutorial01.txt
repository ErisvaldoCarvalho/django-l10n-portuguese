..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 9012 $
..   $TranslationAuthors: Marcelo Minholi $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..

.. _intro-tutorial01:

=================================================
Escrevendo sua primeira aplicação Django, parte 1
=================================================

Vamos aprender pelo exemplo.

Ao longo desse tutorial nós iremos guiá-lo na criação de uma aplicação básica de
enquete.

Ela irá consistir de duas partes:

    * Um site público que deixa as pessoas verem as enquetes e votarem nelas.
    * Um site de administração que deixa você adicionar, alterar e deletar
      enquetes.

Nós iremos assumir que você já tem o `Django instalado <intro-install>`. Você
pode saber se o Django está instalado rodando o interpretador interativo do
Python e digitando ``import django``. Se esse comando rodar com sucesso, sem
nenhum erro, o Django está instalado.

.. admonition:: Onde conseguir ajuda:

    Se você estiver tendo problemas no decorrer desse tutorial, por favor envie
    uma mensagem para `django-brasil`__ ou para `django-users`__ (inglês) ou 
    deixe-a em `#django-br`__ ou `#django`__ no ``irc.freenode.net`` para bater-papo
    com outros usuarios Django que devem estar aptos a ajudar.

__ http://groups.google.com/group/django-brasil
__ http://groups.google.com/group/django-users
__ irc://irc.freenode.net/django-br
__ irc://irc.freenode.net/django

Criando um projeto
==================

Se for a primeira vez que você está usando o Django você terá que preocupar-se 
com algumas configurações iniciais. A saber, você irá precisar auto-gerar
algum código para estabelecer um :term:`project` Django -- uma coleção de
configurações para uma instância do Django, incluindo configuração do banco de
dados, opções específicas do Django e configurações específicas da aplicação.

A partir da linha de comando, ``cd`` para o diretório onde você gostaria de
armazenar seu código, então execute o comando ``django-admin.py startproject
mysite``. Isso irá criar o diretório ``mysite`` no seu diretório atual.

.. admonition:: Permissões do Mac OS X

   Se você estiver usando Mac OS X, você poderá ver a mensagem "permissão
   negada" quando você tentar rodar o ``django-admin.py startproject``. Isso
   porque, em sistemas baseados no Unix como o OS X, um arquivo precisa ser
   marcado como "executável" antes que possa ser executado como um programa. Para
   fazer isso, abra o Terminal.app e navegue (usando o comando `cd`) até o
   diretório onde o :ref:`django-admin.py <ref-django-admin>` está instalado,
   então rode o comando ``chmod +x django-admin.py``.

.. note::

    Você precisará evitar dar nomes a projetos que remetam a componentes internos
    do Python ou do Django. Particularmente, isso significa que você deve evitar
    usar nomes como ``django`` (que irá conflitar com o próprio Django) ou
    ``test`` (que irá conflitar com um pacote interno do Python).

O :ref:`django-admin.py <ref-django-admin>`  deverá estar no caminho do seu
sistema se você instalou o Django via ``python setup.py``. Se ele não estiver no
caminho, você pode encontrá-lo em ``site-packages/django/bin``, onde
``site-packages`` é um diretório dentro da sua instalação do Python. Considere a
possibilidade de criar um link simbólico para o :ref:`django-admin.py 
<ref-django-admin>` a partir de algum lugar no seu caminho, como em
``/usr/local/bin``.

.. admonition:: Onde esse código deve morar?

    Se você tem experiência prévia em PHP, você deve estar acostumado a colocar o
    código dentro da raiz da pasta de documentos do seu servidor Web (em um lugar
    como ``/var/www``). Com o Django você não fará isto. Não é uma boa idéia
    colocar qualquer código Python na raiz da pasta de documentos do seu servidor
    Web, porque tem o possível risco de pessoas conseguirem ver seu
    código através da Web. Isso não é bom para a segurança.

    Coloque seu código em algum diretório **fora** da raiz da pasta de documentos,
    como em ``/home/mycode``.

Vamos olhar o que o :djadmin:`startproject` criou::

    mysite/
        __init__.py
        manage.py
        settings.py
        urls.py

Esses arquivos são:

    * :file:`__init__.py`: Um arquivo vazio que diz ao Python que esse diretório
      deve ser considerado como um pacote Python. (Leia `mais sobre pacotes`_ na
      documentação oficial do Python se você for iniciante em Python.)

    * :file:`manage.py`: Um utilitário de linha de comando que permite a você
      interagir com esse projeto Django de várias maneiras. Voce pode ler todos
      os detalhes sobre :file:`manage.py` em :ref:`ref-django-admin`.

    * :file:`settings.py`: Settings/configurações para esse projeto Django.
      :ref:`topics-settings` Ira revelar para voce tudo sobre como o settings
      funciona.

    * :file:`urls.py`: As declarações de URLs para esse projeto Django; uma 
      "tabela de conteúdos" para o seu site movido a Django. Voce pode ler mais
      sobre URLs em :ref:`topics-http-urls`.

.. _mais sobre pacotes: http://docs.python.org/tut/node8.html#packages

O servidor de desenvolvimento
-----------------------------

Vamos verificar se ele funciona. Vá para o diretório :file:`mysite`, se você
ainda não estiver nele, e rode o comando ``python manage.py runserver``. Você irá
ver a seguinte saída na sua linha de comando::

    Validating models...
    0 errors found.

    Django version 1.0, using settings 'mysite.settings'
    Development server is running at http://127.0.0.1:8000/
    Quit the server with CONTROL-C.

Você iniciou o servidor de desenvolvimento do Django, um servidor Web leve escrito
puramente em Python. Nós incluímos ele com o Django, então você pode desenvolver
coisas rapidamente, sem ter que lidar com a configuração de um servidor Web de
produção -- como o Apache -- até que você esteja pronto para a produção.

Agora é uma boa hora para anotar: NÃO use esse servidor em nada relacionado a um
ambiente de produção. Seu objetivo é ser utilizado apenas durante o
desenvolvimento. (Nós estamos no negócio de criar frameworks Web, não servidores
Web.)

Agora que o servidor está rodando, visite http://127.0.0.1:8000/ com seu navegador
Web. Você irá ver a página "Welcome to Django", em agradáveis tons de azul claro
pastel. Ele funcionou!

.. admonition:: Mudando a porta

    Por padrão, o comando ``runserver`` inicia o servidor de desenvolvimento na
    porta 8000. Se você quer mudar a porta do servidor, passe ela como um argumento
    na linha de comando. Por exemplo, este comando iniciará o servidor na porta
    8080:
    
    .. code-block:: bash

        python manage.py runserver 8080

    A documentação completa para o servidor de desenvolvimento está na
    referncia :djadmin:`runserver`.


Configuração do banco de dados
------------------------------

Agora, edite o :file:`settings.py`. Ele é um módulo normal do Python com variáveis
representando as configurações do Django. Altere essas configurações para que
atendam aos parâmetros de conexão do seu banco de dados:

    * :setting:`DATABASE_ENGINE` -- Um entre 'postgresql_psycopg2', 'mysql' ou
      'sqlite3'.      Outros backends também :setting:`estão disponíveis 
      <DATABASE_ENGINE>`.

    * :setting:`DATABASE_NAME` -- O nome do seu banco de dados, e você estiver
      usando SQLite, o banco de dados sera uma arquivo no se computador; neste
      caso, ``DATABASE_NAME`` deve ser o caminho completo, incluindo o nome, para
      este arquivo. Se este arquivo nao existir, ele sera automaticamente criado
      quando voce sincronizar o banco de dados pela primeira vez (veja abaixo).

      Quando estiver especificndo o caminho, sempre use barra normal ate mesmo
      no Windows (e.g. ``C:/homes/user/mysite/sqlite3.db``).

    * ``DATABASE_USER`` -- Usuário do seu banco de dados (não utilizado para o
      SQLite).

    * ``DATABASE_PASSWORD`` -- Senha do seu banco de dados (não utilizado para o
      SQLite).

    * ``DATABASE_HOST`` -- O host onde seu banco de dados está. Deixe isso em
      branco se o seu servidor de banco de dados está na mesma máquina física
      (não utilizado para o SQLite).

Se voce ainda nao conhece banco de dados, nos recomendamos simplesment usar
SQLite (configurando :setting:`DATABASE_ENGINE` para ``'sqlite3'``). SQLite é
incluido como parte do Python 2.5 e posterior, entao voce nao precisa instalar
qualquer outra coisa.

.. admonition:: Nota

    Se você estiver usando PostgreSQL ou MySQL, certifique-se de que já tenha
    criado o banco de dados a partir desse ponto. Faça isso com "``CREATE DATABASE
    database_name;``" a partir do prompt interativo do seu banco de dados.

    Se voce esta usando SQLite voce nao precisa crear nada de antemão - o arquivo
    do banco de dado sera criado automaticamento quando ele for nescessario.

Enquanto você estiver editando o :file:`settings.py`, observe a configuração do
:setting:`INSTALLED_APPS` próximo ao final do arquivo. Aquela variável possui
os nomes de todas as aplicações Django que estiverem ativadas para essa instância
do Django. Aplicações podem ser usadas em múltiplos projetos, e você pode
empacotá-las e distribuí-las para uso de outros em seus projetos.

Por padrão, o :setting:`INSTALLED_APPS` contém as seguintes aplicações, que vêm
com o Django:

    * :mod:`django.contrib.auth` -- Um sistema de autenticação.

    * :mod:`django.contrib.contenttypes` -- Um framework para tipos de conteúdo.

    * :mod:`django.contrib.sessions` -- Um framework de sessão.

    * :mod:`django.contrib.sites` -- Um framework para gerenciamento de múltiplos
      sites com uma instalação do Django.

Essas aplicações são incluídas por padrão como uma conveniência para os casos
comuns.

Cada uma dessas aplicações faz uso de pelo menos uma tabela no banco de dados,
assim sendo, nós precisamos criar as tabelas no banco de dados antes que possamos
usá-las. Para isso rode o seguinte comando:

.. code-block:: bash

    python manage.py syncdb

O comando :djadmin:`syncdb` verifica a configuração em :setting:`INSTALLED_APPS`
e cria todas as tabelas necessárias de acordo com a configuração do banco de
dados no seu arquivo :file:`settings.py`. Você irá ver uma mensagem para cada
tabela do banco de dados que ele criar, e você irá receber um prompt perguntando
se gostaria de criar uma conta de super-usuário para o sistema de autenticação.
Vá em frente e faça isso.

Se você estiver interessado, rode o cliente de linha de comando do seu banco de
dados e digite ``\dt`` (PostgreSQL), ``SHOW TABLES;`` (MySQL), ou ``.schema``
(SQLite) para mostrar as tabelas que o Django criou.

.. admonition:: Para os minimalistas

    Como dissemos acima, as aplicações padrão são incluídas para casos comuns,
    mas nem todo mundo precisa delas. Se você não precisa de nenhuma delas,
    sinta-se livre para comentar ou deletar a(s) linha(s) apropriadas do
    :setting:`INSTALLED_APPS` antes de rodar o :djadmin:`syncdb`. O comando
    :djadmin:`syncdb` irá criar apenas as tabelas para as aplicações que
    estiverem no :setting:`INSTALLED_APPS`.

.. _creating-models:

Criando modelos
===============

Agora que seu ambiente -- um "projeto" -- está configurado, você está pronto para
começar o trabalho.

Cada aplicação que você escreve no Django consiste de um pacote Python, em algum
lugar no seu `caminho do Python`_, que seguirá uma certa convenção. O Django vem
com um utilitário que gera automaticamente a estrutura básica de diretório de uma
aplicação, então você pode se concentrar apenas em escrever código em vez de
ficar criando diretórios.

.. admonition:: Projetos vs. aplicações

    Qual é a diferença entre um projeto e uma aplicação? Uma aplicação é uma
    aplicação Web que faz alguma coisa -- ex., um sistema de blog, um banco de
    dados de registros públicos ou uma simples aplicação de enquete. Um projeto
    é uma coleção de configurações e aplicações para um determinado Web site. Um
    projeto pode conter múltiplas aplicações. Uma aplicação pode estar em
    múltiplos projetos.

Nesse tutorial nós iremos criar nossa aplicação de enquete no diretório ``mysite``,
para simplificar. Como conseqüência, a aplicação irá ser acoplada ao projet.
Assim sendo, o código Python interno da aplicação da enquete irá se referir a
``mysite.polls``. Posteriormente, nesse tutorial, nós iremos discutir como
desacoplar suas aplicações para distribuição.

Para criar sua aplicação, certifique-se de que você está no diretório
:file:`mysite` e digite esse comando:

.. code-block:: bash

    python manage.py startapp polls

Isso irá criar um diretório :file:`polls`, que irá ser apresentado desta forma::

    polls/
        __init__.py
        models.py
        views.py

Essa estrutura de diretório irá abrigar a aplicação de enquete.

O primeiro passo ao escrever uma aplicação Web de banco de dados no Django é
definir seus modelos -- essencialmente, o layout do seu banco de dados, com
metadados adicionais.

.. admonition:: Filosofia

   Um modelo é a única e definitiva fonte de dados sobre seus dados. Ele contém
   os campos essenciais e os comportamentos para os dados que você estiver
   armazenando. O Django segue o :ref:`princípio DRY <dry>`. O objetivo é
   definir seu modelo de dados em um local e automaticamente derivar coisas a
   partir dele.

Em nossa simples aplicação de enquete, nós iremos criar dois modelos: polls e
choices. Uma enquete (poll) tem uma pergunta e uma data de publicação. Uma
escolha (choice) tem dois campos: o texto da escolha e um totalizador de votos.
Cada escolha é associada a uma enquete.

Esses conceitos são representados por simples classes Python. Edite o arquivo
:file:`polls/models.py` entao ele se parecerá com isso::

    from django.db import models

    class Poll(models.Model):
        question = models.CharField(max_length=200)
        pub_date = models.DateTimeField('date published')

    class Choice(models.Model):
        poll = models.ForeignKey(Poll)
        choice = models.CharField(max_length=200)
        votes = models.IntegerField()

.. admonition:: Errors about :attr:`~django.db.models.Field.max_length`

   If Django gives you an error message saying that
   :attr:`~django.db.models.Field.max_length` is not a valid argument, you're
   most likely using an old version of Django. (This version of the tutorial is
   written for the latest development version of Django.) If you're using a
   Subversion checkout of Django's development version (see :ref:`the
   installation docs <topics-install>` for more information), you shouldn't have
   any problems.

   If you want to stick with an older version of Django, you'll want to switch
   to `the Django 0.96 tutorial`_, because this tutorial covers several features
   that only exist in the Django development version.

.. _the Django 0.96 tutorial: http://www.djangoproject.com/documentation/0.96/tutorial01/

The code is straightforward. Each model is represented by a class that
subclasses :class:`django.db.models.Model`. Each model has a number of class
variables, each of which represents a database field in the model.

Each field is represented by an instance of a :class:`~django.db.models.Field`
class -- e.g., :class:`~django.db.models.CharField` for character fields and
:class:`~django.db.models.DateTimeField` for datetimes. This tells Django what
type of data each field holds.

The name of each :class:`~django.db.models.Field` instance (e.g. ``question`` or
``pub_date`` ) is the field's name, in machine-friendly format. You'll use this
value in your Python code, and your database will use it as the column name.

You can use an optional first positional argument to a
:class:`~django.db.models.Field` to designate a human-readable name. That's used
in a couple of introspective parts of Django, and it doubles as documentation.
If this field isn't provided, Django will use the machine-readable name. In this
example, we've only defined a human-readable name for ``Poll.pub_date``. For all
other fields in this model, the field's machine-readable name will suffice as
its human-readable name.

Some :class:`~django.db.models.Field` classes have required elements.
:class:`~django.db.models.CharField`, for example, requires that you give it a
:attr:`~django.db.models.Field.max_length`. That's used not only in the database
schema, but in validation, as we'll soon see.

Finally, note a relationship is defined, using
:class:`~django.db.models.ForeignKey`. That tells Django each Choice is related
to a single Poll. Django supports all the common database relationships:
many-to-ones, many-to-manys and one-to-ones.

.. _`caminho do Python`: http://docs.python.org/tut/node8.html#SECTION008110000000000000000

Activating models
=================

That small bit of model code gives Django a lot of information. With it, Django
is able to:

    * Create a database schema (``CREATE TABLE`` statements) for this app.
    * Create a Python database-access API for accessing Poll and Choice objects.

But first we need to tell our project that the ``polls`` app is installed.

.. admonition:: Philosophy

    Django apps are "pluggable": You can use an app in multiple projects, and
    you can distribute apps, because they don't have to be tied to a given
    Django installation.

Edit the :file:`settings.py` file again, and change the
:setting:`INSTALLED_APPS` setting to include the string ``'mysite.polls'``. So
it'll look like this::

    INSTALLED_APPS = (
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.sites',
        'mysite.polls'
    )

Now Django knows ``mysite`` includes the ``polls`` app. Let's run another
command:

.. code-block:: bash

    python manage.py sql polls

You should see something similar to the following (the ``CREATE TABLE`` SQL
statements for the polls app):

.. code-block:: sql

    BEGIN;
    CREATE TABLE "polls_poll" (
        "id" serial NOT NULL PRIMARY KEY,
        "question" varchar(200) NOT NULL,
        "pub_date" timestamp with time zone NOT NULL
    );
    CREATE TABLE "polls_choice" (
        "id" serial NOT NULL PRIMARY KEY,
        "poll_id" integer NOT NULL REFERENCES "polls_poll" ("id"),
        "choice" varchar(200) NOT NULL,
        "votes" integer NOT NULL
    );
    COMMIT;

Note the following:

    * The exact output will vary depending on the database you are using.

    * Table names are automatically generated by combining the name of the app
      (``polls``) and the lowercase name of the model -- ``poll`` and
      ``choice``. (You can override this behavior.)

    * Primary keys (IDs) are added automatically. (You can override this, too.)

    * By convention, Django appends ``"_id"`` to the foreign key field name.
      Yes, you can override this, as well.

    * The foreign key relationship is made explicit by a ``REFERENCES``
      statement.

    * It's tailored to the database you're using, so database-specific field
      types such as ``auto_increment`` (MySQL), ``serial`` (PostgreSQL), or
      ``integer primary key`` (SQLite) are handled for you automatically. Same
      goes for quoting of field names -- e.g., using double quotes or single
      quotes. The author of this tutorial runs PostgreSQL, so the example
      output is in PostgreSQL syntax.

    * The :djadmin:`sql` command doesn't actually run the SQL in your database -
      it just prints it to the screen so that you can see what SQL Django thinks
      is required. If you wanted to, you could copy and paste this SQL into your
      database prompt. However, as we will see shortly, Django provides an
      easier way of committing the SQL to the database.

If you're interested, also run the following commands:

    * :djadmin:`python manage.py validate <validate>` -- Checks for any errors
      in the construction of your models.

    * :djadmin:`python manage.py sqlcustom polls <sqlcustom>` -- Outputs any
      :ref:`custom SQL statements <initial-sql>` (such as table modifications or
      constraints) that are defined for the application.

    * :djadmin:`python manage.py sqlclear polls <sqlclear>` -- Outputs the
      necessary ``DROP TABLE`` statements for this app, according to which
      tables already exist in your database (if any).

    * :djadmin:`python manage.py sqlindexes polls <sqlindexes>` -- Outputs the
      ``CREATE INDEX`` statements for this app.

    * :djadmin:`python manage.py sqlall polls <sqlall>` -- A combination of all
      the SQL from the :djadmin:`sql`, :djadmin:`sqlcustom`, and
      :djadmin:`sqlindexes` commands.

Looking at the output of those commands can help you understand what's actually
happening under the hood.

Now, run :djadmin:`syncdb` again to create those model tables in your database:

.. code-block:: bash

    python manage.py syncdb

The :djadmin:`syncdb` command runs the sql from 'sqlall' on your database for
all apps in :setting:`INSTALLED_APPS` that don't already exist in your database.
This creates all the tables, initial data and indexes for any apps you have
added to your project since the last time you ran syncdb. :djadmin:`syncdb` can
be called as often as you like, and it will only ever create the tables that
don't exist.

Read the :ref:`django-admin.py documentation <ref-django-admin>` for full
information on what the ``manage.py`` utility can do.

Playing with the API
====================

Now, let's hop into the interactive Python shell and play around with the free
API Django gives you. To invoke the Python shell, use this command:

.. code-block:: bash

    python manage.py shell

We're using this instead of simply typing "python", because ``manage.py`` sets
up the project's environment for you. "Setting up the environment" involves two
things:

    * Putting ``mysite`` on ``sys.path``. For flexibility, several pieces of
      Django refer to projects in Python dotted-path notation (e.g.
      ``'mysite.polls.models'``). In order for this to work, the ``mysite``
      package has to be on ``sys.path``.

      We've already seen one example of this: the :setting:`INSTALLED_APPS`
      setting is a list of packages in dotted-path notation.

    * Setting the ``DJANGO_SETTINGS_MODULE`` environment variable, which gives
      Django the path to your ``settings.py`` file.

.. admonition:: Bypassing manage.py

    If you'd rather not use ``manage.py``, no problem. Just make sure ``mysite``
    is at the root level on the Python path (i.e., ``import mysite`` works) and
    set the ``DJANGO_SETTINGS_MODULE`` environment variable to
    ``mysite.settings``.

    For more information on all of this, see the :ref:`django-admin.py
    documentation <ref-django-admin>`.

Once you're in the shell, explore the :ref:`database API <topics-db-queries>`::

    >>> from mysite.polls.models import Poll, Choice # Import the model classes we just wrote.

    # No polls are in the system yet.
    >>> Poll.objects.all()
    []

    # Create a new Poll.
    >>> import datetime
    >>> p = Poll(question="What's up?", pub_date=datetime.datetime.now())

    # Save the object into the database. You have to call save() explicitly.
    >>> p.save()

    # Now it has an ID. Note that this might say "1L" instead of "1", depending
    # on which database you're using. That's no biggie; it just means your
    # database backend prefers to return integers as Python long integer
    # objects.
    >>> p.id
    1

    # Access database columns via Python attributes.
    >>> p.question
    "What's up?"
    >>> p.pub_date
    datetime.datetime(2007, 7, 15, 12, 00, 53)

    # Change values by changing the attributes, then calling save().
    >>> p.pub_date = datetime.datetime(2007, 4, 1, 0, 0)
    >>> p.save()

    # objects.all() displays all the polls in the database.
    >>> Poll.objects.all()
    [<Poll: Poll object>]


Wait a minute. ``<Poll: Poll object>`` is, utterly, an unhelpful representation
of this object. Let's fix that by editing the polls model (in the
``polls/models.py`` file) and adding a
:meth:`~django.db.models.Model.__unicode__` method to both ``Poll`` and
``Choice``::

    class Poll(models.Model):
        # ...
        def __unicode__(self):
            return self.question

    class Choice(models.Model):
        # ...
        def __unicode__(self):
            return self.choice

.. admonition:: If :meth:`~django.db.models.Model.__unicode__` doesn't seem to work

   If you add the :meth:`~django.db.models.Model.__unicode__` method to your
   models and don't see any change in how they're represented, you're most
   likely using an old version of Django. (This version of the tutorial is
   written for the latest development version of Django.) If you're using a
   Subversion checkout of Django's development version (see :ref:`the
   installation docs <topics-install>` for more information), you shouldn't have
   any problems.

   If you want to stick with an older version of Django, you'll want to switch
   to `the Django 0.96 tutorial`_, because this tutorial covers several features
   that only exist in the Django development version.

.. _the Django 0.96 tutorial: http://www.djangoproject.com/documentation/0.96/tutorial01/

It's important to add :meth:`~django.db.models.Model.__unicode__` methods to
your models, not only for your own sanity when dealing with the interactive
prompt, but also because objects' representations are used throughout Django's
automatically-generated admin.

.. admonition:: Why :meth:`~django.db.models.Model.__unicode__` and not 
                :meth:`django.db.models.Model.__str__`?

    If you're familiar with Python, you might be in the habit of adding
    :meth:`django.db.models.Model.__str__` methods to your classes, not
    :meth:`~django.db.models.Model.__unicode__` methods. We use
    :meth:`~django.db.models.Model.__unicode__` here because Django models deal
    with Unicode by default. All data stored in your database is converted to
    Unicode when it's returned.

    Django models have a default :meth:`django.db.models.Model.__str__` method
    that calls :meth:`~django.db.models.Model.__unicode__` and converts the
    result to a UTF-8 bytestring. This means that ``unicode(p)`` will return a
    Unicode string, and ``str(p)`` will return a normal string, with characters
    encoded as UTF-8.

    If all of this is jibberish to you, just remember to add
    :meth:`~django.db.models.Model.__unicode__` methods to your models. With any
    luck, things should Just Work for you.

Note these are normal Python methods. Let's add a custom method, just for
demonstration::

    import datetime
    # ...
    class Poll(models.Model):
        # ...
        def was_published_today(self):
            return self.pub_date.date() == datetime.date.today()

Note the addition of ``import datetime`` to reference Python's standard
``datetime`` module.

Let's jump back into the Python interactive shell by running
``python manage.py shell`` again::

    >>> from mysite.polls.models import Poll, Choice

    # Make sure our __unicode__() addition worked.
    >>> Poll.objects.all()
    [<Poll: What's up?>]

    # Django provides a rich database lookup API that's entirely driven by
    # keyword arguments.
    >>> Poll.objects.filter(id=1)
    [<Poll: What's up?>]
    >>> Poll.objects.filter(question__startswith='What')
    [<Poll: What's up?>]

    # Get the poll whose year is 2007. Of course, if you're going through this
    # tutorial in another year, change as appropriate.
    >>> Poll.objects.get(pub_date__year=2007)
    <Poll: What's up?>

    >>> Poll.objects.get(id=2)
    Traceback (most recent call last):
        ...
    DoesNotExist: Poll matching query does not exist.

    # Lookup by a primary key is the most common case, so Django provides a
    # shortcut for primary-key exact lookups.
    # The following is identical to Poll.objects.get(id=1).
    >>> Poll.objects.get(pk=1)
    <Poll: What's up?>

    # Make sure our custom method worked.
    >>> p = Poll.objects.get(pk=1)
    >>> p.was_published_today()
    False

    # Give the Poll a couple of Choices. The create call constructs a new
    # choice object, does the INSERT statement, adds the choice to the set
    # of available choices and returns the new Choice object.
    >>> p = Poll.objects.get(pk=1)
    >>> p.choice_set.create(choice='Not much', votes=0)
    <Choice: Not much>
    >>> p.choice_set.create(choice='The sky', votes=0)
    <Choice: The sky>
    >>> c = p.choice_set.create(choice='Just hacking again', votes=0)

    # Choice objects have API access to their related Poll objects.
    >>> c.poll
    <Poll: What's up?>

    # And vice versa: Poll objects get access to Choice objects.
    >>> p.choice_set.all()
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
    >>> p.choice_set.count()
    3

    # The API automatically follows relationships as far as you need.
    # Use double underscores to separate relationships.
    # This works as many levels deep as you want; there's no limit.
    # Find all Choices for any poll whose pub_date is in 2007.
    >>> Choice.objects.filter(poll__pub_date__year=2007)
    [<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]

    # Let's delete one of the choices. Use delete() for that.
    >>> c = p.choice_set.filter(choice__startswith='Just hacking')
    >>> c.delete()

For full details on the database API, see our :ref:`Database API reference
<topics-db-queries>`.

When you're comfortable with the API, read :ref:`part 2 of this tutorial
<intro-tutorial02>` to get Django's automatic admin working.
